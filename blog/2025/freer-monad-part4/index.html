<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Tutorial: A Verified Interpreter with Side Effects | Tanner Duve </title> <meta name="author" content="Tanner Duve"> <meta name="description" content="Part of the free monads series"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tannerduve.github.io/blog/2025/freer-monad-part4/"> <script src="/assets/js/theme.js?61a71b4bf8cc88f490e9b04fb200867e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Tanner</span> Duve </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/books/">Bookshelf </a> </li> <li class="nav-item "> <a class="nav-link" href="/lean/">Lean </a> </li> <li class="nav-item "> <a class="nav-link" href="/coursework/">Coursework </a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Talks </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Tutorial: A Verified Interpreter with Side Effects</h1> <p class="post-meta"> Created on June 18, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/lean"> <i class="fa-solid fa-hashtag fa-sm"></i> lean,</a>   <a href="/blog/tag/formal-verification"> <i class="fa-solid fa-hashtag fa-sm"></i> formal-verification,</a>   <a href="/blog/tag/free-monads"> <i class="fa-solid fa-hashtag fa-sm"></i> free-monads,</a>   <a href="/blog/tag/type-theory"> <i class="fa-solid fa-hashtag fa-sm"></i> type-theory,</a>   <a href="/blog/tag/tutorial"> <i class="fa-solid fa-hashtag fa-sm"></i> tutorial</a>   ·   <a href="/blog/category/formal"> <i class="fa-solid fa-tag fa-sm"></i> Formal</a>   <a href="/blog/category/verification"> <i class="fa-solid fa-tag fa-sm"></i> Verification,</a>   <a href="/blog/category/type"> <i class="fa-solid fa-tag fa-sm"></i> Type</a>   <a href="/blog/category/theory"> <i class="fa-solid fa-tag fa-sm"></i> Theory</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>In this final section we will do a mini tutorial to show the power of the free monad by building an interpreter for an expression language with side effects. The key idea here is that the free monad lets us separate what we want to do (a syntactic description of effectful computation) from how we want to do it (interpreting and executing the effects semantically).</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#LanguageandEffects">Language and Effects</a></li> <li><a href="#Interpreter">Interpreter</a></li> <li><a href="#Verification">Verification</a></li> <li><a href="#Conclusion">Conclusion</a></li> <li><a href="#References">References</a></li> </ol> <h2 id="2-language-and-effects">2. <a name="LanguageandEffects"></a>Language and Effects</h2> <p>We begin by defining a tiny expression language, with integers, variables, addition, and division. We use the <code class="language-plaintext highlighter-rouge">Env</code> type to represent environments, which are just mappings of variables to values:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">Expr</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">val</span> : <span class="n">Int</span> <span class="o">→</span> <span class="n">Expr</span>
  <span class="o">|</span> <span class="n">var</span> : <span class="n">String</span> <span class="o">→</span> <span class="n">Expr</span>
  <span class="o">|</span> <span class="n">add</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span>
  <span class="o">|</span> <span class="n">div</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span>

<span class="n">abbrev</span> <span class="n">Env</span> := <span class="n">List</span> (<span class="n">String</span> <span class="o">×</span> <span class="n">Int</span>)
</code></pre></div></div> <p>We also define three effect types: mutable state (for the environment), errors (for failed variable lookups or division by zero), and a trace log (for inspection or debugging):</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">StateEff</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">Get</span> : <span class="n">StateEff</span> <span class="n">Env</span>
  <span class="o">|</span> <span class="n">Put</span> : <span class="n">Env</span> <span class="o">→</span> <span class="n">StateEff</span> <span class="n">Unit</span>

<span class="k">inductive</span> <span class="n">ErrorEff</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">Fail</span> : <span class="n">String</span> <span class="o">→</span> <span class="n">ErrorEff</span> <span class="n">Unit</span>

<span class="k">inductive</span> <span class="n">TraceEff</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">Log</span> : <span class="n">String</span> <span class="o">→</span> <span class="n">TraceEff</span> <span class="n">Unit</span>
</code></pre></div></div> <p>We can then define a sum/coproduct of type constructors as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FSum</span> (<span class="n">F</span> <span class="n">G</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span>) (α : <span class="kt">Type</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">inl</span> : <span class="n">F</span> α <span class="o">→</span> <span class="n">FSum</span> <span class="n">F</span> <span class="n">G</span> α
  <span class="o">|</span> <span class="n">inr</span> : <span class="n">G</span> α <span class="o">→</span> <span class="n">FSum</span> <span class="n">F</span> <span class="n">G</span> α

<span class="k">infixl</span>:<span class="mi">50</span> <span class="s">"⊕"</span> <span class="o">=&gt;</span> <span class="n">FSum</span>
</code></pre></div></div> <p>And we define our overall effect signature as the nested sum:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">Eff</span> := <span class="n">StateEff</span> <span class="err">⊕</span> (<span class="n">ErrorEff</span> <span class="err">⊕</span> <span class="n">TraceEff</span>)
</code></pre></div></div> <p>Notice how free monads are extensible in their effects. Adding a new effect is simply constructing a new datatype and adding it to the Eff definition.</p> <p>This type <code class="language-plaintext highlighter-rouge">Eff</code> is a pure description of the available commands in our language. Not what they do, just what kinds of actions exist. Our computations will now live in the type <code class="language-plaintext highlighter-rouge">FreeM Eff α</code>, which means they are pure syntax trees of abstract effects that eventually return a value of type <code class="language-plaintext highlighter-rouge">α</code>.</p> <p><strong>Lifting Effects into the Syntax Tree</strong></p> <p>To construct nodes in our effect AST, we define some helper functions that wrap each command in the FreeM monad. We first define a general way to lift an effect signature from <code class="language-plaintext highlighter-rouge">F</code> into its free monad <code class="language-plaintext highlighter-rouge">FreeM F</code>. This is the morphism <code class="language-plaintext highlighter-rouge">lift : F -&gt; FreeM F</code> in the universal property diagram:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) : <span class="n">FreeM</span> <span class="n">F</span> <span class="err">ι</span> :=
  <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">pure</span>

<span class="k">def</span> <span class="n">getEnv</span> : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Env</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inl</span> <span class="n">StateEff</span><span class="o">.</span><span class="n">Get</span>)

<span class="k">def</span> <span class="n">putEnv</span> (<span class="n">e</span> : <span class="n">Env</span>) : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Unit</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inl</span> (<span class="n">StateEff</span><span class="o">.</span><span class="n">Put</span> <span class="n">e</span>))

<span class="k">def</span> <span class="n">fail</span> (<span class="n">msg</span> : <span class="n">String</span>) : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Unit</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inr</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inl</span> (<span class="n">ErrorEff</span><span class="o">.</span><span class="n">Fail</span> <span class="n">msg</span>)))

<span class="k">def</span> <span class="n">log</span> (<span class="n">msg</span> : <span class="n">String</span>) : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Unit</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inr</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inr</span> (<span class="n">TraceEff</span><span class="o">.</span><span class="n">Log</span> <span class="n">msg</span>)))
</code></pre></div></div> <p><strong>Writing a Program</strong></p> <p>We can now write a little program. It logs a message, updates the environment, reads back a variable, and returns its increment:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">ex</span> : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Int</span> := <span class="n">do</span>
  <span class="n">log</span> <span class="s">"Starting"</span>
  <span class="n">putEnv</span> [(<span class="s">"x"</span>, <span class="mi">10</span>)
  <span class="n">let</span> <span class="n">env</span> <span class="err">←</span> <span class="n">getEnv</span>
  <span class="k">match</span> <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">⋅</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="s">"x"</span>) <span class="k">with</span>
  <span class="o">|</span> <span class="n">some</span> (<span class="n">_</span>, <span class="n">x</span>) <span class="o">=&gt;</span> <span class="n">pure</span> (<span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>)
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">do</span> <span class="n">fail</span> <span class="s">"x not found"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span>
</code></pre></div></div> <p>This “program” is constructing a tree of abstract effects independently of any execution or semantics. The calls to <code class="language-plaintext highlighter-rouge">log</code>, <code class="language-plaintext highlighter-rouge">putEnv</code>, <code class="language-plaintext highlighter-rouge">getEnv</code>, and fail are not doing anything yet, they are just nodes in a tree. When programs are represented as data structures you can do much more with them than just their operational interpretation, and you gain immense leverage and control over how you’d like to interpret them.</p> <p>This separation between syntax and semantics is the core idea. We build up a value of type <code class="language-plaintext highlighter-rouge">FreeM Eff Int</code> that describes a program in terms of its desired behavior. This value is like an AST of effects. The tree is built using the constructors pure and bind, and the functorial action of the coproduct <code class="language-plaintext highlighter-rouge">⊕</code> lets us represent multiple kinds of effects simultaneously.</p> <h2 id="3-interpreter">3. <a name="Interpreter"></a>Interpreter</h2> <p>To run a program written in <code class="language-plaintext highlighter-rouge">FreeM Eff α</code>, we must interpret its abstract syntax tree into a concrete computation. This involves defining a <strong>catamorphism</strong> — a recursive fold over the <code class="language-plaintext highlighter-rouge">FreeM</code> structure — into a semantic domain of effectful computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
</code></pre></div></div> <p>Before we can fold the entire syntax tree, we need to define how to interpret each individual effect. This is done via a <em>handler</em>, which is a function that gives meaning to each primitive operation in the effect functor <code class="language-plaintext highlighter-rouge">Eff</code>.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Eff</span> α <span class="o">→</span> <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
</code></pre></div></div> <p>This function interprets each effect label into our semantic domain of exceptions, states, traces:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">Trace</span> := <span class="n">List</span> <span class="n">String</span>

<span class="k">def</span> <span class="n">effInterp</span> : <span class="err">{</span>α : <span class="kt">Type</span><span class="err">}</span> <span class="o">→</span> <span class="n">Eff</span> α <span class="o">→</span> <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> <span class="n">StateEff</span><span class="o">.</span><span class="n">Get</span> <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">env</span> <span class="n">trace</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> (<span class="n">env</span>, <span class="n">env</span>, <span class="n">trace</span>)
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> (<span class="n">StateEff</span><span class="o">.</span><span class="n">Put</span> <span class="n">newEnv</span>) <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">trace</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> ((), <span class="n">newEnv</span>, <span class="n">trace</span>)
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inl</span> (<span class="n">ErrorEff</span><span class="o">.</span><span class="n">Fail</span> <span class="n">msg</span>)) <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inr</span> (<span class="n">TraceEff</span><span class="o">.</span><span class="n">Log</span> <span class="n">msg</span>)) <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">env</span> <span class="n">trace</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> ((), <span class="n">env</span>, <span class="n">trace</span> <span class="o">++</span> [<span class="n">msg</span>])
</code></pre></div></div> <p>This gives us the semantics for a single <code class="language-plaintext highlighter-rouge">Eff</code> node. But interpreting a full program requires recursively folding over the <code class="language-plaintext highlighter-rouge">FreeM</code> tree. Think of <code class="language-plaintext highlighter-rouge">effInterp</code> as the function which we will fold over the tree.</p> <p>We define this fold using our catamorphism:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">cataFreeM</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{</span>α β : <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span>
  (<span class="n">pureCase</span> : α <span class="o">→</span> β)
  (<span class="n">bindCase</span> : <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="o">→</span> <span class="n">F</span> <span class="err">ι</span> <span class="o">→</span> (<span class="err">ι</span> <span class="o">→</span> β) <span class="o">→</span> β)
  : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> β
<span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">pureCase</span> <span class="n">a</span>
<span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="n">bindCase</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">cataFreeM</span> <span class="n">pureCase</span> <span class="n">bindCase</span> (<span class="n">k</span> <span class="n">x</span>))
</code></pre></div></div> <p>This is saying, given a type <code class="language-plaintext highlighter-rouge">β</code> with a <code class="language-plaintext highlighter-rouge">pureCase : α → β</code> and a <code class="language-plaintext highlighter-rouge">bindCase : {ι : Type u} → F ι → (ι → β) → β</code> (making it an algebra over the free monad functor), we define a function <code class="language-plaintext highlighter-rouge">cataFreeM : FreeM F α -&gt; β</code>. This is indeed the catamorphism guaranteed by initiality of <code class="language-plaintext highlighter-rouge">FreeM F α</code>.</p> <p>We define the carrier type of our effect algebra as:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">EffAction</span> (α : <span class="kt">Type</span>) := <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
</code></pre></div></div> <p>Then we define the two parts of the algebra:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">-- Handle pure values</span>
<span class="k">def</span> <span class="n">effPure</span> <span class="err">{</span>α<span class="err">}</span> (<span class="n">a</span> : α) : <span class="n">EffAction</span> α :=
  <span class="k">fun</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> (<span class="n">a</span>, <span class="n">env</span>, <span class="n">tr</span>)

<span class="cd">-- Handle effectful operations and sequencing</span>
<span class="k">def</span> <span class="n">effStep</span> <span class="err">{</span>α<span class="err">}</span> :
    <span class="err">{ι</span> : <span class="kt">Type</span><span class="err">}</span> <span class="o">→</span> <span class="n">Eff</span> <span class="err">ι</span> <span class="o">→</span> (<span class="err">ι</span> <span class="o">→</span> <span class="n">EffAction</span> α) <span class="o">→</span> <span class="n">EffAction</span> α
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> <span class="n">StateEff</span><span class="o">.</span><span class="n">Get</span>,        <span class="n">k</span> <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=&gt;</span> <span class="n">k</span> <span class="n">env</span> <span class="n">env</span> <span class="n">tr</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> (<span class="n">StateEff</span><span class="o">.</span><span class="n">Put</span> <span class="err">σ</span>),    <span class="n">k</span> <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">_</span>   <span class="n">tr</span> <span class="o">=&gt;</span> <span class="n">k</span> () <span class="err">σ</span> <span class="n">tr</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inl</span> (<span class="n">ErrorEff</span><span class="o">.</span><span class="n">Fail</span> <span class="n">msg</span>)), <span class="n">_</span> <span class="o">=&gt;</span>
        <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span>  <span class="o">=&gt;</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inr</span> (<span class="n">TraceEff</span><span class="o">.</span><span class="n">Log</span> <span class="n">msg</span>)), <span class="n">k</span> <span class="o">=&gt;</span>
        <span class="k">fun</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=&gt;</span> <span class="n">k</span> () <span class="n">env</span> (<span class="n">tr</span> <span class="o">++</span> [<span class="n">msg</span>])
</code></pre></div></div> <p>Finally, we combine the two cases into a full interpreter via our catamorphism <code class="language-plaintext highlighter-rouge">cataFreeM</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">run</span> <span class="err">{</span>α<span class="err">}</span> : <span class="n">FreeM</span> <span class="n">Eff</span> α <span class="o">→</span> <span class="n">EffAction</span> α :=
  <span class="n">cataFreeM</span> <span class="n">effPure</span> <span class="n">effStep</span>
</code></pre></div></div> <p>This catamorphism <code class="language-plaintext highlighter-rouge">run</code> is the unique morphism from <code class="language-plaintext highlighter-rouge">FreeM Eff α</code> to our effect algebra <code class="language-plaintext highlighter-rouge">EffAction α</code> which interprets computation trees of type <code class="language-plaintext highlighter-rouge">FreeM Eff α</code> by evaluating them and executing their effects concretely.</p> <h3 id="4-verification">4. <a name="Verification"></a>Verification</h3> <p>Now that we have an interpreter, we can verify its correctness. What does correctness mean here?</p> <p>In order to check that our interpreter is correct, we need some kind of semantics for our language, i.e., an assignment of meaning to our programs. In programming language theory, this is given as a formal relation that specifies when evaluation succeeds and what result it produces.</p> <p>We’ll define a <em>big-step operational semantics</em> as an inductive relation, and then prove that the interpreter agrees with the semantics.</p> <p><strong>Semantics</strong></p> <p>We define a relation <code class="language-plaintext highlighter-rouge">EvalRel e env trace res</code> that says: under environment <code class="language-plaintext highlighter-rouge">env</code> and trace <code class="language-plaintext highlighter-rouge">trace</code>, expression <code class="language-plaintext highlighter-rouge">e</code> evaluates to result <code class="language-plaintext highlighter-rouge">res</code>. This result is either an error or a triple of the resulting value, environment, and trace. We also define a function <code class="language-plaintext highlighter-rouge">eval</code> which maps an expression to the effectful AST. Our correctness claim will then be that if <code class="language-plaintext highlighter-rouge">EvalRel e env trace res</code> holds (i.e., <code class="language-plaintext highlighter-rouge">e</code> evaluates to <code class="language-plaintext highlighter-rouge">res</code>), then our interpreter also returns <code class="language-plaintext highlighter-rouge">res</code> when run on the output of <code class="language-plaintext highlighter-rouge">eval e</code>.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">EvalRel</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (<span class="n">Int</span> <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>) <span class="o">→</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="o">|</span> <span class="n">val</span> :
    <span class="o">∀</span> <span class="n">n</span> <span class="n">env</span> <span class="n">trace</span>,
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">val</span> <span class="n">n</span>) <span class="n">env</span> <span class="n">trace</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">n</span>, <span class="n">env</span>, <span class="n">trace</span>))
<span class="o">|</span> <span class="n">var_found</span> :
    <span class="o">∀</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">v</span>,
    <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">·</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">x</span>) <span class="o">=</span> <span class="n">some</span> (<span class="n">x</span>, <span class="n">v</span>) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">var</span> <span class="n">x</span>) <span class="n">env</span> <span class="n">trace</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v</span>, <span class="n">env</span>, <span class="n">trace</span>))
<span class="o">|</span> <span class="n">var_missing</span> :
    <span class="o">∀</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span>,
    <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">·</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">x</span>) <span class="o">=</span> <span class="n">none</span> <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">var</span> <span class="n">x</span>) <span class="n">env</span> <span class="n">trace</span> (<span class="o">.</span><span class="n">error</span> <span class="n">s</span><span class="o">!</span><span class="s">"unbound variable {x}"</span>)
<span class="o">|</span> <span class="n">add</span> :
    <span class="o">∀</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span>,
    <span class="n">EvalRel</span> <span class="n">e1</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span>, <span class="n">env</span><span class="err">₂</span>, <span class="n">trace</span><span class="err">₂</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₂</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span>) <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>))
<span class="o">|</span> <span class="n">div_ok</span> :
    <span class="o">∀</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span>,
    <span class="n">v2</span> <span class="o">≠</span> <span class="mi">0</span> <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e1</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span>, <span class="n">env</span><span class="err">₂</span>, <span class="n">trace</span><span class="err">₂</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₂</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">div</span> <span class="n">e1</span> <span class="n">e2</span>) <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>))
<span class="o">|</span> <span class="n">div_zero</span> :
    <span class="o">∀</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span>,
    <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e1</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span>, <span class="n">env</span><span class="err">₂</span>, <span class="n">trace</span><span class="err">₂</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₂</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">div</span> <span class="n">e1</span> <span class="n">e2</span>) <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">error</span> <span class="s">"divide by zero"</span>)
</code></pre></div></div> <p>The function <code class="language-plaintext highlighter-rouge">eval : Expr → FreeM Eff Int</code> constructs a tree of effects representing what should happen during evaluation from an expression. This is the object our interpreter consumes.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">eval</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Int</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">val</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="n">pure</span> <span class="n">n</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">var</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">do</span>
      <span class="n">let</span> <span class="n">env</span> <span class="err">←</span> <span class="n">getEnv</span>
      <span class="k">match</span> <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">·</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">x</span>) <span class="k">with</span>
      <span class="o">|</span> <span class="n">some</span> (<span class="n">_</span>, <span class="n">v</span>) <span class="o">=&gt;</span> <span class="n">pure</span> <span class="n">v</span>
      <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">do</span>
          <span class="n">fail</span> <span class="n">s</span><span class="o">!</span><span class="s">"unbound variable {x}"</span>
          <span class="n">pure</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=&gt;</span> <span class="n">do</span>
      <span class="n">let</span> <span class="n">v1</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e1</span>
      <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e2</span>
      <span class="n">pure</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>)
  <span class="o">|</span> <span class="o">.</span><span class="n">div</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=&gt;</span> <span class="n">do</span>
      <span class="n">let</span> <span class="n">v1</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e1</span>
      <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e2</span>
      <span class="n">if</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span>
        <span class="n">fail</span> <span class="s">"divide by zero"</span>
        <span class="n">pure</span> <span class="mi">0</span>
      <span class="n">else</span>
        <span class="n">pure</span> (<span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>)
</code></pre></div></div> <p><strong>What do we want to prove?</strong></p> <p>We want to prove that <code class="language-plaintext highlighter-rouge">eval</code> followed by <code class="language-plaintext highlighter-rouge">run</code> gives the same result as the semantics. That is:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">eval_correct</span> (<span class="n">e</span> : <span class="n">Expr</span>) (<span class="n">env</span> : <span class="n">Env</span>) (<span class="n">trace</span> : <span class="n">Trace</span>)
    (<span class="n">res</span> : <span class="n">Except</span> <span class="n">String</span> (<span class="n">Int</span> <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>))
    (<span class="n">h</span> : <span class="n">EvalRel</span> <span class="n">e</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">res</span>) :
    <span class="n">run</span> (<span class="n">eval</span> <span class="n">e</span>) <span class="n">env</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">res</span>
</code></pre></div></div> <p><strong>Proof</strong></p> <p>We proceed by induction on the derivation of <code class="language-plaintext highlighter-rouge">EvalRel e env trace res</code>. In each case, we:</p> <ul> <li>Unfold the definition of <code class="language-plaintext highlighter-rouge">eval</code> for the given expression</li> <li>Use helper lemmas to simplify <code class="language-plaintext highlighter-rouge">run (p &gt;&gt;= k)</code> </li> <li>Match the result with the expected output</li> </ul> <p>These two helper lemmas simplify <code class="language-plaintext highlighter-rouge">run (p &gt;&gt;= k)</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">run_bind_ok</span> <span class="err">{</span>α β<span class="err">}</span>
    <span class="err">{</span><span class="n">p</span> : <span class="n">FreeM</span> <span class="n">Eff</span> α<span class="err">}</span> <span class="err">{</span><span class="n">k</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">Eff</span> β<span class="err">}</span>
    <span class="err">{</span><span class="n">env</span> <span class="n">env</span><span class="err">'</span> : <span class="n">Env</span><span class="err">}</span> <span class="err">{</span><span class="n">tr</span> <span class="n">tr</span><span class="err">'</span> : <span class="n">Trace</span><span class="err">}</span> <span class="err">{</span><span class="n">v</span> : α<span class="err">}</span> (<span class="n">h</span> : <span class="n">runEff</span> <span class="n">p</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="o">.</span><span class="n">ok</span> (<span class="n">v</span>, <span class="n">env</span><span class="err">'</span>, <span class="n">tr</span><span class="err">'</span>)) :
    <span class="n">runEff</span> (<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>) <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">runEff</span> (<span class="n">k</span> <span class="n">v</span>) <span class="n">env</span><span class="err">'</span> <span class="n">tr</span><span class="err">'</span> := <span class="k">by</span> <span class="o">...</span>
</code></pre></div></div> <p>The above says if <code class="language-plaintext highlighter-rouge">p</code> succeeds with <code class="language-plaintext highlighter-rouge">v</code>, then <code class="language-plaintext highlighter-rouge">p &gt;&gt;= k</code> runs <code class="language-plaintext highlighter-rouge">k v</code> next.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">run_bind_err</span> <span class="err">{</span>α β<span class="err">}</span>
    <span class="err">{</span><span class="n">p</span> : <span class="n">FreeM</span> <span class="n">Eff</span> α<span class="err">}</span> <span class="err">{</span><span class="n">k</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">Eff</span> β<span class="err">}</span>
    <span class="err">{</span><span class="n">env</span> : <span class="n">Env</span><span class="err">}</span> <span class="err">{</span><span class="n">tr</span> : <span class="n">Trace</span><span class="err">}</span> <span class="err">{</span><span class="n">msg</span> : <span class="n">String</span><span class="err">}</span> :
  <span class="n">runEff</span> <span class="n">p</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span> <span class="o">→</span>
  <span class="n">runEff</span> (<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>) <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span> <span class="o">...</span>
</code></pre></div></div> <p>This one says if <code class="language-plaintext highlighter-rouge">p</code> errors, then <code class="language-plaintext highlighter-rouge">p &gt;&gt;= k</code> errors with the same message.</p> <p>Now we can prove the theorem.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">eval_correct</span> (<span class="n">e</span> : <span class="n">Expr</span>) (<span class="n">env</span> : <span class="n">Env</span>) (<span class="n">trace</span> : <span class="n">Trace</span>)
    (<span class="n">res</span> : <span class="n">Except</span> <span class="n">String</span> (<span class="n">Int</span> <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>))
    (<span class="n">h</span> : <span class="n">EvalRel</span> <span class="n">e</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">res</span>) :
    <span class="n">runEff</span> (<span class="n">eval</span> <span class="n">e</span>) <span class="n">env</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">res</span> := <span class="k">by</span>
    <span class="n">induction</span><span class="err">'</span> <span class="n">h</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">val</span> <span class="n">z</span> <span class="n">env</span> <span class="n">trace</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">pure_eq_purePure</span>, <span class="n">runEff</span>, <span class="n">cataFreeM</span>, <span class="n">effPure</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">var_found</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">v</span> <span class="n">h</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">runEff</span>, <span class="n">eval</span>, <span class="n">getEnv</span>, <span class="n">bind_pure_comp</span>, <span class="n">lift_def</span>, <span class="n">cataFreeM</span>, <span class="n">effStep</span>, <span class="n">h</span>, <span class="n">effPure</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">var_missing</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">h</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">runEff</span>, <span class="n">eval</span>, <span class="n">bind</span>, <span class="n">getEnv</span>, <span class="n">fail</span>, <span class="n">lift_def</span>, <span class="n">cataFreeM</span>, <span class="n">effStep</span>, <span class="n">h</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">add</span> <span class="n">e</span><span class="err">₁</span> <span class="n">e</span><span class="err">₂</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span> <span class="n">h</span><span class="err">₁</span> <span class="n">h</span><span class="err">₂</span> <span class="n">ih</span><span class="err">₁</span> <span class="n">ih</span><span class="err">₂</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">bind</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₁</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₁</span> ) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v1</span> <span class="o">=&gt;</span> <span class="n">do</span>
        <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>
        <span class="n">pure</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>)) <span class="n">ih</span><span class="err">₁</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₁</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₁</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₂</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v2</span> <span class="o">=&gt;</span> <span class="n">pure</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>)) <span class="n">ih</span><span class="err">₂</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₂</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₂</span>]<span class="o">;</span> <span class="n">congr</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">div_ok</span> <span class="n">e</span><span class="err">₁</span> <span class="n">e</span><span class="err">₂</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v</span><span class="err">₁</span> <span class="n">v</span><span class="err">₂</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span> <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span> <span class="n">h</span><span class="err">₁</span> <span class="n">h</span><span class="err">₂</span> <span class="n">ih</span><span class="err">₁</span> <span class="n">ih</span><span class="err">₂</span>  <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">bind</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₁</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₁</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v1</span> <span class="o">=&gt;</span> <span class="n">do</span>
        <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>
        <span class="n">if</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> <span class="n">do</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span> <span class="n">else</span> <span class="n">pure</span> (<span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>)) <span class="n">ih</span><span class="err">₁</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₁</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₁</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₂</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=&gt;</span>
        <span class="n">if</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> <span class="n">do</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span> <span class="n">else</span> <span class="n">pure</span> (<span class="n">v</span><span class="err">₁</span> <span class="o">/</span> <span class="n">v</span><span class="err">₂</span>)) <span class="n">ih</span><span class="err">₂</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₂</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₂</span>, <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span>
      <span class="n">congr</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">div_zero</span> <span class="n">e</span><span class="err">₁</span> <span class="n">e</span><span class="err">₂</span> <span class="n">env</span><span class="err">'</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v</span><span class="err">₁</span> <span class="n">v</span><span class="err">₂</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span> <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span> <span class="n">h</span><span class="err">₁</span> <span class="n">h</span><span class="err">₂</span> <span class="n">ih</span><span class="err">₁</span> <span class="n">ih</span><span class="err">₂</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">bind</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₁</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₁</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v</span><span class="err">₁</span> <span class="o">=&gt;</span> <span class="n">do</span> <span class="n">let</span> <span class="n">v</span><span class="err">₂</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span><span class="o">;</span> <span class="n">if</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span> <span class="n">else</span> <span class="n">pure</span> (<span class="n">v</span><span class="err">₁</span> <span class="o">/</span> <span class="n">v</span><span class="err">₂</span>)) <span class="n">ih</span><span class="err">₁</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₁</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₁</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₂</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=&gt;</span> <span class="n">if</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> (<span class="n">do</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span>) <span class="n">else</span> <span class="n">pure</span> (<span class="n">v</span><span class="err">₁</span> <span class="o">/</span> <span class="n">v</span><span class="err">₂</span>)) <span class="n">ih</span><span class="err">₂</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₂</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₂</span>, <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span>
      <span class="n">simp</span> [<span class="n">pure</span>, <span class="n">fail</span>, <span class="n">lift</span>, <span class="n">runEff</span>
      <span class="n">congr</span>
</code></pre></div></div> <p>Now we have formally verified our interpreter agrees with our language semantics.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>Hopefully this article was informative and helpful in understanding free monads mathematically and gave you a glimpse of their usefulness in programming. This is the first blog post I’ve written so I’m hoping it was enjoyable. To review what we did:</p> <ul> <li> <p>We introduced the concept of free objects in mathematics, starting with vector spaces, monoids, and groups.</p> </li> <li> <p>We defined the free monad categorically as the initial algebra of a particular functor, drawing analogy to the List type.</p> </li> <li> <p>In Haskell, we implemented the standard <code class="language-plaintext highlighter-rouge">FreeM f a</code> type and gave it a Monad instance.</p> </li> <li> <p>We learned about strict positivity in dependently typed proof assistants and why the classic <code class="language-plaintext highlighter-rouge">Free</code> monad fails in Lean</p> </li> <li> <p>We introduced the Freer monad as a strictly positive solution, and showed it forms a monad for any <code class="language-plaintext highlighter-rouge">F : Type -&gt; Type</code></p> </li> <li> <p>We talked about initial algebras and how catamorphisms are canonical interpreters for effect functors, and how universal morphisms interpret free monadic computations into other monads.</p> </li> <li> <p>We defined a small expression language with three effects: state, errors, and tracing, showed how effects can be represented as data structures using the FreeM monad, and wrote an interpreter for it as a catamorphism</p> </li> <li> <p>We showed how this separation between syntax and semantics enables flexibility in evaluating and interpreting effectful languages.</p> </li> <li> <p>We showed how to define an operational semantics and prove that the interpreter agrees with it.</p> </li> </ul> <p>All this code can be found <a href="https://github.com/tannerduve/lean-playground/blob/main/LeanPlayground/freemonad.lean" rel="external nofollow noopener" target="_blank">here</a></p> <h2 id="6-references">6. <a name="References"></a>References</h2> <ul> <li> <p><a href="https://ncatlab.org/nlab/show/free+monad" rel="external nofollow noopener" target="_blank">nLab: Free Monad</a></p> </li> <li> <p><a href="https://www.seas.upenn.edu/~cis5520/22fa/lectures/stub/11-transformers/Freer.html" rel="external nofollow noopener" target="_blank">CIS 5520 Lecture Notes on Freer Monads</a></p> </li> <li> <p><em>The Dao of Functional Programming</em>, Bartosz Milewski (2025)</p> </li> <li> <p><a href="https://serokell.io/blog/introduction-to-free-monads" rel="external nofollow noopener" target="_blank">Serokell: Introduction to Free Monads</a></p> </li> <li> <p><a href="https://okmij.org/ftp/Computation/free-monad.html" rel="external nofollow noopener" target="_blank">Okmij : FreeM and Freer Monads: Putting Monads Back into Closet</a></p> </li> </ul> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2026 Tanner Duve. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?5da0d10fafc1cf3bc56f5211b70e764f"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>