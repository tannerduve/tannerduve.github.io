<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p>In the <a href="/blog/freer-monad/part-1/">last section</a>, we introduced the free monad and implemented it in Lean. In this section we will study the theory a bit more deeply, by understanding the notions of algebra and universality.</p> <h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <blockquote> <p>The essence of algebra is the formal manipulation of expressions. But what are expressions, and how do we manipulate them? The first things to observe about algebraic expressions like $2(x + y)$ or $ax^2 + bx + c$ is that there are infinitely many of them. There is a finite number of rules for making them, but these rules can be used in infinitely many combinations. This suggests that the rules are used <em>recursively</em>.</p> <ul> <li>Bartosz Milewski, The Dao of Functional Programming</li> </ul> </blockquote> <p>In this part, we will examine this connection between algebra and recursion a bit, from the perspective of category theory.</p> <p>In particular, we will explore a universal construction called an initial algebra. An initial algebra gives rise to a unique morphism that, as programmers, we can think of as an “interpreter” in a certain sense. These morphisms are often called <strong>catamorphisms</strong> in programming, and are an instance of a broader concept called a <strong>recursion scheme</strong>.</p> <p>We will then see how free monads are initial algebras giving us catamorphisms into other algebras, and how catamorphisms are essentially ways of collapsing structure, providing a way to interpret recursive data.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li> <a href="#InitialAlgebras">Initial Algebras and Inductive Types</a> <ul> <li><a href="#Algebras">Algebras and their Morphisms</a></li> <li><a href="#InductiveTypes">Lists as Initial Algebras</a></li> </ul> </li> <li><a href="#FreeMonads">Free Monads as Initial Algebras</a></li> <li><a href="#Cata">Catamorphisms as Interpreters</a></li> <li><a href="Conclusion">Conclusion</a></li> <li><a href="Exercise">Exercise</a></li> </ol> <h2 id="2-initial-algebras-and-inductive-types">2. <a name="InitialAlgebras"></a>Initial Algebras and Inductive Types</h2> <p>We begin this section with some definitions.</p> <h2 id="21-algebras-and-their-morphisms">2.1. <a name="Algebras"></a>Algebras and their Morphisms</h2> <p>Let $F : C \to C$ be an endofunctor. An <em>algebra</em> over $F$ is a pair $(A, \alpha)$ where $\alpha : FA \to A$.</p> <p>Given $F$-algebras $(A, \alpha)$ and $(B, \beta)$, $\phi : A \to B$ is an $F$-algebra morphism iff the following diagram commutes:</p> <div style="text-align: center;"> <span style="display: inline-block;"> <script type="text/tikz">
      \begin{tikzcd}[scale=2, column sep=huge, row sep=huge]
        FA && A \\
        \\
        FB && B
        \arrow["\alpha", from=1-1, to=1-3]
        \arrow["Ff"', from=1-1, to=3-1]
        \arrow["f", from=1-3, to=3-3]
        \arrow["\beta"', from=3-1, to=3-3]
      \end{tikzcd}
    </script> </span> </div> <p>$F$-algebras and their morphisms form a category, and the initial object in this category is called the <em>initial algebra</em>. That is, $(A, \alpha)$ is an initial $F$-algebra iff for any $F$-algebra $(B, \beta)$, there is a unique morphism $\phi : (A, \alpha) \to (B, \beta)$</p> <h2 id="22-lists-as-initial-algebras">2.2. <a name="InductiveTypes"></a>Lists as Initial Algebras</h2> <p>As it turns out, an inductive type is a type whose interpretation is given by an initial algebra of an endofunctor. This was mentioned in part 1 using the example of the <code class="language-plaintext highlighter-rouge">List</code> type but perhaps was not explained sufficiently. Let’s unpack it a bit. First, recall the definition of the type <code class="language-plaintext highlighter-rouge">List α</code> for an arbitrary type <code class="language-plaintext highlighter-rouge">α</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">List</span> (α : <span class="kt">Type</span> <span class="n">u</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">nil</span> : <span class="n">List</span> α
  <span class="o">|</span> <span class="n">cons</span> (<span class="n">head</span> : α) (<span class="n">tail</span> : <span class="n">List</span> α) : <span class="n">List</span> α
</code></pre></div></div> <p>This says, a list of <code class="language-plaintext highlighter-rouge">α</code>’s is either empty, OR it consists of a single <code class="language-plaintext highlighter-rouge">α</code> AND a list of <code class="language-plaintext highlighter-rouge">α</code>’s. Another way of looking at this type is, as a function which gives you a <code class="language-plaintext highlighter-rouge">List α</code> given either a <code class="language-plaintext highlighter-rouge">nil</code> or a <code class="language-plaintext highlighter-rouge">(head : α)</code> and a <code class="language-plaintext highlighter-rouge">(tail : List α)</code>.</p> <p>If you think of “or” as a sum, “and” as a product, and “empty” as a unit, we can express this function as a morphism:</p> <div style="text-align: center;"> $$ \phi: \mathbf{1} + (\alpha \times \texttt{List } \alpha) \to \texttt{List } \alpha $$ </div> <p>That is, $(\texttt{List} \alpha, \phi)$ is an <em>algebra</em> of the functor:</p> <div style="text-align: center;"> $$ F_\alpha x = \mathbf{1} + (\alpha \times x) $$ </div> <p>The next step would be to show that this is initial, ie. that there is a unique morphism from <code class="language-plaintext highlighter-rouge">List α</code> to any other algebra over $F_\alpha$. Instead of proving this mathematically, let’s just write the function in code! As it turns out, this function is already very familiar to anyone that has touched functional programming.</p> <p>Recall our functor</p> <div style="text-align: center;"> $$ F_\alpha X = \mathbf{1} + (\alpha \times X) $$ </div> <p>Or, in code if you prefer:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">ListF</span> <span class="err">{</span>α : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">X</span> : <span class="kt">Type</span> <span class="n">u</span>) : <span class="kt">Type</span> <span class="n">u</span> :=
  <span class="n">Unit</span> <span class="err">⊕</span> (α <span class="o">×</span> <span class="n">X</span>)
</code></pre></div></div> <p>An $F_\alpha$-algebra is a pair $(B, \beta)$ where $\beta : \mathbf{1} + (\alpha \times B) \to B$. That is, $\beta$ tells you how to collapse either:</p> <ul> <li>A <strong>unit</strong>, or</li> <li>A <strong>pair</strong> <code class="language-plaintext highlighter-rouge">(fst : α, snd : B)</code> </li> </ul> <p>into a single value of type <code class="language-plaintext highlighter-rouge">B</code>.</p> <p>Suppose you want to turn a list into a single value of type <code class="language-plaintext highlighter-rouge">B</code>. To do that, you need to answer two questions:</p> <ol> <li> <p>What should an empty list mean? That is, what value of <code class="language-plaintext highlighter-rouge">B</code> should <code class="language-plaintext highlighter-rouge">nil</code> become?</p> </li> <li> <p>What should a cons cell mean? That is, given a head of type <code class="language-plaintext highlighter-rouge">α</code> and a recursive result of type <code class="language-plaintext highlighter-rouge">B</code>, how do we combine them into a new <code class="language-plaintext highlighter-rouge">B</code>?</p> </li> </ol> <p>These two pieces of data:</p> <ul> <li>A base case <code class="language-plaintext highlighter-rouge">b₀ : B</code> </li> <li>A step function <code class="language-plaintext highlighter-rouge">step : α → B → B</code> </li> </ul> <p>together define a function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code>β : <span class="n">Unit</span> <span class="o">+</span> (α <span class="o">×</span> <span class="n">B</span>) <span class="o">→</span> <span class="n">B</span>
</code></pre></div></div> <p>which is exactly the shape of an algebra over $F_\alpha$.</p> <p>So any such <code class="language-plaintext highlighter-rouge">(B, b₀, step)</code> forms an $F_\alpha$-algebra.</p> <h3 id="the-unique-morphism-from-list-α">The Unique Morphism from <code class="language-plaintext highlighter-rouge">List α</code> </h3> <p>Now the magic: because <code class="language-plaintext highlighter-rouge">List α</code> is the <em>initial algebra</em> of $F_\alpha$, there exists a <em>unique morphism</em> from <code class="language-plaintext highlighter-rouge">List α</code> to any other $F_\alpha$-algebra <code class="language-plaintext highlighter-rouge">(B, β)</code>.</p> <p>This morphism is defined by recursion:</p> <ul> <li>It sends <code class="language-plaintext highlighter-rouge">nil</code> to <code class="language-plaintext highlighter-rouge">b₀</code> </li> <li>It sends <code class="language-plaintext highlighter-rouge">cons x xs</code> to <code class="language-plaintext highlighter-rouge">step x (⟦xs⟧)</code>, where <code class="language-plaintext highlighter-rouge">⟦xs⟧</code> is the interpretation of the tail</li> </ul> <p>Let’s define it in Lean:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">reduce</span> <span class="err">{</span>α β : <span class="kt">Type</span><span class="err">}</span> (<span class="n">b</span><span class="err">₀</span> : β) (<span class="n">step</span> : α <span class="o">→</span> β <span class="o">→</span> β) : <span class="n">List</span> α <span class="o">→</span> β
  <span class="o">|</span> [] <span class="o">=&gt;</span> <span class="n">b</span><span class="err">₀</span>
  <span class="o">|</span> <span class="n">x</span> :: <span class="n">xs</span> <span class="o">=&gt;</span> <span class="n">step</span> <span class="n">x</span> (<span class="n">reduce</span> <span class="n">b</span><span class="err">₀</span> <span class="n">step</span> <span class="n">xs</span>)
</code></pre></div></div> <p>This may look familiar to you if you have ever used a functional language before, in fact, this is just the <code class="language-plaintext highlighter-rouge">foldr</code> function! If you’ve ever written any functional programs you have likely used this plenty.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foldr</span> <span class="err">{</span>α β : <span class="kt">Type</span><span class="err">}</span> (<span class="n">b</span><span class="err">₀</span> : β) (<span class="n">step</span> : α <span class="o">→</span> β <span class="o">→</span> β) : <span class="n">List</span> α <span class="o">→</span> β
  <span class="o">|</span> [] <span class="o">=&gt;</span> <span class="n">b</span><span class="err">₀</span>
  <span class="o">|</span> <span class="n">x</span> :: <span class="n">xs</span> <span class="o">=&gt;</span> <span class="n">step</span> <span class="n">x</span> (<span class="n">foldr</span> <span class="n">b</span><span class="err">₀</span> <span class="n">step</span> <span class="n">xs</span>)
</code></pre></div></div> <p>In categorical terms:</p> <ul> <li> <code class="language-plaintext highlighter-rouge">List α</code> is the initial $F_\alpha$-algebra</li> <li> <code class="language-plaintext highlighter-rouge">(β, b₀, step)</code> is any other $F_\alpha$-algebra</li> <li> <code class="language-plaintext highlighter-rouge">foldr</code> is the unique morphism from the initial algebra to that target algebra</li> </ul> <p>So every time you use <code class="language-plaintext highlighter-rouge">foldr</code>, you’re using the initiality of <code class="language-plaintext highlighter-rouge">List α</code> to collapse the list into a value.</p> <h2 id="3-free-monads-as-initial-algebras">3. <a name="FreeMonads"></a>Free Monads as Initial Algebras</h2> <p>Now remember in part 1, we gave a functorial description of free monads analogously to that of lists, as follows:</p> <div style="text-align: center;"> $$ \Phi_F G = \text{Id} + F \circ G $$ </div> <p>Hopefully now this makes even more sense. But remember, the way we ended up defining free monads in Lean was not the traditional <code class="language-plaintext highlighter-rouge">Free</code> definition we had in Haskell. Due to strict positivity, we had to give a slightly trickier definition:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FreeM</span><span class="o">.</span><span class="err">{</span><span class="n">u</span>, <span class="n">v</span>, <span class="n">w</span><span class="err">}</span> (<span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span>) (α : <span class="kt">Type</span> <span class="n">w</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">pure</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α
  <span class="o">|</span> <span class="n">liftBind</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) (<span class="n">cont</span> : <span class="err">ι</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α) : <span class="n">FreeM</span> <span class="n">F</span> α
</code></pre></div></div> <p>It’s an inductive type, so it’s an initial algebra over some functor. What could this functor be? Let’s break it down a bit and try to build up what this functor looks like categorically.</p> <p>We have two constructors, which tells us we have a sum, with <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">liftBind</code> on either side. <code class="language-plaintext highlighter-rouge">pure</code> is pretty straightforward, its just an <code class="language-plaintext highlighter-rouge">α</code>, so our functor will be $\alpha + …$ followed by something. The <code class="language-plaintext highlighter-rouge">liftBind</code> constructor is a bit tricker. It’s indexed by <code class="language-plaintext highlighter-rouge">ι</code>, so we can think of <code class="language-plaintext highlighter-rouge">liftBind</code> as a <em>family</em> of constructors indexed by <code class="language-plaintext highlighter-rouge">Type u</code>. It also requires an <code class="language-plaintext highlighter-rouge">op : f ι</code> and a <code class="language-plaintext highlighter-rouge">cont : ι → FreeM f α</code>. We can represent our family of constructors as an indexed sum, and the other arguments as the usual product. The functor then looks like this:</p> <div style="text-align: center;"> $$ \Phi_F(X) := \alpha + \sum_\iota F \iota \times (\iota \to X) $$ </div> <p>To give an algebra over this functor means: given either</p> <ul> <li>a <strong>value</strong> of type <code class="language-plaintext highlighter-rouge">α</code>, or</li> <li>an <strong>index</strong> <code class="language-plaintext highlighter-rouge">ι</code>, an <strong>effect</strong> <code class="language-plaintext highlighter-rouge">op : F ι</code>, and a <strong>continuation</strong> <code class="language-plaintext highlighter-rouge">k : ι → FreeM F α</code>,</li> </ul> <p>you tell me how to return a value of type <code class="language-plaintext highlighter-rouge">FreeM F α</code>.</p> <p>So just like with <code class="language-plaintext highlighter-rouge">List</code>, we can define a morphism:</p> <div style="text-align: center;"> $$ \varphi_F : \alpha + \textstyle\sum_\iota F\ \iota \times (\iota \to \text{FreeM }F\alpha) \to \text{FreeM } F\alpha $$ </div> <p>by matching on the sum:</p> <ul> <li>If it’s an <code class="language-plaintext highlighter-rouge">inl a</code>, return <code class="language-plaintext highlighter-rouge">pure a</code> </li> <li>If it’s an <code class="language-plaintext highlighter-rouge">inr (ι, (op, k))</code>, return <code class="language-plaintext highlighter-rouge">liftBind op k</code> </li> </ul> <p>Now to show that <code class="language-plaintext highlighter-rouge">FreeM F α</code> is initial, we need to define the unique morphism from it into any other $\Phi_F$-algebra. This is just like what we did with <code class="language-plaintext highlighter-rouge">List α</code>. Given an algebra <code class="language-plaintext highlighter-rouge">(B, pureCase, bindCase)</code> — that is:</p> <ul> <li>a function <code class="language-plaintext highlighter-rouge">pureCase : α → B</code> for the <code class="language-plaintext highlighter-rouge">pure</code> case, and</li> <li>a function <code class="language-plaintext highlighter-rouge">bindCase : ∀ {ι}, F ι → (ι → B) → B</code> for the <code class="language-plaintext highlighter-rouge">liftBind</code> case,</li> </ul> <p>we want to define a function <code class="language-plaintext highlighter-rouge">⟦·⟧ : FreeM F α → B</code> that collapses the entire free monad tree into a single result of type <code class="language-plaintext highlighter-rouge">B</code>.</p> <p>Just like with <code class="language-plaintext highlighter-rouge">foldr</code> for lists, we define this function recursively:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foldFree</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{</span>α β : <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span>
  (<span class="n">pureCase</span> : α <span class="o">→</span> β)
  (<span class="n">bindCase</span> : <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="o">→</span> <span class="n">F</span> <span class="err">ι</span> <span class="o">→</span> (<span class="err">ι</span> <span class="o">→</span> β) <span class="o">→</span> β)
  : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> β
<span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">pureCase</span> <span class="n">a</span>
<span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="n">bindCase</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">foldFree</span> <span class="n">pureCase</span> <span class="n">bindCase</span> (<span class="n">k</span> <span class="n">x</span>))
</code></pre></div></div> <p>This is the fold analogue for the free monad: the unique morphism from the initial algebra <code class="language-plaintext highlighter-rouge">FreeM F α</code> to any other algebra <code class="language-plaintext highlighter-rouge">(β, pureCase, bindCase)</code>. It lets us “run” or “collapse” a free monadic structure by specifying what to do at each node of the tree.</p> <h2 id="4-catamorphisms-as-interpreters">4. <a name="Cata"></a>Catamorphisms as Interpreters</h2> <p>We’ve now seen two initial algebras and described their unique outgoing morphisms as ways of “folding” or “collapsing” their data into another value. In functional programming, there is a word for the unique morphism from an initial algebra - a <strong>catamorphism</strong>. This is a generalization of folding that allows you to collapse structured data from an initial algebra into a single value. More precisely, a catamorphism is the unique function from an inductive type to any algebra over its defining functor, which folds the recursive structure into some value and respects the algebra’s semantics.</p> <p>In the case of the free monad, the separation of syntax and semantics provides additional freedom in how programs are interpreted. Given a computation tree defined by a free monad, one can evaluate its value, execute its effects, pretty print its nodes, or anything else all by selecting the appropriate target algebra for its catamorphism. We will put this to use in part 4, where we build and verify an interpreter for a small effectful language.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>In this post, we explored how free monads arise as initial algebras over a particular functor, and how this initiality gives rise to a unique morphism—called a catamorphism—that collapses or interprets the structure into some other type. This construction generalizes common patterns in functional programming, such as folding over lists.</p> <h2 id="6-exercise">6. <a name="Exercise"></a>Exercise</h2> <ul> <li>Suppose <code class="language-plaintext highlighter-rouge">Tree α</code> is defined as either a <code class="language-plaintext highlighter-rouge">Leaf α</code> or a <code class="language-plaintext highlighter-rouge">Branch</code> of two subtrees. Define it as an initial algebra over an appropriate functor and write the associated <code class="language-plaintext highlighter-rouge">foldTree</code>.</li> </ul> <h2 id="continue-to-part-3---universal-morphisms"><strong>Continue to Part 3 - Universal Morphisms</strong></h2> <p><a href="/blog/freer-monad/part3/">Continue to Part 3 - Universal Morphisms</a></p> </body></html>