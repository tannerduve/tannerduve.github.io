<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Verified Dynamic Programming with Σ-types in Lean | Tanner Duve </title> <meta name="author" content="Tanner Duve"> <meta name="description" content="Solving a competitive programming problem and proving it correct with dependent types"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tannerduve.github.io/blog/2025/verified-dp/"> <script src="/assets/js/theme.js?61a71b4bf8cc88f490e9b04fb200867e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Tanner</span> Duve </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/books/">Bookshelf </a> </li> <li class="nav-item "> <a class="nav-link" href="/lean/">Lean </a> </li> <li class="nav-item "> <a class="nav-link" href="/coursework/">Coursework </a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Talks </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Verified Dynamic Programming with Σ-types in Lean</h1> <p class="post-meta"> Created on May 21, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/lean"> <i class="fa-solid fa-hashtag fa-sm"></i> lean</a>   <a href="/blog/tag/dynamic-programming"> <i class="fa-solid fa-hashtag fa-sm"></i> dynamic-programming</a>   <a href="/blog/tag/formal-verification"> <i class="fa-solid fa-hashtag fa-sm"></i> formal-verification</a>   <a href="/blog/tag/dependent-types"> <i class="fa-solid fa-hashtag fa-sm"></i> dependent-types</a>   <a href="/blog/tag/sigma-types"> <i class="fa-solid fa-hashtag fa-sm"></i> sigma-types</a>   ·   <a href="/blog/category/formal-verification"> <i class="fa-solid fa-tag fa-sm"></i> Formal-Verification</a>   <a href="/blog/category/algorithms"> <i class="fa-solid fa-tag fa-sm"></i> Algorithms</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>If you’ve taken an algorithms class, you have likely seen dynamic programming, specifically a technique called <em>memoization</em>. Memoization works to optimize recursive algorithms by <em>caching</em> the solutions to subproblems in a table, and when a subproblem is encountered, it queries the table instead of recomputing the solution. This gives us an exponential performance boost.</p> <p>This blog post will show how to solve a dynamic programming problem using memoization in Lean, and verify its correctness against a specification. The technique used in the proof of correctness here is an interesting application of Lean’s dependent types, and is generalized to work for any memoization algorithm. The idea came from a conversation with <a href="https://gasstationmanager.github.io" rel="external nofollow noopener" target="_blank">GasStationManager</a> over at the <a href="https://leanprover.zulipchat.com" rel="external nofollow noopener" target="_blank">Lean Zulip chat</a>, who I credit with coming up with the general technique.</p> <p>This should be pretty beginner friendly. Basic data structures+algorithms at the undergrad level. Lean experience is not necessary but you should be able to read functional code.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#Problem">Problem</a></li> <li><a href="#FirstSolution">First Solution</a></li> <li><a href="#Sigma">Type Theory Interlude: Subtypes and Dependent Pairs</a></li> <li><a href="#Solution">Improved Solution</a></li> <li><a href="#Conclusion">Conclusion</a></li> <li><a href="#Exercises">Exercises</a></li> <li><a href="#References">References</a></li> </ol> <h2 id="2-problem">2. <a name="Problem"></a>Problem</h2> <p>The problem we will be working on here is called <a href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/state-space-reduction/practice-problems/algorithm/bytelandian-gold-coins/" rel="external nofollow noopener" target="_blank">Bytelandian Gold Coins</a>. The problem description is as follows:</p> <blockquote> <p>In Byteland they have a very strange monetary system. Each Bytelandian gold coin has an integer number written on it. A coin n can be exchanged in a bank into three coins: n/2, n/3 and n/4. But these numbers are all rounded down (the banks have to make a profit).</p> <p>You can also sell Bytelandian coins for American dollars. The exchange rate is 1:1. But you can not buy Bytelandian coins. You have one gold coin. What is the maximum amount of American dollars you can get for it?</p> </blockquote> <p>The solution is classic DP. Observe that for any amount up to 8, we can’t get more money by dividing into $n/2, n/3, n/4$. For any value, the minimum amount we can get out of it is $n$. We will compare this value with the value we get after dividing $n$ and select the bigger value.</p> <h2 id="3-first-solution">3. <a name="FirstSolution"></a>First Solution</h2> <p>The solution is given by the following recurrence relation :</p> \[f(n)= \begin{cases} n, &amp; n \le 8,\\[6pt] \displaystyle \max\!\bigl(n,\; f(\lfloor n/2\rfloor)+f(\lfloor n/3\rfloor)+f(\lfloor n/4\rfloor)\bigr), &amp; n&gt;8. \end{cases}\] <p>Before writing any code, here is the header we’ll want to use:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">Std</span><span class="o">.</span><span class="n">Data</span><span class="o">.</span><span class="n">HashMap</span>
<span class="k">open</span> <span class="n">Std</span>
</code></pre></div></div> <p>We define the recurrence in Lean as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  <span class="n">if</span> <span class="n">n</span> <span class="o">≤</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">
  -- Base case: for `n ≤ 8`, it's better to sell the coin directly.</span>
    <span class="n">n</span>
  <span class="n">else</span><span class="cd">
  -- Recursive case: choose the maximum between selling the coin directly and exchanging it.</span>
    <span class="n">max</span> <span class="n">n</span> (<span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="o">+</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="o">+</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>))
</code></pre></div></div> <p>This directly computes the maximum earnable amount. We will use this as our specification for proving our memoized solution is correct.</p> <p>Now here is a memoized solution:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollarsMemo</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  <span class="n">let</span> <span class="n">rec</span> <span class="n">helperMemo</span> (<span class="n">n</span> : <span class="n">Nat</span>) (<span class="n">memo</span> : <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span>) : <span class="n">Nat</span> <span class="o">×</span> <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span> :=
      <span class="k">match</span> <span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="err">?</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="n">some</span> <span class="n">v</span> <span class="o">=&gt;</span> (<span class="n">v</span>, <span class="n">memo</span>)  <span class="cd">-- already cached</span>
      <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span>
        <span class="n">if</span> <span class="n">n</span> <span class="o">≤</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">          -- base case: sell coin directly</span>
          <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">memo</span><span class="o">.</span><span class="n">insert</span> <span class="n">n</span> <span class="n">n</span>
          (<span class="n">n</span>, <span class="n">memo</span><span class="err">'</span>)
        <span class="n">else</span><span class="cd">
          -- recursive: compute best exchange value, memoizing along the way</span>
          <span class="n">let</span> (<span class="n">v1</span>, <span class="n">memo1</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="n">memo</span>
          <span class="n">let</span> (<span class="n">v2</span>, <span class="n">memo2</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="n">memo1</span>
          <span class="n">let</span> (<span class="n">v3</span>, <span class="n">memo3</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>) <span class="n">memo2</span>
          <span class="n">let</span> <span class="n">best</span> := <span class="n">max</span> <span class="n">n</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">+</span> <span class="n">v3</span>)
          <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">memo3</span><span class="o">.</span><span class="n">insert</span> <span class="n">n</span> <span class="n">best</span>
          (<span class="n">best</span>, <span class="n">memo</span><span class="err">'</span>)
  (<span class="n">helperMemo</span> <span class="n">n</span> (<span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>))<span class="o">.</span><span class="n">fst</span>
</code></pre></div></div> <p>This function defines a helper which caches the solutions to subproblems in a hashmap and at each recursive call, queries the hashmap for a stored value. It then calls the helper on the empty map and returns the <code class="language-plaintext highlighter-rouge">n</code>th value <em>(Exercise : Rewrite this using a state monad to simulate mutating the hashmap instead of passing around a new one with each insertion)</em></p> <p>Now our correctness claim is as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">memo_correct</span> : <span class="o">∀</span> (<span class="n">n</span> : <span class="o">ℕ</span>), <span class="n">maxDollarsMemo</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maxDollarsSpec</span> <span class="n">n</span>
</code></pre></div></div> <p>That is, our memoized solution computes the recurrence correctly on every $n \in \mathbb{N}$. Trying to prove this ends up being <em>very</em> difficult. I invite the reader to try it out themselves and see where you get stuck. A good prover may figure it out. I attempted strong induction on $n$ to no avail and trying various approaches I kept getting stuck. The direct proof is indeed possible but the statement feels far too intuitively true to be worth this much effort. The key realization here as to what makes this proof difficult is that correctness relies on invariant properties of the data structure which we store our values in.</p> <p>First off, we need to prove that the HashMap correctly computes subproblems, that is, that <code class="language-plaintext highlighter-rouge">get? x</code> always returns either <code class="language-plaintext highlighter-rouge">none</code> or a value which is equal to <code class="language-plaintext highlighter-rouge">maxDollars_spec x</code>. We also rely on the invariant that if the HashMap satisfies this property before the call to <code class="language-plaintext highlighter-rouge">helperMemo</code>, then it satisfies this property after the call to <code class="language-plaintext highlighter-rouge">helperMemo</code>. To prove this requires reasoning about the body of <code class="language-plaintext highlighter-rouge">helperMemo</code>.</p> <p>There’s a lot of logic to juggle here in our proof, but thankfully there is a better way. A Haskeller is likely familiar with the notion of refinement types. In Lean we call them subtypes. Subtypes provide a way to attach logical properties to data using a familiar set-builder-like notation, where we can refer to the type of all elements of some type <code class="language-plaintext highlighter-rouge">T</code> for which a particular property holds. An example of a subtype is <code class="language-plaintext highlighter-rouge">{n : ℕ // Even n}</code> - the subtype of <code class="language-plaintext highlighter-rouge">ℕ</code> consisting of all of the Even natural numbers. This is all just syntactic sugar for a dependent pair type, aka $\Sigma$-types. Let’s explore these some more before moving on.</p> <h2 id="4-type-theory-interlude-subtypes-and-dependent-pairs">4. <a name="Sigma"></a>Type Theory Interlude: Subtypes and Dependent Pairs</h2> <p>This section is a brief detour into the theory of Lean’s subtypes. This is optional but I find it valuable. In dependent type theory, $\Sigma$-types are a generalization of a product type, where the type of the second element in a pair can <em>depend</em> on the value of the first element. In a non-dependent setting, the product $A \times B$ of two types $A$ and $B$ consists of all pairs $(a, b)$ where $a : A$ and $b : B$ - it’s just the standard cartesian product. The dependent pair type generalizes this.</p> <p>Suppose we have a type $A$ and a <em>family of types indexed by $A$</em>, denoted $B : A \to \mathcal{U}$ (where $\mathcal{U}$ denotes the universe of all types). Then the type $\sum_{(x : A)}B(x)$ consists of the pairs $(a, b)$ where $a : A$ and $b : B(a)$ - the <em>type</em> of $b$ <em>depends</em> on the <em>value</em> of $a$. Note that the Cartesian product is exactly the special case where $B$ is constant, ie $\displaystyle\sum_{(x : A)}B = A \times B$.</p> <p>Back to the original example, let’s think about <code class="language-plaintext highlighter-rouge">{n : ℕ // Even n}</code> in these terms. Under the <a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence" rel="external nofollow noopener" target="_blank">propositions-as-types</a> principle, the proposition <code class="language-plaintext highlighter-rouge">Even n</code> is of course just a type. But note that <code class="language-plaintext highlighter-rouge">Even n</code> is a <em>different</em> proposition for every <code class="language-plaintext highlighter-rouge">n : ℕ</code> - that is, <code class="language-plaintext highlighter-rouge">Even</code> is a <em>family</em> of types <em>indexed</em> by <code class="language-plaintext highlighter-rouge">ℕ</code>. So, the type <code class="language-plaintext highlighter-rouge">{n : ℕ // Even n}</code> is exactly the $\Sigma$-type $\sum_{n : \mathbb{N}}\text{Even}(n)$, which consists of pairs $(n, P_n)$, where $P_n$ is a <em>proof</em> that $n$ is Even.</p> <p>For a primer on dependent type theory, see chapter 1 of <a href="https://www.cs.uoregon.edu/research/summerschool/summer14/rwh_notes/hott-book.pdf" rel="external nofollow noopener" target="_blank">HoTT</a></p> <h2 id="5-improved-solution">5. <a name="Solution"></a>Improved Solution</h2> <p>Now that we’ve introduced subtypes we will put them to use by writing a new memoized algorithm that, in some sense, proves itself. Remember part of our correctness proof is showing that the HashMap’s <code class="language-plaintext highlighter-rouge">get? x</code> method always returns a <code class="language-plaintext highlighter-rouge">y</code> such that <code class="language-plaintext highlighter-rouge">maxDollars_spec x = y</code>. What if, to guarantee this, we write a new version of <code class="language-plaintext highlighter-rouge">get?</code> so that <code class="language-plaintext highlighter-rouge">get? x</code> returns a <code class="language-plaintext highlighter-rouge">y</code> in the subtype <code class="language-plaintext highlighter-rouge">{y : ℕ // maxDollars_spec x = y}</code>? To do this, we can just subtype the data which our HashMap stores.</p> <p>For the memoization, the property we want to hold is: for a pair <code class="language-plaintext highlighter-rouge">(k, v)</code> stored in your table, <code class="language-plaintext highlighter-rouge">f k = v</code> where <code class="language-plaintext highlighter-rouge">f</code> is the recursive function you are proving equivalence to (in our case, <code class="language-plaintext highlighter-rouge">f</code> is the the recurrence <code class="language-plaintext highlighter-rouge">maxDollars_spec</code>).</p> <p>Now the implementation is as follows. We begin with a very general definition: a pair of values with a property attached to it:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">cell</span> (<span class="n">f</span> : α <span class="o">→</span> β) := <span class="err">{</span><span class="n">c</span>: α <span class="o">×</span> β <span class="o">//</span> <span class="n">f</span> <span class="n">c</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">snd</span><span class="err">}</span>
</code></pre></div></div> <p>That is, given a function <code class="language-plaintext highlighter-rouge">f : α → β</code>, for example the recurrence <code class="language-plaintext highlighter-rouge">maxDollars_spec</code> above, <code class="language-plaintext highlighter-rouge">cell f</code> is the type of all pairs <code class="language-plaintext highlighter-rouge">(a, b) : α × β</code> such that <code class="language-plaintext highlighter-rouge">f a = b</code></p> <p>Our new HashMap, <code class="language-plaintext highlighter-rouge">PropMap</code>, stores keys of type <code class="language-plaintext highlighter-rouge">α</code> and values of type <code class="language-plaintext highlighter-rouge">cell f</code> whose first element is equal to the key:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">PropMap</span> [<span class="n">BEq</span> α][<span class="n">Hashable</span> α] [<span class="n">LawfulBEq</span> α] (<span class="n">f</span> : α <span class="o">→</span> β) :=
  <span class="n">HashMap</span> α (<span class="n">cell</span> <span class="n">f</span>)
</code></pre></div></div> <p>Now we can define <code class="language-plaintext highlighter-rouge">get?</code> with the guarantee we are looking for:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">PropMap_get</span><span class="err">?</span> [<span class="n">BEq</span> α][<span class="n">Hashable</span> α] [<span class="n">LawfulBEq</span> α] (<span class="n">ft</span> : α <span class="o">→</span> β) (<span class="n">hm</span> : <span class="n">PropMap</span> <span class="n">ft</span>) (<span class="n">a</span> : α) : <span class="n">Option</span> <span class="err">{</span> <span class="n">b</span> : β <span class="o">//</span> <span class="n">ft</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="err">}</span> :=
  <span class="k">match</span> <span class="n">hf</span> : <span class="n">hm</span><span class="o">.</span><span class="n">get</span><span class="err">?</span> <span class="n">a</span> <span class="k">with</span><span class="cd">  -- Attempt to get the value associated with `a` in the map.</span>
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">none</span><span class="cd">            -- If not found, return `none`.</span>
  <span class="o">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">=&gt;</span>
    <span class="n">if</span> <span class="n">heq</span> : <span class="n">a</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">fst</span> <span class="n">then</span><span class="cd">  -- Check if the key `a` matches `x.val.fst`.</span>
      <span class="k">have</span> : <span class="n">ft</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">snd</span> := <span class="k">by</span>
        <span class="k">have</span> <span class="n">hx</span> := <span class="n">x</span><span class="o">.</span><span class="n">property</span><span class="cd">       -- Extract the proof that `ft x.val.fst = x.val.snd`.</span>
        <span class="n">rw</span> [<span class="n">beq_iff_eq</span>] <span class="n">at</span> <span class="n">heq</span><span class="cd">      -- Propositional equality from boolean equality</span>
        <span class="n">rw</span> [<span class="err">←</span> <span class="n">heq</span>] <span class="n">at</span> <span class="n">hx</span><span class="cd">            -- Replace `x.val.fst` with `a` using `heq`.</span>
        <span class="n">exact</span> <span class="n">hx</span><span class="cd">                    -- Conclude that `ft a = x.val.snd`.</span>
      <span class="n">pure</span> <span class="o">⟨</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">snd</span>, <span class="n">this</span> <span class="o">⟩</span><span class="cd">     -- Return the value and proof as `some`.</span>
    <span class="n">else</span>
      <span class="n">none</span><span class="cd">  -- If the keys don't match (shouldn't happen), return `none`.</span>
</code></pre></div></div> <p>As well as an insertion function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">PropMap_insert</span> [<span class="n">BEq</span> α][<span class="n">Hashable</span> α] [<span class="n">LawfulBEq</span> α] (<span class="n">ft</span> : α <span class="o">→</span> β) (<span class="n">hm</span> : <span class="n">PropMap</span> <span class="n">ft</span>) (<span class="n">k</span> : α) (<span class="n">v</span> : β) (<span class="n">h</span> : <span class="n">ft</span> <span class="n">k</span> <span class="o">=</span> <span class="n">v</span>) : <span class="n">PropMap</span> <span class="n">ft</span> :=
  <span class="n">let</span> <span class="n">cell</span> : <span class="err">{</span> <span class="n">c</span> : α <span class="o">×</span> β <span class="o">//</span> <span class="n">ft</span> <span class="n">c</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">snd</span> <span class="err">}</span> := <span class="o">⟨</span>(<span class="n">k</span>, <span class="n">v</span>), <span class="n">h</span><span class="o">⟩</span><span class="cd">  -- Create the cell with proof.</span>
  <span class="n">hm</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">cell</span><span class="cd">  -- Insert the cell into the map at key `k`.</span>
</code></pre></div></div> <p>And now we can define our recursive helper:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">helper</span> (<span class="n">n</span> : <span class="n">Nat</span>) (<span class="n">memo</span> : <span class="n">PropMap</span> <span class="n">maxDollars_spec</span>) :
  <span class="err">{</span> <span class="n">v</span> : <span class="n">Nat</span> <span class="o">//</span> <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> <span class="err">}</span> <span class="o">×</span> <span class="n">PropMap</span> <span class="n">maxDollars_spec</span> :=
  <span class="k">match</span> <span class="n">PropMap_get</span><span class="err">?</span> <span class="n">maxDollars_spec</span> <span class="n">memo</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">some</span> <span class="n">result</span> <span class="o">=&gt;</span><span class="cd">
    -- If `n` is already in the memoization map, return the cached value and the memo.
    -- `result` has type `{ v : Nat // maxDollars_spec n = v }`.</span>
    (<span class="n">result</span>, <span class="n">memo</span>)
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span>
    <span class="n">if</span> <span class="n">h</span> : <span class="n">n</span> <span class="o">≤</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">
      -- Base case: for `n ≤ 8`.</span>
      <span class="n">let</span> <span class="n">v</span> := <span class="n">n</span>
      <span class="n">let</span> <span class="n">h_spec</span> : <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> := <span class="k">by</span> <span class="n">simp</span> [<span class="n">maxDollars_spec</span>, <span class="n">h</span><span class="cd">
      -- Prove that `maxDollars_spec n = n` using simplification.</span>
      <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">PropMap_insert</span> <span class="n">maxDollars_spec</span> <span class="n">memo</span> <span class="n">n</span> <span class="n">v</span> <span class="n">h_spec</span><span class="cd">
      -- Insert `(n, v)` with proof into the memoization map.</span>
      (<span class="o">⟨</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">⟩</span>, <span class="n">memo</span><span class="err">'</span>)
    <span class="n">else</span><span class="cd">
      -- Recursive case: compute the values for `n / 2`, `n / 3`, and `n / 4`.</span>
      <span class="n">let</span> (<span class="n">r1</span>, <span class="n">memo1</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="n">memo</span>
      <span class="n">let</span> (<span class="n">r2</span>, <span class="n">memo2</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="n">memo1</span>
      <span class="n">let</span> (<span class="n">r3</span>, <span class="n">memo3</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>) <span class="n">memo2</span><span class="cd">
      -- `r1`, `r2`, `r3` are of type `{ v : Nat // maxDollars_spec (n / x) = v }`. Basically an induction hypothesis.
      -- `memo3` is the updated memoization map after all recursive calls.</span>
      <span class="n">let</span> <span class="n">exchangeSum</span> := <span class="n">r1</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">r2</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">r3</span><span class="o">.</span><span class="n">val</span><span class="cd">  -- Sum the values obtained from recursion.</span>
      <span class="n">let</span> <span class="n">v</span> := <span class="n">max</span> <span class="n">n</span> <span class="n">exchangeSum</span><span class="cd">  -- Decide whether to sell `n` directly or exchange it.

      -- **Construct the proof that `maxDollars_spec n = v`**</span>
      <span class="k">have</span> <span class="n">h_spec</span> : <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> := <span class="k">by</span>
        <span class="n">unfold</span> <span class="n">maxDollars_spec</span><span class="cd">         -- Expand `maxDollars_spec n`.</span>
        <span class="n">rw</span> [<span class="n">if_neg</span> <span class="n">h</span>]                  <span class="cd">-- Since `n &gt; 8`, use the recursive case.</span>
        <span class="n">rw</span> [<span class="n">r1</span><span class="o">.</span><span class="n">property</span>, <span class="n">r2</span><span class="o">.</span><span class="n">property</span>, <span class="n">r3</span><span class="o">.</span><span class="n">property</span><span class="cd">

      -- Replace recursive calls with their computed values using the proofs from `r1`, `r2`, `r3`.</span>
      <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">PropMap_insert</span> <span class="n">maxDollars_spec</span> <span class="n">memo3</span> <span class="n">n</span> <span class="n">v</span> <span class="n">h_spec</span><span class="cd">
      -- Insert the computed value and its proof into the memoization map.</span>
      (<span class="o">⟨</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">⟩</span>, <span class="n">memo</span><span class="err">'</span>)  <span class="cd">-- Return the computed value with proof and the updated memo.</span>
</code></pre></div></div> <p>Look here. Subtypes require proofs that their value satisfies their logical property. Thus each time our algorithm computes a value <code class="language-plaintext highlighter-rouge">v</code> to go in our table, we also compute a proof that <code class="language-plaintext highlighter-rouge">v</code> is computed correctly according to <code class="language-plaintext highlighter-rouge">maxDollars_spec</code>. We are interleaving code and proof and essentially proving correctness <em>inside the algorithm itself</em>.</p> <p>And finally, here is our main function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollars</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  (<span class="n">helper</span> <span class="n">n</span> (<span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>))<span class="o">.1</span>
</code></pre></div></div> <p>We’ve embedded the proof into the algorithm itself: every computed value is stored together with a proof that it satisfies the spec. So to prove correctness for any n, we just apply the function — its type guarantees that the result equals maxDollars_spec n:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">maxDollars_spec_correct</span> : <span class="o">∀</span> <span class="n">n</span>, <span class="n">maxDollars</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maxDollars_spec</span> <span class="n">n</span> := <span class="k">by</span>
  <span class="n">intro</span> <span class="n">n</span>
  <span class="n">unfold</span> <span class="n">maxDollars</span>
  <span class="n">let</span> <span class="o">⟨</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">⟩</span> := (<span class="n">helper</span> <span class="n">n</span> <span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>)<span class="o">.1</span>
  <span class="n">exact</span> <span class="n">h_spec</span><span class="o">.</span><span class="n">symm</span>
</code></pre></div></div> <p>And we’re done. The algorithm has been verified.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>My goal here was to share what I learned from this technique and show how it can be applied to a particular problem. I also hope the reader came away understanding subtypes from the perspective of dependent type theory. I find intertwining code with proof in this way really cool and the people I’ve shown this to felt the same.</p> <p>To review what we did:</p> <ul> <li> <p>We introduced the Bytelandian Gold Coins problem and wrote a basic recursive specification using a natural recurrence relation.</p> </li> <li> <p>We implemented a naive memoized version using a <code class="language-plaintext highlighter-rouge">HashMap</code>, and discussed why proving its correctness directly is tough due to the difficulty of reasoning about data structure invariants.</p> </li> <li> <p>We took a detour into type theory to study subtypes and $\Sigma$-types as a way to attach logical properties to data.</p> </li> <li> <p>We defined a new form of memoization table (<code class="language-plaintext highlighter-rouge">PropMap</code>) that stores not just computed values, but also <em>proofs</em> that they were computed correctly with respect to the spec.</p> </li> <li> <p>We rewrote the algorithm so that correctness was proven incrementally, at every step, as a side effect of evaluation - embedding the proof <em>into</em> the recursion.</p> </li> <li> <p>We ended with a trivial top-level proof: correctness follows directly from the structure of the implementation.</p> </li> </ul> <p>All this code is available at <a href="https://github.com/tannerduve/coins" rel="external nofollow noopener" target="_blank">this repo</a></p> <h2 id="6-exercises">6. <a name="Exercises"></a>Exercises</h2> <p>Each of the following DP problems can be solved using the same framework introduced in this post: define a recurrence relation as a specification, write a memoized implementation that returns values paired with correctness proofs via subtypes, and prove the top-level function computes the intended result.</p> <p>Try implementing and verifying your favorite(s) of the following:</p> <ul> <li> <p><strong>Rod Cutting</strong> Given a rod of length <code class="language-plaintext highlighter-rouge">n</code> and a list of prices <code class="language-plaintext highlighter-rouge">p : List ℕ</code> where <code class="language-plaintext highlighter-rouge">p[i]</code> is the price of a rod of length <code class="language-plaintext highlighter-rouge">i + 1</code>, define:</p> \[r(n) = \max_{1 \le i \le n} (p[i{-}1] + r(n - i))\] <p>Implement <code class="language-plaintext highlighter-rouge">rodCut : ℕ → ℕ</code> using a memoization table and prove correctness</p> </li> <li> <p><strong>0/1 Knapsack</strong> Given <code class="language-plaintext highlighter-rouge">n</code> items with weights <code class="language-plaintext highlighter-rouge">w : Fin n → ℕ</code>, values <code class="language-plaintext highlighter-rouge">v : Fin n → ℕ</code>, and a maximum capacity <code class="language-plaintext highlighter-rouge">C</code>, define:</p> \[\text{knapsack}(i, c) = \begin{cases} 0, &amp; i = n \\ \text{knapsack}(i+1, c), &amp; w[i] &gt; c \\ \max(\text{knapsack}(i+1, c),\ v[i] + \text{knapsack}(i+1, c - w[i])), &amp; \text{otherwise} \end{cases}\] <p>Implement and verify <code class="language-plaintext highlighter-rouge">knapsack : ℕ → ℕ</code> using a memo table indexed by item and capacity.</p> </li> <li> <p><strong>Levenshtein Distance</strong> Given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>, define their edit/Levenshtein distance:</p> \[\text{dist}(i, j) = \begin{cases} i, &amp; j = 0 \\ j, &amp; i = 0 \\ \min\!\left( \text{dist}(i{-}1, j) + 1,\; \text{dist}(i, j{-}1) + 1,\; \text{dist}(i{-}1, j{-}1) + \text{cost} \right), &amp; \text{otherwise} \end{cases}\] <p>where <code class="language-plaintext highlighter-rouge">cost = 0</code> if <code class="language-plaintext highlighter-rouge">s[i-1] = t[j-1]</code> and <code class="language-plaintext highlighter-rouge">1</code> otherwise. Implement and verify <code class="language-plaintext highlighter-rouge">editDist : String → String → ℕ</code>.</p> </li> </ul> <p>In each case, define the specification as a recursive function, then write a subtype-verified implementation using a <code class="language-plaintext highlighter-rouge">PropMap</code> to cache and prove subproblem results. Your goal is a final theorem of the form:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">algorithm_correct</span> : <span class="o">∀</span> <span class="n">input</span>, <span class="n">algorithm</span> <span class="n">input</span> <span class="o">=</span> <span class="n">spec</span> <span class="n">input</span>
</code></pre></div></div> <h2 id="7-references">7. <a name="References"></a>References</h2> <p><a href="https://gasstationmanager.github.io/ai/2024/12/03/memoization1.html" rel="external nofollow noopener" target="_blank">Proving Memoization in Lean, And Teaching it to Sonnet</a>, GasStationManager</p> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Tanner Duve. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>