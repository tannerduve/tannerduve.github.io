<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Part 3: Universal Morphisms and Effect Handlers | Tanner Duve </title> <meta name="author" content="Tanner Duve"> <meta name="description" content="Part of the free monads series"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tannerduve.github.io/blog/2025/freer-monad-part3/"> <script src="/assets/js/theme.js?61a71b4bf8cc88f490e9b04fb200867e"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Tanner</span> Duve </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/">About <span class="sr-only">(current)</span> </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/books/">Bookshelf </a> </li> <li class="nav-item "> <a class="nav-link" href="/lean/">Lean </a> </li> <li class="nav-item "> <a class="nav-link" href="/coursework/">Coursework </a> </li> <li class="nav-item "> <a class="nav-link" href="/talks/">Talks </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Part 3: Universal Morphisms and Effect Handlers</h1> <p class="post-meta"> Created on June 16, 2025 </p> <p class="post-tags"> <a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a href="/blog/tag/lean"> <i class="fa-solid fa-hashtag fa-sm"></i> lean,</a>   <a href="/blog/tag/free-monads"> <i class="fa-solid fa-hashtag fa-sm"></i> free-monads,</a>   <a href="/blog/tag/universal-properties"> <i class="fa-solid fa-hashtag fa-sm"></i> universal-properties,</a>   <a href="/blog/tag/effect-handlers"> <i class="fa-solid fa-hashtag fa-sm"></i> effect-handlers</a>   ·   <a href="/blog/category/formal"> <i class="fa-solid fa-tag fa-sm"></i> Formal</a>   <a href="/blog/category/verification"> <i class="fa-solid fa-tag fa-sm"></i> Verification,</a>   <a href="/blog/category/free"> <i class="fa-solid fa-tag fa-sm"></i> Free</a>   <a href="/blog/category/monads"> <i class="fa-solid fa-tag fa-sm"></i> Monads</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>As we recall from <a href="/blog/freer-monad/part1/">part 1</a>, free objects are defined by left adjoints to forgetful functors, and can also be defined by a particular universal property. Universal properties are given by <em>universal arrows</em>: unique morphisms that characterize an object up to isomorphism. In <a href="/blog/freer-monad/part2/">part 2</a>, we talked about one particular universal property, and this part will focus on another.</p> <p>In this section we will apply the general universal property of the free object to our special case of monads. The free monad over a type constructor <code class="language-plaintext highlighter-rouge">F</code> is the monad that arises from freely generating effects described by <code class="language-plaintext highlighter-rouge">F</code>, with just enough structure to satisfy the monad laws and nothing else.</p> <p>This point of view leads naturally to the concept of an effect handler, which is a function that interprets operations from <code class="language-plaintext highlighter-rouge">F</code> into a monad <code class="language-plaintext highlighter-rouge">M</code>. The universal property of the free monad ensures that any such handler extends uniquely to a monad morphism from the free monad into <code class="language-plaintext highlighter-rouge">M</code>. This morphism, in turn, acts as an interpreter for the entire computation.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#FreeMonadAsFreeObject">Free Monads as Free Objects</a></li> <li><a href="#UnivMorphism">The Universal Morphism</a></li> <li><a href="#Example">An Example</a></li> <li> <a href="#Conclusion">Conclusion</a> </li> </ol> <h2 id="2-free-monads-as-free-objects">2. <a name="FreeMonadAsFreeObject"></a>Free Monads as Free Objects</h2> <p>The universal property of free objects, as we saw in part 1, says the free object on some “basis” data $X$ is a structured object $X’$ which includes $X$, such that any map from $X$ into another structured object $G$ uniquely extends to a morphism from $X’$ to $G$. Diagrammatically:</p> <div style="text-align: center;"> <span style="display: inline-block;"> <script type="text/tikz">
      \begin{tikzcd}[scale=2, column sep=huge, row sep=huge
        {X'} && G \\
        \\
        X
        \arrow["{\hat{h}}", dashed, from=1-1, to=1-3
        \arrow["\iota", from=3-1, to=1-1
        \arrow["h"', from=3-1, to=1-3
      \end{tikzcd}
    </script> </span> </div> <p>In the category of vector spaces for example, this intuitively says that if you have a function from a set $B$ to a vector space $W$, then this function can be extended uniquely (as a linear transformation) to the entire vector space $V_B$ with basis $B$. As we know from linear algebra, any linear transformation is uniquely defined by how it acts on a basis. This is the universal property in action.</p> <p>Now what does this mean for monads? We know that our free monad generates a monad from a type constructor <code class="language-plaintext highlighter-rouge">F : Type -&gt; Type</code>, so our “basis” data on which we freely generate our structured object (in this case, a monad) is <code class="language-plaintext highlighter-rouge">F</code> itself. Plugging things into the diagram, we get that for any type constructor <code class="language-plaintext highlighter-rouge">F</code> and a monad <code class="language-plaintext highlighter-rouge">M</code> with a map <code class="language-plaintext highlighter-rouge">h {a : Type} : F a -&gt; M a</code>, <code class="language-plaintext highlighter-rouge">h</code> extends uniquely to a monad morphism <code class="language-plaintext highlighter-rouge">h' {a : Type} : FreeM F a -&gt; M a</code>.</p> <p>Intuitively, you can think of the morphism <code class="language-plaintext highlighter-rouge">h</code> as an <em>effect handler</em> - it interprets each primitive operation described by <code class="language-plaintext highlighter-rouge">F</code> as a monadic computation in <code class="language-plaintext highlighter-rouge">M</code>. The universal property ensures that this effect handler uniquely lifts to a interpretation of entire programs written in the free monad, ie. computations of type <code class="language-plaintext highlighter-rouge">FreeM F</code>. That is, any computation of type <code class="language-plaintext highlighter-rouge">Free M a</code>, can be interpreted as a computation in <code class="language-plaintext highlighter-rouge">M</code> via a morphism <code class="language-plaintext highlighter-rouge">h' a : Free M a -&gt; M a</code>. <code class="language-plaintext highlighter-rouge">h'</code> being a morphism, means it respects both <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">bind</code> of the monads, ie:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span><span class="err">'</span> (<span class="n">pure</span> <span class="n">a</span>) <span class="o">=</span> <span class="n">pure</span> <span class="n">a</span>
<span class="n">h</span><span class="err">'</span> (<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>) <span class="o">=</span> <span class="n">h</span><span class="err">'</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">h</span><span class="err">'</span> (<span class="n">k</span> <span class="n">x</span>)
</code></pre></div></div> <h2 id="3-the-universal-morphism">3. <a name="UnivMorphism"></a>The Universal Morphism</h2> <p>Let’s formalize the universal property precisely. Recall, our <code class="language-plaintext highlighter-rouge">FreeM F</code> monad was defined inductively as a tree of computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FreeM</span> (<span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span>) (α : <span class="kt">Type</span> <span class="n">w</span>)
  <span class="o">|</span> <span class="n">pure</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α
  <span class="o">|</span> <span class="n">liftBind</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) (<span class="n">cont</span> : <span class="err">ι</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α) : <span class="n">FreeM</span> <span class="n">F</span> α
</code></pre></div></div> <p>The universal property, more precisely, is as follows:</p> <blockquote> <p>Given any monad <code class="language-plaintext highlighter-rouge">M</code> and any function (an effect handler)</p> <div class="language-lean highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">f</span> : <span class="o">∀</span> α, <span class="n">F</span> α <span class="o">→</span> <span class="n">M</span> α
</code></pre></div> </div> <p>there exists a unique monad morphism</p> <div class="language-lean highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="err">'</span> : <span class="o">∀</span> α, <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> <span class="n">M</span> α
</code></pre></div> </div> <p>such that</p> <div class="language-lean highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="err">'</span> (<span class="n">lift</span> <span class="n">op</span>) <span class="o">=</span> <span class="n">f</span> <span class="n">op</span>
</code></pre></div> </div> </blockquote> <p>Here, <code class="language-plaintext highlighter-rouge">lift</code> is the inclusion map from our type constructor into the free monad. It lifts a primitive operation into its free monad structure.</p> <p>Explicitly, we define this inclusion as:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) : <span class="n">FreeM</span> <span class="n">F</span> <span class="err">ι</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">pure</span>
</code></pre></div></div> <p>The map <code class="language-plaintext highlighter-rouge">lift</code> takes a single operation from our basis <code class="language-plaintext highlighter-rouge">F</code> and wraps it as an effectful node inside <code class="language-plaintext highlighter-rouge">FreeM</code>.</p> <p>The universal property then guarantees that for any monad <code class="language-plaintext highlighter-rouge">M</code> and any interpretation <code class="language-plaintext highlighter-rouge">f</code> from our effects to <code class="language-plaintext highlighter-rouge">M</code>, we can define our unique interpreter <code class="language-plaintext highlighter-rouge">liftM f</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftM</span> <span class="err">{</span><span class="n">M</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span> [<span class="n">Monad</span> <span class="n">M</span>
    <span class="err">{</span>α : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> (<span class="err">{</span>β : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="o">→</span> <span class="n">F</span> β <span class="o">→</span> <span class="n">M</span> β) <span class="o">→</span> <span class="n">M</span> α
  <span class="o">|</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">pure</span> <span class="n">a</span>, <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">pure</span> <span class="n">a</span>
  <span class="o">|</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span>, <span class="n">interp</span> <span class="o">=&gt;</span> <span class="n">interp</span> <span class="n">op</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">result</span> <span class="o">=&gt;</span> <span class="n">liftM</span> (<span class="n">cont</span> <span class="n">result</span>) <span class="n">interp</span>
</code></pre></div></div> <p>This interpreter <code class="language-plaintext highlighter-rouge">liftM</code> traverses our computation tree. It interprets each effectful node using <code class="language-plaintext highlighter-rouge">interp</code> and recursively interprets the remaining computation.</p> <p>The commutativity condition of the universal property explicitly states:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftM</span> <span class="n">f</span> (<span class="n">lift</span> <span class="n">op</span>) <span class="o">=</span> <span class="n">f</span> <span class="n">op</span>
</code></pre></div></div> <p>In other words, interpreting an operation wrapped by <code class="language-plaintext highlighter-rouge">lift</code> using <code class="language-plaintext highlighter-rouge">liftM</code> is exactly the same as applying the effect handler <code class="language-plaintext highlighter-rouge">f</code> directly.</p> <h2 id="4-an-example">4. <a name="Example"></a>An Example</h2> <p>Let’s illustrate this concretely with an example. Suppose we have a simple effect type describing state operations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">StateF</span> (<span class="err">σ</span> : <span class="kt">Type</span> <span class="n">u</span>) : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">u</span>
  <span class="o">|</span> <span class="n">get</span> : <span class="n">StateF</span> <span class="err">σ</span> <span class="err">σ</span>
  <span class="o">|</span> <span class="n">set</span> : <span class="err">σ</span> <span class="o">→</span> <span class="n">StateF</span> <span class="err">σ</span> <span class="n">PUnit</span>
</code></pre></div></div> <p>Using <code class="language-plaintext highlighter-rouge">lift</code>, we embed these operations into <code class="language-plaintext highlighter-rouge">FreeState σ α := FreeM (StateF σ) α</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get</span> <span class="err">{σ</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> : <span class="n">FreeState</span> <span class="err">σ</span> <span class="err">σ</span> := <span class="n">lift</span> <span class="n">StateF</span><span class="o">.</span><span class="n">get</span>

<span class="k">def</span> <span class="n">set</span> <span class="err">{σ</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">s</span> : <span class="err">σ</span>) : <span class="n">FreeState</span> <span class="err">σ</span> <span class="n">PUnit</span> := <span class="n">lift</span> (<span class="n">StateF</span><span class="o">.</span><span class="n">set</span> <span class="n">s</span>)
</code></pre></div></div> <p>Now suppose we want to interpret our <code class="language-plaintext highlighter-rouge">FreeState</code> computations into the standard state monad <code class="language-plaintext highlighter-rouge">StateM</code>. Our effect handler is straightforward:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">stateInterp</span> <span class="err">{σ</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> : <span class="o">∀</span> <span class="err">{</span>α<span class="err">}</span>, <span class="n">StateF</span> <span class="err">σ</span> α <span class="o">→</span> <span class="n">StateM</span> <span class="err">σ</span> α
  <span class="o">|</span> <span class="n">_</span>, <span class="n">StateF</span><span class="o">.</span><span class="n">get</span> <span class="o">=&gt;</span> <span class="n">StateM</span><span class="o">.</span><span class="n">get</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="n">StateF</span><span class="o">.</span><span class="n">set</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">StateM</span><span class="o">.</span><span class="n">set</span> <span class="n">s</span>
</code></pre></div></div> <p>By the universal property, we uniquely lift this handler to interpret entire computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">toStateM</span> <span class="err">{σ</span> α : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">comp</span> : <span class="n">FreeState</span> <span class="err">σ</span> α) : <span class="n">StateM</span> <span class="err">σ</span> α :=
  <span class="n">liftM</span> <span class="n">stateInterp</span> <span class="n">comp</span>
</code></pre></div></div> <p>This interpreter maps our <code class="language-plaintext highlighter-rouge">FreeState</code> computations into the built-in <code class="language-plaintext highlighter-rouge">StateM</code> monad.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>The universal property of free monads provides a canonical interpreter with nice mathematical guarantees, ensuring that any choice of an effect handler uniquely determines how entire computations get interpreted. In this post we explored this universal property and showed an example in interpreting free computations into the state monad.</p> <p>In practice, this means defining computations using <code class="language-plaintext highlighter-rouge">FreeM</code> is extremely flexible, as changing how we interpret effects is simply a matter of providing different handlers. The next and final section will be a tutorial on using the free monad to design a small DSL with mutable state, logging, and exceptions, and building a verified interpreter for the language.</p> <h2 id="continue-to-part-4---a-tutorial"><strong>Continue to Part 4 - A Tutorial</strong></h2> <p><a href="/blog/freer-monad/part4/">Continue to Part 4 - A Tutorial</a></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/freer-monad-part4/">Tutorial: A Verified Interpreter with Side Effects</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/freer-monad-part2/">Part 2: Initial Algebras, Catamorphisms, and Interpreters</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/freer-monad-part1/">Part 1: Defining the Free Monad in Lean</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/freer-monad/">The Free Monad: A Four-Part Series</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/verified-dp/">Verified Dynamic Programming with Σ-types in Lean</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Tanner Duve. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?c15de51d4bb57887caa2c21988d97279"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>