<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://tannerduve.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://tannerduve.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-11-18T19:35:40+00:00</updated><id>https://tannerduve.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">The Free-er Monad</title><link href="https://tannerduve.github.io/blog/2025/freer-monad/" rel="alternate" type="text/html" title="The Free-er Monad"/><published>2025-05-21T21:00:00+00:00</published><updated>2025-05-21T21:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/freer-monad</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/freer-monad/"><![CDATA[<p>Free monads provide a way to represent effectful sequential programs as pure syntactic data, separate from their interpretation. You describe <em>what</em> should happen as an abstract tree of effects, leaving open <em>how</em> you want it to happen. By decoupling syntax from semantics like this you gain full control over how programs are evaluated and interpreted - for example we could interpret a syntax tree in multiple ways:</p> <ul> <li>Run it directly</li> <li>Pretty print it</li> <li>Analyze it statically</li> </ul> <p>Each of these corresponds to a different interpreter. This approach also allows effects to be combined without you having to get tangled up in monad transformers. <em>Freer</em> monads are a flexible generalization of free monads that make combining and interpreting effects even easier.</p> <p>This four-part series will introduce the freer monad in Lean ‚Äî Part 1 will introduce the categorical theory and motivation of the free monad and walk through its implementation in Lean. In part 2 we will further explore some theory and study initial algebras and catamorphisms, and how they give rise to canonical interpreters for effectful computation trees. In part 3 we will study the universal property of free monads and what it provides for us as programmers. Finally in part 4, we will use what we‚Äôve learned to build and verify a real interpreter for a small language, making elegant use of freeness to combine effectful computations.</p> <p>This series assumes you know basic concepts from both category theory and functional programming, including functors, monads, and inductive datatypes.</p> <ol> <li><a href="/blog/freer-monad/part1/">Part¬†1 ‚Äî Defining the Free Monad in Lean</a></li> <li><a href="/blog/freer-monad/part2/">Part¬†2 ‚Äî Initial Algebras, Catamorphisms, and Interpreters</a></li> <li><a href="/blog/freer-monad/part3/">Part¬†3 ‚Äî Universal Morphisms and Effect Handlers</a></li> <li><a href="/blog/freer-monad/part4/">Part¬†4 ‚Äî Tutorial: A Verified Interpreter with Side Effects</a></li> </ol>]]></content><author><name></name></author><category term="Formal Verification"/><category term="Free Monads"/><category term="lean"/><category term="free-monads"/><category term="category-theory"/><category term="effects"/><summary type="html"><![CDATA[Free monads provide a way to represent effectful sequential programs as pure syntactic data, separate from their interpretation. You describe what should happen as an abstract tree of effects, leaving open how you want it to happen. By decoupling syntax from semantics like this you gain full control over how programs are evaluated and interpreted - for example we could interpret a syntax tree in multiple ways:]]></summary></entry><entry><title type="html">Verified Dynamic Programming with Œ£-types in Lean</title><link href="https://tannerduve.github.io/blog/2025/verified-dp/" rel="alternate" type="text/html" title="Verified Dynamic Programming with Œ£-types in Lean"/><published>2025-05-21T20:00:00+00:00</published><updated>2025-05-21T20:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/verified-dp</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/verified-dp/"><![CDATA[<h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>If you‚Äôve taken an algorithms class, you have likely seen dynamic programming, specifically a technique called <em>memoization</em>. Memoization works to optimize recursive algorithms by <em>caching</em> the solutions to subproblems in a table, and when a subproblem is encountered, it queries the table instead of recomputing the solution. This gives us an exponential performance boost.</p> <p>This blog post will show how to solve a dynamic programming problem using memoization in Lean, and verify its correctness against a specification. The technique used in the proof of correctness here is an interesting application of Lean‚Äôs dependent types, and is generalized to work for any memoization algorithm. The idea came from a conversation with <a href="https://gasstationmanager.github.io">GasStationManager</a> over at the <a href="https://leanprover.zulipchat.com">Lean Zulip chat</a>, who I credit with coming up with the general technique.</p> <p>This should be pretty beginner friendly. Basic data structures+algorithms at the undergrad level. Lean experience is not necessary but is helpful for following code samples.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#Problem">Problem</a></li> <li><a href="#FirstSolution">First Solution</a></li> <li><a href="#Sigma">Type Theory Interlude: Subtypes and Dependent Pairs</a></li> <li><a href="#Solution">Improved Solution</a></li> <li><a href="#Conclusion">Conclusion</a></li> <li><a href="#Exercises">Exercises</a></li> <li><a href="#References">References</a></li> </ol> <h2 id="2-problem">2. <a name="Problem"></a>Problem</h2> <p>The problem we will be working on here is called <a href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/state-space-reduction/practice-problems/algorithm/bytelandian-gold-coins/">Bytelandian Gold Coins</a>. The problem description is as follows:</p> <blockquote> <p>In Byteland they have a very strange monetary system. Each Bytelandian gold coin has an integer number written on it. A coin n can be exchanged in a bank into three coins: n/2, n/3 and n/4. But these numbers are all rounded down (the banks have to make a profit).</p> <p>You can also sell Bytelandian coins for American dollars. The exchange rate is 1:1. But you can not buy Bytelandian coins. You have one gold coin. What is the maximum amount of American dollars you can get for it?</p> </blockquote> <p>The solution is classic DP. Observe that for any amount up to 8, we can‚Äôt get more money by dividing into $n/2, n/3, n/4$. For any value, the minimum amount we can get out of it is $n$. We will compare this value with the value we get after dividing $n$ and select the bigger value.</p> <h2 id="3-first-solution">3. <a name="FirstSolution"></a>First Solution</h2> <p>The solution is given by the following recurrence relation :</p> \[f(n)= \begin{cases} n, &amp; n \le 8,\\[6pt] \displaystyle \max\!\bigl(n,\; f(\lfloor n/2\rfloor)+f(\lfloor n/3\rfloor)+f(\lfloor n/4\rfloor)\bigr), &amp; n&gt;8. \end{cases}\] <p>Before writing any code, here is the header we‚Äôll want to use:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">Std</span><span class="o">.</span><span class="n">Data</span><span class="o">.</span><span class="n">HashMap</span>
<span class="k">open</span> <span class="n">Std</span>
</code></pre></div></div> <p>We define the recurrence in Lean as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  <span class="n">if</span> <span class="n">n</span> <span class="o">‚â§</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">
  -- Base case: for `n ‚â§ 8`, it's better to sell the coin directly.</span>
    <span class="n">n</span>
  <span class="n">else</span><span class="cd">
  -- Recursive case: choose the maximum between selling the coin directly and exchanging it.</span>
    <span class="n">max</span> <span class="n">n</span> (<span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="o">+</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="o">+</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>))
</code></pre></div></div> <p>This directly computes the maximum earnable amount. We will use this as our specification for proving our memoized solution is correct.</p> <p>Now here is a memoized solution:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollarsMemo</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  <span class="n">let</span> <span class="n">rec</span> <span class="n">helperMemo</span> (<span class="n">n</span> : <span class="n">Nat</span>) (<span class="n">memo</span> : <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span>) : <span class="n">Nat</span> <span class="o">√ó</span> <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span> :=
      <span class="k">match</span> <span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="err">?</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="n">some</span> <span class="n">v</span> <span class="o">=&gt;</span> (<span class="n">v</span>, <span class="n">memo</span>)  <span class="cd">-- already cached</span>
      <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span>
        <span class="n">if</span> <span class="n">n</span> <span class="o">‚â§</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">          -- base case: sell coin directly</span>
          <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">memo</span><span class="o">.</span><span class="n">insert</span> <span class="n">n</span> <span class="n">n</span>
          (<span class="n">n</span>, <span class="n">memo</span><span class="err">'</span>)
        <span class="n">else</span><span class="cd">
          -- recursive: compute best exchange value, memoizing along the way</span>
          <span class="n">let</span> (<span class="n">v1</span>, <span class="n">memo1</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="n">memo</span>
          <span class="n">let</span> (<span class="n">v2</span>, <span class="n">memo2</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="n">memo1</span>
          <span class="n">let</span> (<span class="n">v3</span>, <span class="n">memo3</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>) <span class="n">memo2</span>
          <span class="n">let</span> <span class="n">best</span> := <span class="n">max</span> <span class="n">n</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">+</span> <span class="n">v3</span>)
          <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">memo3</span><span class="o">.</span><span class="n">insert</span> <span class="n">n</span> <span class="n">best</span>
          (<span class="n">best</span>, <span class="n">memo</span><span class="err">'</span>)
  (<span class="n">helperMemo</span> <span class="n">n</span> (<span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>))<span class="o">.</span><span class="n">fst</span>
</code></pre></div></div> <p>This function defines a helper which caches the solutions to subproblems in a hashmap and at each recursive call, queries the hashmap for a stored value. It then calls the helper on the empty map and returns the <code class="language-plaintext highlighter-rouge">n</code>th value <em>(Exercise : Rewrite this using a state monad to simulate mutating the hashmap instead of passing around a new one with each insertion)</em></p> <p>Now our correctness claim is as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">memo_correct</span> : <span class="o">‚àÄ</span> (<span class="n">n</span> : <span class="o">‚Ñï</span>), <span class="n">maxDollarsMemo</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maxDollarsSpec</span> <span class="n">n</span>
</code></pre></div></div> <p>That is, our memoized solution computes the recurrence correctly on every $n \in \mathbb{N}$. Trying to prove this ends up being <em>very</em> difficult. I invite the reader to try it out themselves and see where you get stuck. A good prover may figure it out. I attempted strong induction on $n$ to no avail and trying various approaches I kept getting stuck. The direct proof is indeed possible but the statement feels far too intuitively true to be worth this much effort. The key realization here as to what makes this proof difficult is that correctness relies on invariant properties of the data structure which we store our values in.</p> <p>First off, we need to prove that the HashMap correctly computes subproblems, that is, that <code class="language-plaintext highlighter-rouge">get? x</code> always returns either <code class="language-plaintext highlighter-rouge">none</code> or a value which is equal to <code class="language-plaintext highlighter-rouge">maxDollars_spec x</code>. We also rely on the invariant that if the HashMap satisfies this property before the call to <code class="language-plaintext highlighter-rouge">helperMemo</code>, then it satisfies this property after the call to <code class="language-plaintext highlighter-rouge">helperMemo</code>. To prove this requires reasoning about the body of <code class="language-plaintext highlighter-rouge">helperMemo</code>.</p> <p>There‚Äôs a lot of logic to juggle here in our proof, but thankfully there is a better way. A Haskeller is likely familiar with the notion of refinement types. In Lean we call them subtypes. Subtypes provide a way to attach logical properties to data using a familiar set-builder-like notation, where we can refer to the type of all elements of some type <code class="language-plaintext highlighter-rouge">T</code> for which a particular property holds. An example of a subtype is <code class="language-plaintext highlighter-rouge">{n : ‚Ñï // Even n}</code> - the subtype of <code class="language-plaintext highlighter-rouge">‚Ñï</code> consisting of all of the Even natural numbers. This is all just syntactic sugar for a dependent pair type, aka $\Sigma$-types. Let‚Äôs explore these some more before moving on.</p> <h2 id="4-type-theory-interlude-subtypes-and-dependent-pairs">4. <a name="Sigma"></a>Type Theory Interlude: Subtypes and Dependent Pairs</h2> <p>This section is a brief detour into the theory of Lean‚Äôs subtypes. This is optional but I find it valuable. In dependent type theory, $\Sigma$-types are a generalization of a product type, where the type of the second element in a pair can <em>depend</em> on the value of the first element. In a non-dependent setting, the product $A \times B$ of two types $A$ and $B$ consists of all pairs $(a, b)$ where $a : A$ and $b : B$ - it‚Äôs just the standard cartesian product. The dependent pair type generalizes this.</p> <p>Suppose we have a type $A$ and a <em>family of types indexed by $A$</em>, denoted $B : A \to \mathcal{U}$ (where $\mathcal{U}$ denotes the universe of all types). Then the type $\sum_{(x : A)}B(x)$ consists of the pairs $(a, b)$ where $a : A$ and $b : B(a)$ - the <em>type</em> of $b$ <em>depends</em> on the <em>value</em> of $a$. Note that the Cartesian product is exactly the special case where $B$ is constant, ie $\displaystyle\sum_{(x : A)}B = A \times B$.</p> <p>Back to the original example, let‚Äôs think about <code class="language-plaintext highlighter-rouge">{n : ‚Ñï // Even n}</code> in these terms. Under the <a href="https://en.wikipedia.org/wiki/Curry‚ÄìHoward_correspondence">propositions-as-types</a> principle, the proposition <code class="language-plaintext highlighter-rouge">Even n</code> is of course just a type. But note that <code class="language-plaintext highlighter-rouge">Even n</code> is a <em>different</em> proposition for every <code class="language-plaintext highlighter-rouge">n : ‚Ñï</code> - that is, <code class="language-plaintext highlighter-rouge">Even</code> is a <em>family</em> of types <em>indexed</em> by <code class="language-plaintext highlighter-rouge">‚Ñï</code>. So, the type <code class="language-plaintext highlighter-rouge">{n : ‚Ñï // Even n}</code> is exactly the $\Sigma$-type $\sum_{n : \mathbb{N}}\text{Even}(n)$, which consists of pairs $(n, P_n)$, where $P_n$ is a <em>proof</em> that $n$ is Even.</p> <p>For a primer on dependent type theory, see chapter 1 of <a href="https://www.cs.uoregon.edu/research/summerschool/summer14/rwh_notes/hott-book.pdf">HoTT</a></p> <h2 id="5-improved-solution">5. <a name="Solution"></a>Improved Solution</h2> <p>Now that we‚Äôve introduced subtypes we will put them to use by writing a new memoized algorithm that, in some sense, proves itself. Remember part of our correctness proof is showing that the HashMap‚Äôs <code class="language-plaintext highlighter-rouge">get? x</code> method always returns a <code class="language-plaintext highlighter-rouge">y</code> such that <code class="language-plaintext highlighter-rouge">maxDollars_spec x = y</code>. What if, to guarantee this, we write a new version of <code class="language-plaintext highlighter-rouge">get?</code> so that <code class="language-plaintext highlighter-rouge">get? x</code> returns a <code class="language-plaintext highlighter-rouge">y</code> in the subtype <code class="language-plaintext highlighter-rouge">{y : ‚Ñï // maxDollars_spec x = y}</code>? To do this, we can just subtype the data which our HashMap stores.</p> <p>For the memoization, the property we want to hold is: for a pair <code class="language-plaintext highlighter-rouge">(k, v)</code> stored in your table, <code class="language-plaintext highlighter-rouge">f k = v</code> where <code class="language-plaintext highlighter-rouge">f</code> is the recursive function you are proving equivalence to (in our case, <code class="language-plaintext highlighter-rouge">f</code> is the the recurrence <code class="language-plaintext highlighter-rouge">maxDollars_spec</code>).</p> <p>Now the implementation is as follows. We begin with a very general definition: a pair of values with a property attached to it:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">cell</span> (<span class="n">f</span> : Œ± <span class="o">‚Üí</span> Œ≤) := <span class="err">{</span><span class="n">c</span>: Œ± <span class="o">√ó</span> Œ≤ <span class="o">//</span> <span class="n">f</span> <span class="n">c</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">snd</span><span class="err">}</span>
</code></pre></div></div> <p>That is, given a function <code class="language-plaintext highlighter-rouge">f : Œ± ‚Üí Œ≤</code>, for example the recurrence <code class="language-plaintext highlighter-rouge">maxDollars_spec</code> above, <code class="language-plaintext highlighter-rouge">cell f</code> is the type of all pairs <code class="language-plaintext highlighter-rouge">(a, b) : Œ± √ó Œ≤</code> such that <code class="language-plaintext highlighter-rouge">f a = b</code></p> <p>Our new HashMap, <code class="language-plaintext highlighter-rouge">PropMap</code>, stores keys of type <code class="language-plaintext highlighter-rouge">Œ±</code> and values of type <code class="language-plaintext highlighter-rouge">cell f</code> whose first element is equal to the key:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">PropMap</span> [<span class="n">BEq</span> Œ±][<span class="n">Hashable</span> Œ±] [<span class="n">LawfulBEq</span> Œ±] (<span class="n">f</span> : Œ± <span class="o">‚Üí</span> Œ≤) :=
  <span class="n">HashMap</span> Œ± (<span class="n">cell</span> <span class="n">f</span>)
</code></pre></div></div> <p>Now we can define <code class="language-plaintext highlighter-rouge">get?</code> with the guarantee we are looking for:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">PropMap_get</span><span class="err">?</span> [<span class="n">BEq</span> Œ±][<span class="n">Hashable</span> Œ±] [<span class="n">LawfulBEq</span> Œ±] (<span class="n">ft</span> : Œ± <span class="o">‚Üí</span> Œ≤) (<span class="n">hm</span> : <span class="n">PropMap</span> <span class="n">ft</span>) (<span class="n">a</span> : Œ±) : <span class="n">Option</span> <span class="err">{</span> <span class="n">b</span> : Œ≤ <span class="o">//</span> <span class="n">ft</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="err">}</span> :=
  <span class="k">match</span> <span class="n">hf</span> : <span class="n">hm</span><span class="o">.</span><span class="n">get</span><span class="err">?</span> <span class="n">a</span> <span class="k">with</span><span class="cd">  -- Attempt to get the value associated with `a` in the map.</span>
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">none</span><span class="cd">            -- If not found, return `none`.</span>
  <span class="o">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">=&gt;</span>
    <span class="n">if</span> <span class="n">heq</span> : <span class="n">a</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">fst</span> <span class="n">then</span><span class="cd">  -- Check if the key `a` matches `x.val.fst`.</span>
      <span class="k">have</span> : <span class="n">ft</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">snd</span> := <span class="k">by</span>
        <span class="k">have</span> <span class="n">hx</span> := <span class="n">x</span><span class="o">.</span><span class="n">property</span><span class="cd">       -- Extract the proof that `ft x.val.fst = x.val.snd`.</span>
        <span class="n">rw</span> [<span class="n">beq_iff_eq</span>] <span class="n">at</span> <span class="n">heq</span><span class="cd">      -- Propositional equality from boolean equality</span>
        <span class="n">rw</span> [<span class="err">‚Üê</span> <span class="n">heq</span>] <span class="n">at</span> <span class="n">hx</span><span class="cd">            -- Replace `x.val.fst` with `a` using `heq`.</span>
        <span class="n">exact</span> <span class="n">hx</span><span class="cd">                    -- Conclude that `ft a = x.val.snd`.</span>
      <span class="n">pure</span> <span class="o">‚ü®</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">snd</span>, <span class="n">this</span> <span class="o">‚ü©</span><span class="cd">     -- Return the value and proof as `some`.</span>
    <span class="n">else</span>
      <span class="n">none</span><span class="cd">  -- If the keys don't match (shouldn't happen), return `none`.</span>
</code></pre></div></div> <p>As well as an insertion function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">PropMap_insert</span> [<span class="n">BEq</span> Œ±][<span class="n">Hashable</span> Œ±] [<span class="n">LawfulBEq</span> Œ±] (<span class="n">ft</span> : Œ± <span class="o">‚Üí</span> Œ≤) (<span class="n">hm</span> : <span class="n">PropMap</span> <span class="n">ft</span>) (<span class="n">k</span> : Œ±) (<span class="n">v</span> : Œ≤) (<span class="n">h</span> : <span class="n">ft</span> <span class="n">k</span> <span class="o">=</span> <span class="n">v</span>) : <span class="n">PropMap</span> <span class="n">ft</span> :=
  <span class="n">let</span> <span class="n">cell</span> : <span class="err">{</span> <span class="n">c</span> : Œ± <span class="o">√ó</span> Œ≤ <span class="o">//</span> <span class="n">ft</span> <span class="n">c</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">snd</span> <span class="err">}</span> := <span class="o">‚ü®</span>(<span class="n">k</span>, <span class="n">v</span>), <span class="n">h</span><span class="o">‚ü©</span><span class="cd">  -- Create the cell with proof.</span>
  <span class="n">hm</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">cell</span><span class="cd">  -- Insert the cell into the map at key `k`.</span>
</code></pre></div></div> <p>And now we can define our recursive helper:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">helper</span> (<span class="n">n</span> : <span class="n">Nat</span>) (<span class="n">memo</span> : <span class="n">PropMap</span> <span class="n">maxDollars_spec</span>) :
  <span class="err">{</span> <span class="n">v</span> : <span class="n">Nat</span> <span class="o">//</span> <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> <span class="err">}</span> <span class="o">√ó</span> <span class="n">PropMap</span> <span class="n">maxDollars_spec</span> :=
  <span class="k">match</span> <span class="n">PropMap_get</span><span class="err">?</span> <span class="n">maxDollars_spec</span> <span class="n">memo</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">some</span> <span class="n">result</span> <span class="o">=&gt;</span><span class="cd">
    -- If `n` is already in the memoization map, return the cached value and the memo.
    -- `result` has type `{ v : Nat // maxDollars_spec n = v }`.</span>
    (<span class="n">result</span>, <span class="n">memo</span>)
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span>
    <span class="n">if</span> <span class="n">h</span> : <span class="n">n</span> <span class="o">‚â§</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">
      -- Base case: for `n ‚â§ 8`.</span>
      <span class="n">let</span> <span class="n">v</span> := <span class="n">n</span>
      <span class="n">let</span> <span class="n">h_spec</span> : <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> := <span class="k">by</span> <span class="n">simp</span> [<span class="n">maxDollars_spec</span>, <span class="n">h</span>]
      <span class="cd">-- Prove that `maxDollars_spec n = n` using simplification.</span>
      <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">PropMap_insert</span> <span class="n">maxDollars_spec</span> <span class="n">memo</span> <span class="n">n</span> <span class="n">v</span> <span class="n">h_spec</span><span class="cd">
      -- Insert `(n, v)` with proof into the memoization map.</span>
      (<span class="o">‚ü®</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">‚ü©</span>, <span class="n">memo</span><span class="err">'</span>)
    <span class="n">else</span><span class="cd">
      -- Recursive case: compute the values for `n / 2`, `n / 3`, and `n / 4`.</span>
      <span class="n">let</span> (<span class="n">r1</span>, <span class="n">memo1</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="n">memo</span>
      <span class="n">let</span> (<span class="n">r2</span>, <span class="n">memo2</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="n">memo1</span>
      <span class="n">let</span> (<span class="n">r3</span>, <span class="n">memo3</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>) <span class="n">memo2</span><span class="cd">
      -- `r1`, `r2`, `r3` are of type `{ v : Nat // maxDollars_spec (n / x) = v }`. Basically an induction hypothesis.
      -- `memo3` is the updated memoization map after all recursive calls.</span>
      <span class="n">let</span> <span class="n">exchangeSum</span> := <span class="n">r1</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">r2</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">r3</span><span class="o">.</span><span class="n">val</span><span class="cd">  -- Sum the values obtained from recursion.</span>
      <span class="n">let</span> <span class="n">v</span> := <span class="n">max</span> <span class="n">n</span> <span class="n">exchangeSum</span><span class="cd">  -- Decide whether to sell `n` directly or exchange it.

      -- **Construct the proof that `maxDollars_spec n = v`**</span>
      <span class="k">have</span> <span class="n">h_spec</span> : <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> := <span class="k">by</span>
        <span class="n">unfold</span> <span class="n">maxDollars_spec</span><span class="cd">         -- Expand `maxDollars_spec n`.</span>
        <span class="n">rw</span> [<span class="n">if_neg</span> <span class="n">h</span>]                  <span class="cd">-- Since `n &gt; 8`, use the recursive case.</span>
        <span class="n">rw</span> [<span class="n">r1</span><span class="o">.</span><span class="n">property</span>, <span class="n">r2</span><span class="o">.</span><span class="n">property</span>, <span class="n">r3</span><span class="o">.</span><span class="n">property</span>]

      <span class="cd">-- Replace recursive calls with their computed values using the proofs from `r1`, `r2`, `r3`.</span>
      <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">PropMap_insert</span> <span class="n">maxDollars_spec</span> <span class="n">memo3</span> <span class="n">n</span> <span class="n">v</span> <span class="n">h_spec</span><span class="cd">
      -- Insert the computed value and its proof into the memoization map.</span>
      (<span class="o">‚ü®</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">‚ü©</span>, <span class="n">memo</span><span class="err">'</span>)  <span class="cd">-- Return the computed value with proof and the updated memo.</span>
</code></pre></div></div> <p>Look here. Subtypes require proofs that their value satisfies their logical property. Thus each time our algorithm computes a value <code class="language-plaintext highlighter-rouge">v</code> to go in our table, we also compute a proof that <code class="language-plaintext highlighter-rouge">v</code> is computed correctly according to <code class="language-plaintext highlighter-rouge">maxDollars_spec</code>. We are interleaving code and proof and essentially proving correctness <em>inside the algorithm itself</em>.</p> <p>And finally, here is our main function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollars</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  (<span class="n">helper</span> <span class="n">n</span> (<span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>))<span class="o">.1</span>
</code></pre></div></div> <p>We‚Äôve embedded the proof into the algorithm itself: every computed value is stored together with a proof that it satisfies the spec. So to prove correctness for any n, we just apply the function ‚Äî its type guarantees that the result equals maxDollars_spec n:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">maxDollars_spec_correct</span> : <span class="o">‚àÄ</span> <span class="n">n</span>, <span class="n">maxDollars</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maxDollars_spec</span> <span class="n">n</span> := <span class="k">by</span>
  <span class="n">intro</span> <span class="n">n</span>
  <span class="n">unfold</span> <span class="n">maxDollars</span>
  <span class="n">let</span> <span class="o">‚ü®</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">‚ü©</span> := (<span class="n">helper</span> <span class="n">n</span> <span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>)<span class="o">.1</span>
  <span class="n">exact</span> <span class="n">h_spec</span><span class="o">.</span><span class="n">symm</span>
</code></pre></div></div> <p>And we‚Äôre done. The algorithm has been verified.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>My goal here was to share what I learned from this technique and show how it can be applied to a particular problem. I also hope the reader came away understanding subtypes from the perspective of dependent type theory. I find intertwining code with proof in this way really cool and the people I‚Äôve shown this to felt the same.</p> <p>To review what we did:</p> <ul> <li> <p>We introduced the Bytelandian Gold Coins problem and wrote a basic recursive specification using a natural recurrence relation.</p> </li> <li> <p>We implemented a naive memoized version using a <code class="language-plaintext highlighter-rouge">HashMap</code>, and discussed why proving its correctness directly is tough due to the difficulty of reasoning about data structure invariants.</p> </li> <li> <p>We took a detour into type theory to study subtypes and $\Sigma$-types as a way to attach logical properties to data.</p> </li> <li> <p>We defined a new form of memoization table (<code class="language-plaintext highlighter-rouge">PropMap</code>) that stores not just computed values, but also <em>proofs</em> that they were computed correctly with respect to the spec.</p> </li> <li> <p>We rewrote the algorithm so that correctness was proven incrementally, at every step, as a side effect of evaluation - embedding the proof <em>into</em> the recursion.</p> </li> <li> <p>We ended with a trivial top-level proof: correctness follows directly from the structure of the implementation.</p> </li> </ul> <p>All this code is available at <a href="https://github.com/tannerduve/coins">this repo</a></p> <h2 id="6-exercises">6. <a name="Exercises"></a>Exercises</h2> <p>Each of the following DP problems can be solved using the same framework introduced in this post: define a recurrence relation as a specification, write a memoized implementation that returns values paired with correctness proofs via subtypes, and prove the top-level function computes the intended result.</p> <p>Try implementing and verifying your favorite(s) of the following:</p> <ul> <li> <p><strong>Rod Cutting</strong> Given a rod of length <code class="language-plaintext highlighter-rouge">n</code> and a list of prices <code class="language-plaintext highlighter-rouge">p : List ‚Ñï</code> where <code class="language-plaintext highlighter-rouge">p[i]</code> is the price of a rod of length <code class="language-plaintext highlighter-rouge">i + 1</code>, define:</p> \[r(n) = \max_{1 \le i \le n} (p[i{-}1] + r(n - i))\] <p>Implement <code class="language-plaintext highlighter-rouge">rodCut : ‚Ñï ‚Üí ‚Ñï</code> using a memoization table and prove correctness</p> </li> <li> <p><strong>0/1 Knapsack</strong> Given <code class="language-plaintext highlighter-rouge">n</code> items with weights <code class="language-plaintext highlighter-rouge">w : Fin n ‚Üí ‚Ñï</code>, values <code class="language-plaintext highlighter-rouge">v : Fin n ‚Üí ‚Ñï</code>, and a maximum capacity <code class="language-plaintext highlighter-rouge">C</code>, define:</p> \[\text{knapsack}(i, c) = \begin{cases} 0, &amp; i = n \\ \text{knapsack}(i+1, c), &amp; w[i] &gt; c \\ \max(\text{knapsack}(i+1, c),\ v[i] + \text{knapsack}(i+1, c - w[i])), &amp; \text{otherwise} \end{cases}\] <p>Implement and verify <code class="language-plaintext highlighter-rouge">knapsack : ‚Ñï ‚Üí ‚Ñï</code> using a memo table indexed by item and capacity.</p> </li> <li> <p><strong>Levenshtein Distance</strong> Given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>, define their edit/Levenshtein distance:</p> \[\text{dist}(i, j) = \begin{cases} i, &amp; j = 0 \\ j, &amp; i = 0 \\ \min\!\left( \text{dist}(i{-}1, j) + 1,\; \text{dist}(i, j{-}1) + 1,\; \text{dist}(i{-}1, j{-}1) + \text{cost} \right), &amp; \text{otherwise} \end{cases}\] <p>where <code class="language-plaintext highlighter-rouge">cost = 0</code> if <code class="language-plaintext highlighter-rouge">s[i-1] = t[j-1]</code> and <code class="language-plaintext highlighter-rouge">1</code> otherwise. Implement and verify <code class="language-plaintext highlighter-rouge">editDist : String ‚Üí String ‚Üí ‚Ñï</code>.</p> </li> </ul> <p>In each case, define the specification as a recursive function, then write a subtype-verified implementation using a <code class="language-plaintext highlighter-rouge">PropMap</code> to cache and prove subproblem results. Your goal is a final theorem of the form:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">algorithm_correct</span> : <span class="o">‚àÄ</span> <span class="n">input</span>, <span class="n">algorithm</span> <span class="n">input</span> <span class="o">=</span> <span class="n">spec</span> <span class="n">input</span>
</code></pre></div></div> <h2 id="7-references">7. <a name="References"></a>References</h2> <p><a href="https://gasstationmanager.github.io/ai/2024/12/03/memoization1.html">Proving Memoization in Lean, And Teaching it to Sonnet</a>, GasStationManager</p>]]></content><author><name></name></author><category term="Formal Verification"/><category term="Algorithms"/><category term="lean"/><category term="dynamic-programming"/><category term="formal-verification"/><category term="dependent-types"/><category term="sigma-types"/><summary type="html"><![CDATA[1. Introduction If you‚Äôve taken an algorithms class, you have likely seen dynamic programming, specifically a technique called memoization. Memoization works to optimize recursive algorithms by caching the solutions to subproblems in a table, and when a subproblem is encountered, it queries the table instead of recomputing the solution. This gives us an exponential performance boost.]]></summary></entry><entry><title type="html">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</title><link href="https://tannerduve.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/" rel="alternate" type="text/html" title="Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra"/><published>2024-05-14T00:00:00+00:00</published><updated>2024-05-14T00:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra</id><content type="html" xml:base="https://tannerduve.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/"><![CDATA[<p>May 14, 2024 We‚Äôre introducing a series of updates across the Gemini family of models, including the new 1.5 Flash, our lightweight model for speed and efficiency, and Project Astra, our vision for the future of AI assistants. In December, we launched our first natively multimodal model Gemini 1.0 in three sizes: Ultra, Pro and Nano. Just a few months later we released 1.5 Pro, with enhanced performance and a breakthrough long context window of 1 million tokens.Developers and enterprise customers have been putting 1.5 Pro to use in incredible ways and finding its long context window, multimodal reasoning capabilities and impressive overall performance incredibly useful.We know from user feedback that some applications need lower latency and a lower cost to serve. This inspired us to keep innovating, so today, we‚Äôre introducing Gemini 1.5 Flash: a model that‚Äôs lighter-weight than 1.5 Pro, and designed to be fast and efficient to serve at scale.Both 1.5 Pro and 1.5 Flash are available in public preview with a 1 million token context window in Google AI Studio and Vertex AI. And now, 1.5 Pro is also available with a 2 million token context window via waitlist to developers using the API and to Google Cloud customers.We‚Äôre also introducing updates across the Gemini family of models, announcing our next generation of open models, Gemma 2, and sharing progress on the future of AI assistants, with Project Astra.Context lengths of leading foundation models compared with Gemini 1.5‚Äôs 2 million token capability1.5 Flash is the newest addition to the Gemini model family and the fastest Gemini model served in the API. It‚Äôs optimized for high-volume, high-frequency tasks at scale, is more cost-efficient to serve and features our breakthrough long context window.While it‚Äôs a lighter weight model than 1.5 Pro, it‚Äôs highly capable of multimodal reasoning across vast amounts of information and delivers impressive quality for its size.The new Gemini 1.5 Flash model is optimized for speed and efficiency, is highly capable of multimodal reasoning and features our breakthrough long context window.1.5 Flash excels at summarization, chat applications, image and video captioning, data extraction from long documents and tables, and more. This is because it‚Äôs been trained by 1.5 Pro through a process called ‚Äúdistillation,‚Äù where the most essential knowledge and skills from a larger model are transferred to a smaller, more efficient model.Read more about 1.5 Flash in our updated Gemini 1.5 technical report, on the Gemini technology page, and learn about 1.5 Flash‚Äôs availability and pricing.Over the last few months, we‚Äôve significantly improved 1.5 Pro, our best model for general performance across a wide range of tasks.Beyond extending its context window to 2 million tokens, we‚Äôve enhanced its code generation, logical reasoning and planning, multi-turn conversation, and audio and image understanding through data and algorithmic advances. We see strong improvements on public and internal benchmarks for each of these tasks.1.5 Pro can now follow increasingly complex and nuanced instructions, including ones that specify product-level behavior involving role, format and style. We‚Äôve improved control over the model‚Äôs responses for specific use cases, like crafting the persona and response style of a chat agent or automating workflows through multiple function calls. And we‚Äôve enabled users to steer model behavior by setting system instructions.We added audio understanding in the Gemini API and Google AI Studio, so 1.5 Pro can now reason across image and audio for videos uploaded in Google AI Studio. And we‚Äôre now integrating 1.5 Pro into Google products, including Gemini Advanced and in Workspace apps.Read more about 1.5 Pro in our updated Gemini 1.5 technical report and on the Gemini technology page.Gemini Nano is expanding beyond text-only inputs to include images as well. Starting with Pixel, applications using Gemini Nano with Multimodality will be able to understand the world the way people do ‚Äî not just through text, but also through sight, sound and spoken language.Read more about Gemini 1.0 Nano on Android.Today, we‚Äôre also sharing a series of updates to Gemma, our family of open models built from the same research and technology used to create the Gemini models.We‚Äôre announcing Gemma 2, our next generation of open models for responsible AI innovation. Gemma 2 has a new architecture designed for breakthrough performance and efficiency, and will be available in new sizes.The Gemma family is also expanding with PaliGemma, our first vision-language model inspired by PaLI-3. And we‚Äôve upgraded our Responsible Generative AI Toolkit with LLM Comparator for evaluating the quality of model responses.Read more on the Developer blog.As part of Google DeepMind‚Äôs mission to build AI responsibly to benefit humanity, we‚Äôve always wanted to develop universal AI agents that can be helpful in everyday life. That‚Äôs why today, we‚Äôre sharing our progress in building the future of AI assistants with Project Astra (advanced seeing and talking responsive agent).To be truly useful, an agent needs to understand and respond to the complex and dynamic world just like people do ‚Äî and take in and remember what it sees and hears to understand context and take action. It also needs to be proactive, teachable and personal, so users can talk to it naturally and without lag or delay.While we‚Äôve made incredible progress developing AI systems that can understand multimodal information, getting response time down to something conversational is a difficult engineering challenge. Over the past few years, we‚Äôve been working to improve how our models perceive, reason and converse to make the pace and quality of interaction feel more natural.Building on Gemini, we‚Äôve developed prototype agents that can process information faster by continuously encoding video frames, combining the video and speech input into a timeline of events, and caching this information for efficient recall.By leveraging our leading speech models, we also enhanced how they sound, giving the agents a wider range of intonations. These agents can better understand the context they‚Äôre being used in, and respond quickly, in conversation.With technology like this, it‚Äôs easy to envision a future where people could have an expert AI assistant by their side, through a phone or glasses. And some of these capabilities are coming to Google products, like the Gemini app and web experience, later this year.We‚Äôve made incredible progress so far with our family of Gemini models, and we‚Äôre always striving to advance the state-of-the-art even further. By investing in a relentless production line of innovation, we‚Äôre able to explore new ideas at the frontier, while also unlocking the possibility of new and exciting Gemini use cases.Learn more about Gemini and its capabilities. Your information will be used in accordance with Google‚Äôs privacy policy.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>      Done. Just one step more.
    
      Check your inbox to confirm your subscription.
    You are already subscribed to our newsletter.
    You can also subscribe with a
    different email address
    
    .
    
  New funding from Google will help launch a regional Data Commons for Africa.Let‚Äôs stay in touch. Get the latest news from Google in your inbox.
          Follow Us
</code></pre></div></div>]]></content><author><name></name></author><summary type="html"><![CDATA[We‚Äôre sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://tannerduve.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog"/><published>2022-04-23T23:20:09+00:00</published><updated>2022-04-23T23:20:09+00:00</updated><id>https://tannerduve.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://tannerduve.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[<h3>External Posts on Your al-folio¬†Blog</h3> <p>If you prefer publishing blog posts on medium.com or other external sources, starting version v0.5.0, <a href="https://github.com/alshedivat/al-folio">al-folio</a> lets you to display your external posts in the blog feed of your website!¬†üéâüéâ</p> <p>Configuring external sources of super simple. After upgrading to v0.5.0, just add the following section to your _config.yml:</p> <pre>external_sources:<br />  - name: medium.com  # name of the source (arbitrary string)<br />    rss_url: <a href="https://medium.com/@al-folio/feed">https://medium.com/@&lt;your-medium-username&gt;/feed</a></pre> <p>The example above adds your medium.com blog post feed as an external source. But you can add arbitrary RSS feeds as¬†sources.</p> <p>Any questions or suggestions? üëâ Start <a href="https://github.com/alshedivat/al-folio/discussions">a discussion on¬†GitHub</a>!</p> <p><img src="https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b60a1d241a0a" width="1" height="1" alt=""/></p>]]></content><author><name></name></author></entry></feed>