<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://tannerduve.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://tannerduve.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2026-02-08T18:42:50+00:00</updated><id>https://tannerduve.github.io/feed.xml</id><title type="html">blank</title><entry><title type="html">Foundations of Algorithmic Randomness and Computability</title><link href="https://tannerduve.github.io/blog/2026/algorithmic-randomness/" rel="alternate" type="text/html" title="Foundations of Algorithmic Randomness and Computability"/><published>2026-02-07T20:00:00+00:00</published><updated>2026-02-07T20:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2026/algorithmic-randomness</id><content type="html" xml:base="https://tannerduve.github.io/blog/2026/algorithmic-randomness/"><![CDATA[<p><em>Written jointly with <a href="https://elanroth.github.io">Elan Roth</a></em></p> <h2 id="introduction">Introduction</h2> <p>This post explores two fundamental questions: what does it mean to be random, and what does it mean to compute? We develop the theory of computation and algorithmic randomness by introducing historical background, the central constructions in computability theory, and three mathematical approaches to defining randomness. Our discussion is enriched by a formalization written in the Lean theorem prover, and code snippets will be used throughout the text to supplement and substantiate the ideas we present.</p> <h2 id="i-history">I. History</h2> <h3 id="the-dream-of-mechanical-reasoning">The Dream of Mechanical Reasoning</h3> <p>At the turn of the twentieth century, David Hilbert expressed the belief that all of mathematics could be reduced to mechanical symbolic manipulation, void of the need for human insight or creativity. If we could just find the right formal system, the right rules for pushing symbols around, then we could put any conjecture into a machine and receive either a proof or a refutation. In terms that hadn’t yet been coined, he believed in the existence of an <em>algorithm</em> for deciding all mathematical truth. This was referred to as the Entscheidungsproblem.</p> <p>To answer this question positively, one would simply have to provide such an algorithm. But to prove such a machine does not exist, we need to step back and answer a more fundamental question: <em>what is an algorithm?</em>. Before the 1930s, this notion lived only in intuition. Computation had the status of “I know it when I see it”. But to make progress on this question we had to put the notion on formal grounds.</p> <p>In the 1930s, Turing, Church, and Gödel each provided rigorous definitions of computability, and these definitions gave us the tools to prove Hilbert wrong. Gödel’s incompleteness theorems showed that any sufficiently powerful formal system contains true statements it cannot prove, Turing proved that no algorithm can decide whether an arbitrary program halts, and the fully mechanical mathematician was proven impossible.</p> <p>Still, something survives from Hilbert’s vision. We cannot mechanize the <em>discovery</em> of all mathematical truth, but we can mechanize its <em>verification</em>. Modern proof assistants like Lean, Coq, and Isabelle let us write proofs in formal languages where every step is checked against a set of rules encoded into the language. The computer cannot tell us what to prove or how, but it can confirm, with absolute certainty, that our reasoning is valid.</p> <p>While Gödel and Turing’s results provide hard theoretical limits on computation, recent progress in machine learning suggests that some sufficiently advanced models may be able to approximate Hilbert’s dream in practice. Modern systems have very recently been able to generate formal proofs of previously unsolved problems, do graduate-level mathematics, and win the most difficult math competitions. They’re beginning to assist not just with verification but with actual mathematical discovery. One can imagine an AI system powerful enough to answer, with high probability, every mathematical question humans actually want to ask, and this would resemble Hilbert’s magical oracle.</p> <h3 id="three-models-of-computation">Three Models of Computation</h3> <p>In the 1930s, three mathematicians working independently proposed formal definitions of computability. Alan Turing imagined an idealized human computer: someone with unlimited paper, a finite set of instructions, and infinite patience. Alonzo Church built a calculus of pure functions, where computation meant simplifying terms by applying and substituting. And Kurt Gödel, building on work by Herbrand, defined a class of arithmetic functions that could be built from simple pieces using specific construction rules.</p> <p><strong>Turing machines.</strong> Alan Turing’s idealized human computer: someone with unlimited paper tape divided into cells, and a finite set of instructions. The machine reads one cell at a time, writes a symbol, moves left or right, and transitions between states according to fixed rules. Turing claims a function is computable if there is a Turing machine which will halt and return the output of the function.</p> <p><strong>Lambda calculus.</strong> Alonzo Church’s calculus of pure functions. This is a language that consists of simple expressions that can be applied to other expressions and simplified by substituting variables. Church claims a function is computable if it can be written as a lambda expression.</p> <p><strong>Recursive functions.</strong> Kurt Gödel’s class of number-theoretic functions built from simple primitives: zero, successor, projections—using composition, primitive recursion, and unbounded search. Gödel claims a function is computable if it belongs to this class.</p> <h3 id="the-church-turing-thesis">The Church-Turing Thesis</h3> <p>Surprisingly, it turns out that these seemingly different notions of computation - computation as instruction following, computation as term simplification, and computation as recursion on $\mathbb{N}$ - are exactly equivalent. This is a mathematical theorem: any Turing-computable function is lambda-definable, any lambda-definable function is recursive, and any recursive function is Turing-computable.</p> <p>The <strong>Church-Turing thesis</strong> is a philosophical claim asserting that this shared class captures precisely the functions that are computable in the intuitive sense: that our formal definitions match what we mean when we speak of computation. Since “intuitive computability” is not a mathematical concept, this claim cannot be proven, and is a hypothesis about how our mathematical formalisms capture physical reality.</p> <p>While the CT thesis can’t be proven, this convergence provides pretty convincing evidence of its truth. Three mathematicians with different motivations and different formalisms arrived at the same boundary. Every subsequent attempt to formalize computation—register machines, Post systems, cellular automata—has yielded the same class of functions. When every reasonable approach produces identical results, we have good reason to believe we’ve identified something fundamental about the universe.</p> <h2 id="ii-formal-introduction">II. Formal Introduction</h2> <h3 id="partial-recursive-functions">Partial Recursive Functions</h3> <p>We work with the recursive function approach, as it connects most directly to our formalization. A <strong>partial recursive function</strong> is built from simple primitives using a small set of operations. The word “partial” matters here: these functions need not be defined everywhere. A computation might run forever without producing an answer.</p> <p>The computable primitives:</p> <p><strong>Zero</strong>: The constant function returning 0, regardless of input.</p> <p><strong>Successor</strong>: Given $n$, return $n + 1$.</p> <p><strong>Projections</strong>: Given a tuple of inputs, extract one component. The left projection takes $(a, b)$ to $a$; the right projection takes $(a, b)$ to $b$.</p> <p>From these atoms, we build molecules using three operations:</p> <p><strong>Pairing/Composition</strong>: If we can compute $f$ and $g$, we can compute their composition $f \circ g$, and we can compute functions that combine their outputs.</p> <p><strong>Primitive Recursion</strong>: This captures the idea of computing by induction. Given a base case function $f$ and a step function $h$, we define:</p> \[\begin{aligned} \text{rec}(a, 0) &amp;= f(a) \\ \text{rec}(a, n+1) &amp;= h(a, n, \text{rec}(a, n)) \end{aligned}\] <p>The value at $n+1$ depends on the value at $n$. This is how you’d compute factorial, exponentiation, or any function defined by “do the previous thing, then one more step.”</p> <p><strong>Unbounded Search (μ-minimization)</strong>: This is where partiality enters. Given a function $f(a, n)$, the μ-operator searches for the smallest $n$ such that $f(a, n) = 0$:</p> \[\mu n. [f(a, n) = 0] = \text{the least } n \text{ with } f(a, n) = 0\] <p>If no such $n$ exists, the search runs forever. The function is undefined at that input.</p> <h3 id="μ-minimization">μ-Minimization</h3> <p>Primitive recursion alone gives you a lot: all the arithmetic operations, primality testing, anything with a predictable runtime. But it doesn’t give you <em>everything</em> computable.</p> <p>Consider the following problem: given a description of a computation, find when (if ever) it terminates. This requires searching through time steps 0, 1, 2, … until termination occurs. There’s no bound you can compute in advance. You must simply search, and the search may never end.</p> <p>The μ-operator is what separates the <em>primitive</em> recursive functions from the <em>partial</em> recursive functions. It’s the source of undecidability, of partial functions, of computations that might diverge. It’s also what makes the recursive functions powerful enough to capture all of computation.</p> <h3 id="oracles-and-relative-computability">Oracles and Relative Computability</h3> <p>We can all recognize that some problems are harder than others. In computability we are interested in comparing the relative difficulty of computational problems. One way to compare difficulty is through <em>reducibility</em>. Reducibility is a way of converting one problem into another, something which naturally comes up in everyday life. For example, if you are looking to find your way to a certain destination, this becomes easy if you are able to obtain a map to your destination, i.e. the problem of finding your destination <em>reduces</em> to finding a map to it. Another way to look at it is: the problem of finding your destination is <em>no more unsolvable</em> than the problem of obtaining a map.</p> <p>Suppose we augment our computing device with an <strong>oracle</strong>, a black box that instantly answers queries about some function $g$. We can’t see inside the box; we just submit inputs and receive outputs, at zero cost. A function $f$ is <strong>recursive in</strong> $g$ (written $f \leq_T g$ for Turing reducibility) if $f$ can be computed by a machine with oracle access to $g$. This relation captures a notion of <em>relative difficulty</em>: $f \leq_T g$ means “$f$ is no harder to compute than $g$,” or “if someone handed us the answers for $g$, we could compute $f$.”</p> <p>The formal definition extends partial recursive functions by adding oracle calls as primitives:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">RecursiveIn</span> (<span class="n">O</span> : <span class="n">Set</span> (<span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>)) : (<span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) <span class="o">→</span> <span class="kt">Prop</span>
  <span class="o">|</span> <span class="n">zero</span> : <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="k">fun</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="n">succ</span> : <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="n">Nat</span><span class="o">.</span><span class="n">succ</span>
  <span class="o">|</span> <span class="n">left</span> : <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="k">fun</span> <span class="n">n</span> <span class="o">=&gt;</span> (<span class="n">Nat</span><span class="o">.</span><span class="n">unpair</span> <span class="n">n</span>)<span class="o">.1</span>
  <span class="o">|</span> <span class="n">right</span> : <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="k">fun</span> <span class="n">n</span> <span class="o">=&gt;</span> (<span class="n">Nat</span><span class="o">.</span><span class="n">unpair</span> <span class="n">n</span>)<span class="o">.2</span>
  <span class="o">|</span> <span class="n">oracle</span> : <span class="o">∀</span> <span class="n">g</span> <span class="err">∈</span> <span class="n">O</span>, <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="n">g</span>
  <span class="o">|</span> <span class="n">pair</span> <span class="o">...</span> <span class="o">|</span> <span class="n">comp</span> <span class="o">...</span> <span class="o">|</span> <span class="n">prec</span> <span class="o">...</span> <span class="o">|</span> <span class="n">rfind</span> <span class="o">...</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">oracle</code> constructor says: any function in our oracle set $O$ is computable relative to $O$. Everything else is the same machinery of pairing, composition, primitive recursion, and search.</p> <p>μ-Minimization is encoded as:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">|</span> <span class="n">rfind</span> <span class="err">{</span><span class="n">f</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span><span class="err">}</span> (<span class="n">hf</span> : <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="n">f</span>) :
    <span class="n">RecursiveIn</span> <span class="n">O</span> <span class="k">fun</span> <span class="n">a</span> <span class="o">=&gt;</span>
      <span class="n">Nat</span><span class="o">.</span><span class="n">rfind</span> <span class="k">fun</span> <span class="n">n</span> <span class="o">=&gt;</span> (<span class="k">fun</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>) <span class="o">&lt;</span><span class="err">$</span><span class="o">&gt;</span> <span class="n">f</span> (<span class="n">Nat</span><span class="o">.</span><span class="n">pair</span> <span class="n">a</span> <span class="n">n</span>)
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">Nat.rfind</code> searches for the first $n$ where $f(a, n) = 0$. If found, it returns that $n$. If $f(a, n) \neq 0$ for all $n$, the result is <code class="language-plaintext highlighter-rouge">Part.none</code>: undefined.</p> <h3 id="degrees-of-unsolvability">Degrees of Unsolvability</h3> <p>The reducibility relation orders problems by their inherent complexity. It is reflexive: any problem reduces to itself, since you can just solve it directly. It is transitive: if $f$ reduces to $g$ and $g$ reduces to $h$, then $f$ reduces to $h$ by chaining the reductions. But it is not antisymmetric. Two genuinely different problems can be mutually reducible, each one solvable given access to the other. When this happens, we say $f$ and $g$ are <strong>Turing equivalent</strong> ($f \equiv_T g$). They sit at the same level of difficulty.</p> <p>A <strong>Turing degree</strong> is an equivalence class of problems under this mutual reducibility. All problems in a degree share the same computational complexity in a fundamental sense: each can simulate any other. The degree itself represents a “level” of unsolvability, an abstract measure of how hard its member problems are.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">TuringEquivalent</span> (<span class="n">f</span> <span class="n">g</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) : <span class="kt">Prop</span> :=
  <span class="n">AntisymmRel</span> <span class="n">TuringReducible</span> <span class="n">f</span> <span class="n">g</span>

<span class="n">abbrev</span> <span class="n">TuringDegree</span> :=
  <span class="n">Antisymmetrization</span> <span class="n">_</span> <span class="n">TuringReducible</span>
</code></pre></div></div> <p>To compare degrees rather than individual functions, we must lift the ordering. We say degree <strong>a</strong> is below degree <strong>b</strong> (written <strong>a</strong> $\leq$ <strong>b</strong>) if some representative of <strong>a</strong> reduces to some representative of <strong>b</strong>.</p> <p>With this lifted ordering, the Turing degrees form a <strong>partial order</strong>: reflexive, transitive, and now antisymmetric by construction. Two degrees are equal exactly when their members are mutually reducible. At the bottom sits $\mathbf{0}$, the degree containing all computable functions. These are the “easy” problems, solvable by algorithms with no oracle at all. They’re all Turing-equivalent to each other: any computable function can compute any other without an oracle.</p> <h3 id="the-structure-of-the-degrees">The Structure of the Degrees</h3> <p>The simplest non-computable degree is $\mathbf{0’}$ (read “zero jump”), the degree of the halting problem. Given an encoding of programs, the halting problem asks: does program $e$ halt on input $n$? Turing proved that no computable function can answer this question for all pairs $(e, n)$. Yet the halting problem is well-defined as a set, and any function that could answer it would live in degree $\mathbf{0’}$.</p> <p>The relationship between 0 and 0’ is an instance of a general construction called the <strong>jump operator</strong>. Given any function $f$, its jump $f’$ is the <em>relativized halting problem</em>: which programs halt when given oracle access to $f$? We can simulate any $f$-oracle program step by step, so $f’$ is computable <em>from</em> $f$. But crucially, $f’$ is never computable <em>in</em> $f$. The same diagonalization that makes the halting problem undecidable relativizes: no $f$-oracle program can decide which $f$-oracle programs halt. This means the degrees are unbounded from above. For any degree <strong>a</strong>, the jump <strong>a’</strong> sits strictly higher:</p> \[\mathbf{0} &lt; \mathbf{0'} &lt; \mathbf{0''} &lt; \mathbf{0'''} &lt; \cdots\] <p>One might imagine that the hierarchy of degrees forms a linear chain, ie. that the degrees are totally ordered. However, in 1956, Friedberg and Muchnik independently proved that there exist <strong>incomparable degrees</strong>: degrees <strong>a</strong> and <strong>b</strong> such that neither <strong>a</strong> $\leq$ <strong>b</strong> nor <strong>b</strong> $\leq$ <strong>a</strong>. This shows that some problems are incommensurable in difficulty; neither helps you solve the other.</p> <p>More specifically the degrees form a join semilattice: any two degrees <strong>a</strong> and <strong>b</strong> have a least upper bound <strong>a</strong> $\lor$ <strong>b</strong>. Picture the structure as branching upward everywhere. From $\mathbf{0}$, it fans out into continuum-many incomparable directions. There are minimal degrees just above $\mathbf{0}$ with nothing between. There are dense chains. There are antichains of any finite size. Any two degrees can be joined, so paths merge going up. But there’s no ceiling, and no uniform way to factor a degree into simpler pieces.</p> <p>In Lean, we define the join by interleaving: even inputs query $f$, odd inputs query $g$, and we encode which oracle answered in the output.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">join</span> (<span class="n">f</span> <span class="n">g</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span> :=
  <span class="k">fun</span> <span class="n">n</span> <span class="o">=&gt;</span>
    <span class="n">cond</span> <span class="n">n</span><span class="o">.</span><span class="n">bodd</span> 
    ( (<span class="n">g</span> <span class="n">n</span><span class="o">.</span><span class="n">div2</span>)<span class="o">.</span><span class="n">map</span> (<span class="k">fun</span> <span class="n">y</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span>) ) 
    ( (<span class="n">f</span> <span class="n">n</span><span class="o">.</span><span class="n">div2</span>)<span class="o">.</span><span class="n">map</span> (<span class="k">fun</span> <span class="n">y</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y</span>) )
<span class="k">infix</span> :<span class="mi">50</span> <span class="s">" ⊕ "</span> <span class="o">=&gt;</span> <span class="n">join</span>
</code></pre></div></div> <p>This definition of <code class="language-plaintext highlighter-rouge">join</code> forms the least upper bound (supremum) in our lattice:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">lemma</span> <span class="n">left_le_join</span> (<span class="n">f</span> <span class="n">g</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) : <span class="n">f</span> <span class="o">≤</span><span class="err">ᵀ</span> (<span class="n">f</span> <span class="err">⊕</span> <span class="n">g</span>)
<span class="k">lemma</span> <span class="n">right_le_join</span> (<span class="n">f</span> <span class="n">g</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) : <span class="n">g</span> <span class="o">≤</span><span class="err">ᵀ</span> (<span class="n">f</span> <span class="err">⊕</span> <span class="n">g</span>)
<span class="k">lemma</span> <span class="n">join_le</span> (<span class="n">f</span> <span class="n">g</span> <span class="n">h</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) (<span class="n">hf</span> : <span class="n">f</span> <span class="o">≤</span><span class="err">ᵀ</span> <span class="n">h</span>) (<span class="n">hg</span> : <span class="n">g</span> <span class="o">≤</span><span class="err">ᵀ</span> <span class="n">h</span>) : (<span class="n">f</span> <span class="err">⊕</span> <span class="n">g</span>) <span class="o">≤</span><span class="err">ᵀ</span> <span class="n">h</span>
</code></pre></div></div> <p>Using some quotient machinery we can lift this to a least upper bound on degrees, which gives us the following instance:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">instance</span> <span class="n">instSemilatticeSup</span> : <span class="n">SemilatticeSup</span> <span class="n">TuringDegree</span> <span class="n">where</span>
  <span class="n">sup</span> := <span class="n">sup</span>
  <span class="n">le_sup_left</span> := <span class="n">le_sup_left</span>
  <span class="n">le_sup_right</span> := <span class="n">le_sup_right</span>
  <span class="n">sup_le</span> <span class="n">_</span> <span class="n">_</span> <span class="n">_</span> := <span class="n">sup_le</span>
</code></pre></div></div> <p>One mysterious part of the structure of the Turing degrees is its <strong>automorphism group</strong>, $Aut(\mathbf{T})$. An automorphism of the Turing degrees is a permutation $\pi$ that preserves the ordering in both directions: $a \leq b$ if and only if $\pi(a) \leq \pi(b)$. The trivial automorphism is the identity function. There is an open conjecture which asks whether there are <em>any</em> non-trivial automorphisms at all. The closest we’ve gotten is from Slaman and Woodin, who proved that $Aut(\mathbf{T})$ is at most countable - we don’t know if there are more than one, but we know there are fewer than there are real numbers!</p> <p>These different aspects of this structure matter for randomness. When we say a sequence is “random,” we are making a claim about its computational properties. Random sequences are incomputable—they sit strictly above $\mathbf{0}$—and they resist computation in specific, measure-theoretic ways.</p> <h3 id="gödel-encoding-programs-as-numbers">Gödel Encoding: Programs as Numbers</h3> <p>A key technique running through all of computability theory is <strong>Gödel encoding</strong>, the representation of syntactic objects as natural numbers. Programs, formulas, proofs, and even other encodings can all be assigned numerical codes.</p> <p>The basic intuition is straightforward. A program is a finite string of symbols. We can list all such strings and assign each a unique natural number. Given the number, we can recover the string; given the string, we can compute its number. In our formalization, we encode the syntax of oracle computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">encode</span> : <span class="n">Program</span> <span class="o">→</span> <span class="o">ℕ</span>
<span class="o">|</span> <span class="o">.</span><span class="n">zero</span>       <span class="o">=&gt;</span> <span class="mi">0</span>
<span class="o">|</span> <span class="o">.</span><span class="n">succ</span>       <span class="o">=&gt;</span> <span class="mi">1</span>
<span class="o">|</span> <span class="o">.</span><span class="n">left</span>       <span class="o">=&gt;</span> <span class="mi">2</span>
<span class="o">|</span> <span class="o">.</span><span class="n">right</span>      <span class="o">=&gt;</span> <span class="mi">3</span>
<span class="o">|</span> <span class="o">.</span><span class="n">oracle</span> <span class="n">i</span>   <span class="o">=&gt;</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">i</span>
<span class="o">|</span> <span class="o">.</span><span class="n">pair</span> <span class="n">p</span> <span class="n">q</span>   <span class="o">=&gt;</span> <span class="mi">4</span> <span class="o">+</span> (<span class="mi">5</span> <span class="o">*</span> <span class="n">Nat</span><span class="o">.</span><span class="n">pair</span> (<span class="n">encode</span> <span class="n">p</span>) (<span class="n">encode</span> <span class="n">q</span>) <span class="o">+</span> <span class="mi">1</span>)
<span class="o">|</span> <span class="o">.</span><span class="n">comp</span> <span class="n">p</span> <span class="n">q</span>   <span class="o">=&gt;</span> <span class="mi">4</span> <span class="o">+</span> (<span class="mi">5</span> <span class="o">*</span> <span class="n">Nat</span><span class="o">.</span><span class="n">pair</span> (<span class="n">encode</span> <span class="n">p</span>) (<span class="n">encode</span> <span class="n">q</span>) <span class="o">+</span> <span class="mi">2</span>)
<span class="o">|</span> <span class="o">.</span><span class="n">prec</span> <span class="n">p</span> <span class="n">q</span>   <span class="o">=&gt;</span> <span class="mi">4</span> <span class="o">+</span> (<span class="mi">5</span> <span class="o">*</span> <span class="n">Nat</span><span class="o">.</span><span class="n">pair</span> (<span class="n">encode</span> <span class="n">p</span>) (<span class="n">encode</span> <span class="n">q</span>) <span class="o">+</span> <span class="mi">3</span>)
<span class="o">|</span> <span class="o">.</span><span class="n">rfind</span> <span class="n">p</span>    <span class="o">=&gt;</span> <span class="mi">4</span> <span class="o">+</span> (<span class="mi">5</span> <span class="o">*</span> <span class="n">encode</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">4</span>)
</code></pre></div></div> <p>Each constructor of our <code class="language-plaintext highlighter-rouge">Program</code> type maps to a distinct numerical range. The pairing function <code class="language-plaintext highlighter-rouge">Nat.pair</code> lets us encode composite structures into single numbers, and the coefficients (the factors of 5 plus offsets) ensure we can always decode unambiguously.</p> <p>Decoding reverses this: we inspect the residue mod 5 to determine the constructor, then recurse on the quotient.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">decode</span> : <span class="o">ℕ</span> <span class="o">→</span> <span class="n">Program</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">zero</span>
  <span class="o">|</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">succ</span>
  <span class="o">|</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">left</span>
  <span class="o">|</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">right</span>
  <span class="o">|</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">=&gt;</span>
    <span class="n">let</span> <span class="n">q</span> := <span class="n">n</span> <span class="o">/</span> <span class="mi">5</span>
    <span class="k">match</span> <span class="n">n</span> <span class="err">%</span> <span class="mi">5</span> <span class="k">with</span>
    <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">oracle</span> <span class="n">q</span>
    <span class="o">|</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">pair</span> (<span class="n">decode</span> <span class="n">q</span><span class="o">.</span><span class="n">unpair</span><span class="o">.1</span>) (<span class="n">decode</span> <span class="n">q</span><span class="o">.</span><span class="n">unpair</span><span class="o">.2</span>)
    <span class="o">|</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">comp</span> (<span class="n">decode</span> <span class="n">q</span><span class="o">.</span><span class="n">unpair</span><span class="o">.1</span>) (<span class="n">decode</span> <span class="n">q</span><span class="o">.</span><span class="n">unpair</span><span class="o">.2</span>)
    <span class="o">|</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">prec</span> (<span class="n">decode</span> <span class="n">q</span><span class="o">.</span><span class="n">unpair</span><span class="o">.1</span>) (<span class="n">decode</span> <span class="n">q</span><span class="o">.</span><span class="n">unpair</span><span class="o">.2</span>)
    <span class="o">|</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">rfind</span> (<span class="n">decode</span> <span class="n">q</span>)
</code></pre></div></div> <p>These are inverses:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">decode_encode</span> (<span class="n">c</span> : <span class="n">Program</span>) : <span class="n">decode</span> (<span class="n">encode</span> <span class="n">c</span>) <span class="o">=</span> <span class="n">c</span>
</code></pre></div></div> <p>As programmers we all know that programs can call other programs. Encoding allows this intuitive idea to be made formal. If programs are numbers, then a program can take another program’s code as input and simulate it step by step. A universal machine does exactly this: given a code $e$ and input $n$, it runs whatever program $e$ specifies on $n$.</p> <p>Gödel encoding also enables self-reference. A program can receive its own code as input. This is how Gödel constructed his incompleteness sentences, and it underlies many undecidability proofs. In our setting, it lets us state and prove that the evaluation function <code class="language-plaintext highlighter-rouge">eval</code> is universal: every function recursive in an oracle has some code that <code class="language-plaintext highlighter-rouge">eval</code> will faithfully execute.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">exists_code</span> <span class="err">{</span>α : <span class="kt">Type</span><span class="err">}</span> [<span class="n">Primcodable</span> α] (<span class="n">g</span> : α <span class="o">→</span> <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) (<span class="n">f</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) :
  <span class="n">RecursiveIn</span> (<span class="n">Set</span><span class="o">.</span><span class="n">range</span> <span class="n">g</span>) <span class="n">f</span> <span class="o">↔</span> <span class="o">∃</span> <span class="n">p</span> : <span class="n">Program</span>, <span class="n">eval</span> <span class="n">g</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f</span>
</code></pre></div></div> <p>This theorem is the formal statement of universality. A function is recursive in $g$ if and only if it has a code. The encoding bridges syntax and semantics: it lets us treat programs as data, feeding a program its own code as input.</p> <p>This encoding additionally allows us to define the jump operator mentioned previously.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">jump</span> (<span class="n">f</span> : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span>) : <span class="o">ℕ</span> <span class="o">→.</span> <span class="o">ℕ</span> :=
  <span class="k">λ</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="n">eval</span> (<span class="k">λ</span> <span class="n">_</span> : <span class="n">Unit</span> <span class="o">=&gt;</span> <span class="n">f</span>) (<span class="n">decode</span> <span class="n">n</span>) <span class="n">n</span>
</code></pre></div></div> <p>To compute the jump of an oracle $f$ on input $n$, we decode $n$ as a program, run that program on input $n$ with oracle access to $f$, and return whatever it returns. The domain of this function—the set of $n$ where the $n$-th $f$-oracle program halts on itself—is the halting problem relative to $f$.</p> <p>The theory developed in this section allows us to study infinite objects through the lens of computation. In particular, we can ask whether an infinite binary sequence can be predicted, compressed, or successfully exploited by any algorithmic procedure. This viewpoint leads to computability-theoretic definitions of randomness, which introduce in the next section.</p> <h2 id="iii-three-definitions-of-randomness">III. Three Definitions of Randomness</h2> <p>Armed with this hefty tool we call “computation,” we may use against another abstract notion: Randomness. What is <em>randomness</em>? Intuitively we may have some ideas, but formalization requires rigor. First, we must fix an object of study. What things are we going to classify as random or not random? As algorithmic randomness is a field within theoretical computer science, those who came before us chose infinite binary sequences. Here are a few examples:</p> <ul> <li>$A_1 := 000 \dots$</li> <li>$A_2 := 01010101 \dots$</li> <li>$A_3 := 10110111011110111110 \dots$</li> <li>$A_4 := 10100101001011101001 \dots$</li> </ul> <p>Which ones do you think are random? What pattern do the non-random seeming ones follow? You may have noticed that the use of $\dots$ is leading; stopping after three $0$’s in $A_1$ clearly indicates that the $0$’s will repeat, and similarly with the pattern $01$ in $A_2$. So these are definitely <em>not</em> random. $A_3$ and $A_4$ are left for your consideration. We urge you to pause and attempt to define your own notion of randomness. We present below three individuals’ characterizations of random binary sequences. Is yours similar?</p> <h3 id="kolmogorov-complexity-and-incompressibility">Kolmogorov Complexity and Incompressibility</h3> <p>To study the first notion, we must humble ourselves. Infinite binary strings are impossible to fathom because (and only because) they are infinite. While we cannot grasp infinity, we can appeal to the finite world we do understand. Where we can put our conveniently formalized theory of computation into action. With these tools, we can reasonably observe arbitrarily long initial segments of our infinite binary string in question.</p> <p>Using the same idea of encoding programs as above, we can encode finite binary strings into natural numbers in order to use the recursive functions. Note that <code class="language-plaintext highlighter-rouge">decode_encode</code> asserts that we can go back and forth between binary strings and natural numbers without losing any data.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">BinSeq</span> := <span class="n">List</span> <span class="n">Bool</span>

<span class="k">def</span> <span class="n">encode</span> : <span class="n">BinSeq</span> <span class="o">→</span> <span class="n">Nat</span>
  <span class="o">|</span> []      <span class="o">=&gt;</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="n">b</span> :: <span class="err">σ</span> <span class="o">=&gt;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">encode</span> <span class="err">σ</span> <span class="o">+</span> (<span class="n">if</span> <span class="n">b</span> <span class="n">then</span> <span class="mi">2</span> <span class="n">else</span> <span class="mi">1</span>)

<span class="k">def</span> <span class="n">decode</span> : <span class="n">Nat</span> <span class="o">→</span> <span class="n">Option</span> <span class="n">BinSeq</span>
  <span class="o">|</span> <span class="mi">0</span> <span class="o">=&gt;</span> <span class="n">some</span> []
  <span class="o">|</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">=&gt;</span>
    <span class="n">if</span> (<span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>) <span class="err">%</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">1</span> <span class="n">then</span> <span class="n">List</span><span class="o">.</span><span class="n">cons</span> <span class="n">false</span> <span class="o">&lt;</span><span class="err">$</span><span class="o">&gt;</span> (<span class="n">decode</span> ((<span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>) <span class="o">/</span> <span class="mi">2</span>))
    <span class="n">else</span> <span class="n">List</span><span class="o">.</span><span class="n">cons</span> <span class="n">true</span> <span class="o">&lt;</span><span class="err">$</span><span class="o">&gt;</span> (<span class="n">decode</span> ((<span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>) <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>))

<span class="k">theorem</span> <span class="n">decode_encode</span> (<span class="err">σ</span> : <span class="n">BinSeq</span>) :
  <span class="n">decode</span> (<span class="n">encode</span> <span class="err">σ</span>) <span class="o">=</span> <span class="err">σ</span>
</code></pre></div></div> <p>Algorithmic randomness uses the term “machine” to describe the lifting of a partially recursive function to take and return finite binary strings. Given some fixed machine, $M$, we can ask which strings it will output and how difficult it is to actually return them. For some finite binary string, $\sigma$, we may ask what is the shortest string such that running $M$ on that string will output $\sigma$. Formally, we can define Kolmogorov complexity with respect to a machine $M$ as</p> \[C_M(\sigma) = \min \{ |\tau| : M(\tau) = \sigma \}\] <p>where $|\tau|$ denotes the length of $\tau$ and $M(\tau) = \sigma$ means executing machine $M$ on $\tau$ halts with output $\sigma$.</p> <p>Now, inputs to these machines that halt on any arbitrary set of inputs have access more information than just the bits that make them up. Such a machine must somehow know when it has finished reading its input. Since our programs consist only of $0$’s and $1$’s, this information cannot come from a special end marker. Essentially, the machine is given the length of the input for free, even though this information is not encoded in the input string.</p> <p>From an information-theoretic perspective, this is unsatisfactory. If we hope for inputs to convey only the information of their bits, our machines must know where the string ends. To circumvent this issue, we restrict our attention to prefix-free machines. A machine $M$ is prefix-free if whenever $M(\sigma)$ and $M(\tau)$ both halt with $\sigma \neq \tau$, then $\sigma$ is not a prefix of $\tau$ and vice versa.</p> <p>But why just concern ourselves with $M$? Recall that universal machines can simulate every other machine, meaning for all machines $M$, and strings $\sigma$, there is some $\rho_M$ such that</p> \[U(\rho_M \sigma) = M(\sigma)\] <p>where $\rho_M$ is the coding string for machine $M$ and $|\rho_M|$ is the coding constant for $U$, the cost of simulating $M$. Fortunately for us, universal prefix-free machines exist and we can define prefix-free Kolmogorov complexity to be $K(\sigma) = C_U(\sigma)$ where $U$ is prefix-free. In our formalization, we have the following</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">Produces</span> <span class="err">{</span>α : <span class="kt">Type</span><span class="err">}</span> [<span class="n">Primcodable</span> α]
  (<span class="n">F</span> : <span class="n">OracleFamily</span> α) (<span class="err">σ</span> : <span class="n">BinSeq</span>) (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="kt">Prop</span> :=
  <span class="o">∃</span> <span class="n">p</span> : <span class="n">BinSeq</span>, <span class="n">p</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">n</span> <span class="o">∧</span> <span class="n">U</span> <span class="n">F</span> <span class="n">p</span> [] <span class="o">=</span> <span class="n">Part</span><span class="o">.</span><span class="n">some</span> <span class="err">σ</span>

<span class="k">def</span> <span class="n">goodLengths</span> <span class="err">{</span>α : <span class="kt">Type</span><span class="err">}</span> [<span class="n">Primcodable</span> α] (<span class="n">F</span> : <span class="n">OracleFamily</span> α) (<span class="err">σ</span> : <span class="n">BinSeq</span>) : <span class="n">Set</span> <span class="n">Nat</span> :=
  <span class="err">{</span> <span class="n">n</span> <span class="o">|</span> <span class="n">Produces</span> <span class="n">F</span> <span class="err">σ</span> <span class="n">n</span> <span class="err">}</span>
</code></pre></div></div> <p>We define <code class="language-plaintext highlighter-rouge">Produces</code> as a proposition over strings $\sigma$ and natural numbers $n$ such that there exists some program with length $n$ and executing that program outputs $\sigma$. Then, <code class="language-plaintext highlighter-rouge">goodLengths</code> is the set of lengths that satisfies <code class="language-plaintext highlighter-rouge">Produces</code> for some $\sigma$. Finally, we can formalize Kolmogorov complexity, first relativized to a family of oracles, and second to no oracles.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">noncomputable</span> <span class="k">def</span> <span class="n">plainKC</span> <span class="err">{</span>α : <span class="kt">Type</span><span class="err">}</span> [<span class="n">Primcodable</span> α]
  (<span class="n">F</span> : <span class="n">OracleFamily</span> α) (<span class="err">σ</span> : <span class="n">BinSeq</span>) : <span class="n">Nat</span> :=
<span class="k">by</span>
  <span class="n">classical</span>
  <span class="n">let</span> <span class="n">S</span> : <span class="n">Set</span> <span class="n">Nat</span> := <span class="n">goodLengths</span> <span class="n">F</span> <span class="err">σ</span>
  <span class="n">exact</span> <span class="n">if</span> <span class="n">h</span> : <span class="n">S</span><span class="o">.</span><span class="n">Nonempty</span> <span class="n">then</span> <span class="n">sInf</span> <span class="n">S</span> <span class="n">else</span> <span class="err">σ</span><span class="o">.</span><span class="n">length</span>

<span class="n">noncomputable</span> <span class="k">def</span> <span class="n">K</span> (<span class="err">σ</span> : <span class="n">BinSeq</span>) : <span class="n">Nat</span> :=
  <span class="n">plainKC</span> (<span class="n">asFamily</span> <span class="n">empty</span>) <span class="err">σ</span>
</code></pre></div></div> <p>While this may seem like theoretical nonsense, the very device you are reading this on is a universal machine (with some technical caveats we do not have to get into). Machines can be thought of as programming languages, and your computer or phone is a universal machine that compiles programs written in other languages.</p> <p>Finally, we arrive at Kolmogorov’s definition of randomness: an infinite binary string is random if it is incompressible. Letting $A \upharpoonright n$ denote the first $n$ bits of the binary string $A$, Kolmogorov says a string $A$ is random if there is some constant $c$ such that for all $n$, $K(A \upharpoonright n) \ge n - c$.</p> <p>A string $A$ is random if there is no program that can effectively compress any of its initial segments. The constant arises from the cost of simulating other machines, where different choices for universal machines yield different behaviour, but are all within a constant. Here, we find a representation of randomness that is defined by its ability to evade computation.</p> <h3 id="measure-theoretic-randomness">Measure Theoretic Randomness</h3> <p>Per Martin-Löf took a different approach. He used measure theory to check how properties of strings can be encoded in its initial segments. These finite binary strings that we have been playing around with fortunately form a measurable space. Consider the tree below</p> <p><img src="/assets/img/binary-tree.png" alt="Binary Tree" title="Binary Tree"/></p> <table> <tbody> <tr> <td>If we think of the tree as having total measure $1$, then its subtrees with roots at (the binary strings) $0$ and $1$ each have measure $\frac{1}{2}$ since their sum gives the measure of the entire tree. In fact, as we go down the tree, we define the subtree with root $\sigma$ to have measure $2^{-</td> <td>\sigma</td> <td>}$. Let’s look at an example to see Martin-Löf’s intuition.</td> </tr> </tbody> </table> <p>Consider $B$ to be the class of infinite binary strings such that the every odd bit is $1$. So $101010…, 111111, 1110101… \in B$ and $011111, 010101, 001010 \notin B$. Clearly, the strings in $B$ are not random, they follow some simple rule. Now, how can we use our tree to pin down where exactly these strings live? We will denote set of extensions of some finite string $\sigma$ as $\lbrack!\lbrack \sigma \rbrack!\rbrack$. It is now our goal to “capture” $B$ in a series of progressively more specific sections of the tree. For every $A \in B$, we have that $A \in \lbrack!\lbrack 1 \rbrack!\rbrack$. Only looking at $\lbrack!\lbrack 1 \rbrack!\rbrack$ is too restrictive since that set includes strings like $10000…$ which do not have $1$ at the third bit. In order to ensure that our third bit is $1$, it must be the case that $A \in \lbrack!\lbrack 101 \rbrack!\rbrack$ or $A \in \lbrack!\lbrack 111 \rbrack!\rbrack$.</p> <p>Adopting Martin-Löf’s notation, we define a Martin-Löf test to be a sequence ${ U_n }_{n \in \mathbb{N}}$ of sets such that the measure of $U_n \le 2^{-n}$ and each $U_n$ is the union of such extensions. Taking unions of such extensions means that we are asking a question of the form, “Does there exist an extension of any of these finite strings which gives us our infinite binary string?” This is found using $\mu$-minimization, connecting us to our computable functions above. We can denote the measure of a set by $\mu(\cdot)$. For our example, $U_1 = \lbrack!\lbrack 1 \rbrack!\rbrack$ and $U_2 = \lbrack!\lbrack 101 \rbrack!\rbrack \cup \lbrack!\lbrack 111 \rbrack!\rbrack$. Notice that $\lbrack!\lbrack 1 \rbrack!\rbrack$ is half of our tree, so $\mu(U_1)=\frac{1}{2}=2^{-1}$ and $\lbrack!\lbrack 101 \rbrack!\rbrack \cup \lbrack!\lbrack 111 \rbrack!\rbrack$ is the union of two eighths of our tree, so $\mu(U_2)=\frac{1}{8} + \frac{1}{8} = \frac{1}{4} = 2^{-2}$. Try to see how you would define $U_n$ for each $n$ and verify that the measures behave nicely.</p> <p>We call a class $C$ Martin-Löf null if there is a Martin-Löf test ${ U_n }_{n \in \mathbb{N}}$ such that $C \subseteq \bigcap_n U_n$. So our class $B$ <em>is</em> Martin-Löf null since the construction above gives such a Martin-Löf test. Martin-Löf nullity formally defines some reasonable property of our class in question. Finally, an infinite binary string $A$ is Martin-Löf random if ${A}$ is not Martin-Löf null. Viewing a Martin-Löf test as a query into whether some property holds of a sequence, $A$ is random if $A$ does not satisfy any property that is effectively describable.</p> <p>Crazy enough, there does exist a universal Martin-Löf test. Meaning that this singular test encompasses all other Martin-Löf tests. While we can enumerate the test, it requires infinite questions which means we cannot decide in finite time whether something is random.</p> <h3 id="gambling-randomness">Gambling Randomness</h3> <p>Let’s shift gears. Say you have $$1$ and we sit down to flip a coin many, many times. You bet whatever money you have at each flip. Your final winnings will be based on how you choose to divide your current winnings at any given point between heads and tails. Any way you could possibly choose each of your bets we can model using some sort of a computable process.</p> <p>We formally define a <em>martingale</em> to be a function $d$ from finite binary strings $\sigma$ to nonnegative real numbers that satisfies</p> \[d(\sigma) = \frac{d(\sigma0) + d(\sigma1)}{2}\] <p>That’s right. The CT thesis in action! Effective functions producing the limits of human computation power.</p> <p>This condition is known as the fairness condition and prohibits money from appearing out of nowhere, you can only make what you bet. Turning it to an inequality would yield supermartingales, similar functions with slightly different behavior. Alternatively, we can restrict $d$’s values to be approximable by a computable sequence of rational numbers from below which we call computably enumerable (c.e.) martingales. We say that a betting strategy succeeds on a sequence of coin flips if such a strategy results in infinite winnings. Formally, a martingale $d$ succeeds on an infinite binary sequence $A$ succeeds if</p> \[\limsup_n d(A \upharpoonright n) = \infty\] <p>Finally, $A$ is random if no c.e. martingale succeeds on it. This notion of randomness says that an inherent trait of a random sequence is that no computable procedure can win infinite money betting on it.</p> <h3 id="they-are-all-equivalent">They are all equivalent!</h3> <p>The notion of randomness as represented by incompressibility, measure theoretic tests, and c.e. martingales turn out to agree on everything! That is, each identifies exactly the same infinite binary sequences as random. Another instance, along with the CT thesis, of different formalizations of abstract notions converging to one: what began as very different formalizations of our intuitive idea of “lack of pattern” end up describing precisely the same phenomenon. When independent formalizations of the same intuitive concept consistently single out the same objects, that is evidence that we have stumbled upon something “real”, not just an artifact of the formalism.</p>]]></content><author><name></name></author><category term="Computability"/><category term="Randomness"/><category term="computability"/><category term="randomness"/><category term="lean"/><category term="formal-verification"/><category term="kolmogorov-complexity"/><summary type="html"><![CDATA[An introduction to computability theory, turing degrees, and randomness, supported by a Lean formalization]]></summary></entry><entry><title type="html">Tutorial: A Verified Interpreter with Side Effects</title><link href="https://tannerduve.github.io/blog/2025/freer-monad-part4/" rel="alternate" type="text/html" title="Tutorial: A Verified Interpreter with Side Effects"/><published>2025-06-18T20:00:00+00:00</published><updated>2025-06-18T20:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/freer-monad-part4</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/freer-monad-part4/"><![CDATA[<h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>In this final section we will do a mini tutorial to show the power of the free monad by building an interpreter for an expression language with side effects. The key idea here is that the free monad lets us separate what we want to do (a syntactic description of effectful computation) from how we want to do it (interpreting and executing the effects semantically).</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#LanguageandEffects">Language and Effects</a></li> <li><a href="#Interpreter">Interpreter</a></li> <li><a href="#Verification">Verification</a></li> <li><a href="#Conclusion">Conclusion</a></li> <li><a href="#References">References</a></li> </ol> <h2 id="2-language-and-effects">2. <a name="LanguageandEffects"></a>Language and Effects</h2> <p>We begin by defining a tiny expression language, with integers, variables, addition, and division. We use the <code class="language-plaintext highlighter-rouge">Env</code> type to represent environments, which are just mappings of variables to values:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">Expr</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">val</span> : <span class="n">Int</span> <span class="o">→</span> <span class="n">Expr</span>
  <span class="o">|</span> <span class="n">var</span> : <span class="n">String</span> <span class="o">→</span> <span class="n">Expr</span>
  <span class="o">|</span> <span class="n">add</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span>
  <span class="o">|</span> <span class="n">div</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span> <span class="o">→</span> <span class="n">Expr</span>

<span class="n">abbrev</span> <span class="n">Env</span> := <span class="n">List</span> (<span class="n">String</span> <span class="o">×</span> <span class="n">Int</span>)
</code></pre></div></div> <p>We also define three effect types: mutable state (for the environment), errors (for failed variable lookups or division by zero), and a trace log (for inspection or debugging):</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">StateEff</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">Get</span> : <span class="n">StateEff</span> <span class="n">Env</span>
  <span class="o">|</span> <span class="n">Put</span> : <span class="n">Env</span> <span class="o">→</span> <span class="n">StateEff</span> <span class="n">Unit</span>

<span class="k">inductive</span> <span class="n">ErrorEff</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">Fail</span> : <span class="n">String</span> <span class="o">→</span> <span class="n">ErrorEff</span> <span class="n">Unit</span>

<span class="k">inductive</span> <span class="n">TraceEff</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">where</span>
  <span class="o">|</span> <span class="n">Log</span> : <span class="n">String</span> <span class="o">→</span> <span class="n">TraceEff</span> <span class="n">Unit</span>
</code></pre></div></div> <p>We can then define a sum/coproduct of type constructors as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FSum</span> (<span class="n">F</span> <span class="n">G</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span>) (α : <span class="kt">Type</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">inl</span> : <span class="n">F</span> α <span class="o">→</span> <span class="n">FSum</span> <span class="n">F</span> <span class="n">G</span> α
  <span class="o">|</span> <span class="n">inr</span> : <span class="n">G</span> α <span class="o">→</span> <span class="n">FSum</span> <span class="n">F</span> <span class="n">G</span> α

<span class="k">infixl</span>:<span class="mi">50</span> <span class="s">"⊕"</span> <span class="o">=&gt;</span> <span class="n">FSum</span>
</code></pre></div></div> <p>And we define our overall effect signature as the nested sum:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">Eff</span> := <span class="n">StateEff</span> <span class="err">⊕</span> (<span class="n">ErrorEff</span> <span class="err">⊕</span> <span class="n">TraceEff</span>)
</code></pre></div></div> <p>Notice how free monads are extensible in their effects. Adding a new effect is simply constructing a new datatype and adding it to the Eff definition.</p> <p>This type <code class="language-plaintext highlighter-rouge">Eff</code> is a pure description of the available commands in our language. Not what they do, just what kinds of actions exist. Our computations will now live in the type <code class="language-plaintext highlighter-rouge">FreeM Eff α</code>, which means they are pure syntax trees of abstract effects that eventually return a value of type <code class="language-plaintext highlighter-rouge">α</code>.</p> <p><strong>Lifting Effects into the Syntax Tree</strong></p> <p>To construct nodes in our effect AST, we define some helper functions that wrap each command in the FreeM monad. We first define a general way to lift an effect signature from <code class="language-plaintext highlighter-rouge">F</code> into its free monad <code class="language-plaintext highlighter-rouge">FreeM F</code>. This is the morphism <code class="language-plaintext highlighter-rouge">lift : F -&gt; FreeM F</code> in the universal property diagram:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) : <span class="n">FreeM</span> <span class="n">F</span> <span class="err">ι</span> :=
  <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">pure</span>

<span class="k">def</span> <span class="n">getEnv</span> : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Env</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inl</span> <span class="n">StateEff</span><span class="o">.</span><span class="n">Get</span>)

<span class="k">def</span> <span class="n">putEnv</span> (<span class="n">e</span> : <span class="n">Env</span>) : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Unit</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inl</span> (<span class="n">StateEff</span><span class="o">.</span><span class="n">Put</span> <span class="n">e</span>))

<span class="k">def</span> <span class="n">fail</span> (<span class="n">msg</span> : <span class="n">String</span>) : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Unit</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inr</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inl</span> (<span class="n">ErrorEff</span><span class="o">.</span><span class="n">Fail</span> <span class="n">msg</span>)))

<span class="k">def</span> <span class="n">log</span> (<span class="n">msg</span> : <span class="n">String</span>) : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Unit</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">lift</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inr</span> (<span class="n">FSum</span><span class="o">.</span><span class="n">inr</span> (<span class="n">TraceEff</span><span class="o">.</span><span class="n">Log</span> <span class="n">msg</span>)))
</code></pre></div></div> <p><strong>Writing a Program</strong></p> <p>We can now write a little program. It logs a message, updates the environment, reads back a variable, and returns its increment:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">ex</span> : <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Int</span> := <span class="n">do</span>
  <span class="n">log</span> <span class="s">"Starting"</span>
  <span class="n">putEnv</span> [(<span class="s">"x"</span>, <span class="mi">10</span>)
  <span class="n">let</span> <span class="n">env</span> <span class="err">←</span> <span class="n">getEnv</span>
  <span class="k">match</span> <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">⋅</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="s">"x"</span>) <span class="k">with</span>
  <span class="o">|</span> <span class="n">some</span> (<span class="n">_</span>, <span class="n">x</span>) <span class="o">=&gt;</span> <span class="n">pure</span> (<span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>)
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">do</span> <span class="n">fail</span> <span class="s">"x not found"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span>
</code></pre></div></div> <p>This “program” is constructing a tree of abstract effects independently of any execution or semantics. The calls to <code class="language-plaintext highlighter-rouge">log</code>, <code class="language-plaintext highlighter-rouge">putEnv</code>, <code class="language-plaintext highlighter-rouge">getEnv</code>, and fail are not doing anything yet, they are just nodes in a tree. When programs are represented as data structures you can do much more with them than just their operational interpretation, and you gain immense leverage and control over how you’d like to interpret them.</p> <p>This separation between syntax and semantics is the core idea. We build up a value of type <code class="language-plaintext highlighter-rouge">FreeM Eff Int</code> that describes a program in terms of its desired behavior. This value is like an AST of effects. The tree is built using the constructors pure and bind, and the functorial action of the coproduct <code class="language-plaintext highlighter-rouge">⊕</code> lets us represent multiple kinds of effects simultaneously.</p> <h2 id="3-interpreter">3. <a name="Interpreter"></a>Interpreter</h2> <p>To run a program written in <code class="language-plaintext highlighter-rouge">FreeM Eff α</code>, we must interpret its abstract syntax tree into a concrete computation. This involves defining a <strong>catamorphism</strong> — a recursive fold over the <code class="language-plaintext highlighter-rouge">FreeM</code> structure — into a semantic domain of effectful computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
</code></pre></div></div> <p>Before we can fold the entire syntax tree, we need to define how to interpret each individual effect. This is done via a <em>handler</em>, which is a function that gives meaning to each primitive operation in the effect functor <code class="language-plaintext highlighter-rouge">Eff</code>.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Eff</span> α <span class="o">→</span> <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
</code></pre></div></div> <p>This function interprets each effect label into our semantic domain of exceptions, states, traces:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">Trace</span> := <span class="n">List</span> <span class="n">String</span>

<span class="k">def</span> <span class="n">effInterp</span> : <span class="err">{</span>α : <span class="kt">Type</span><span class="err">}</span> <span class="o">→</span> <span class="n">Eff</span> α <span class="o">→</span> <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> <span class="n">StateEff</span><span class="o">.</span><span class="n">Get</span> <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">env</span> <span class="n">trace</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> (<span class="n">env</span>, <span class="n">env</span>, <span class="n">trace</span>)
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> (<span class="n">StateEff</span><span class="o">.</span><span class="n">Put</span> <span class="n">newEnv</span>) <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">trace</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> ((), <span class="n">newEnv</span>, <span class="n">trace</span>)
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inl</span> (<span class="n">ErrorEff</span><span class="o">.</span><span class="n">Fail</span> <span class="n">msg</span>)) <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inr</span> (<span class="n">TraceEff</span><span class="o">.</span><span class="n">Log</span> <span class="n">msg</span>)) <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">env</span> <span class="n">trace</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> ((), <span class="n">env</span>, <span class="n">trace</span> <span class="o">++</span> [<span class="n">msg</span>])
</code></pre></div></div> <p>This gives us the semantics for a single <code class="language-plaintext highlighter-rouge">Eff</code> node. But interpreting a full program requires recursively folding over the <code class="language-plaintext highlighter-rouge">FreeM</code> tree. Think of <code class="language-plaintext highlighter-rouge">effInterp</code> as the function which we will fold over the tree.</p> <p>We define this fold using our catamorphism:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">cataFreeM</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{</span>α β : <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span>
  (<span class="n">pureCase</span> : α <span class="o">→</span> β)
  (<span class="n">bindCase</span> : <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="o">→</span> <span class="n">F</span> <span class="err">ι</span> <span class="o">→</span> (<span class="err">ι</span> <span class="o">→</span> β) <span class="o">→</span> β)
  : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> β
<span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">pureCase</span> <span class="n">a</span>
<span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="n">bindCase</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">cataFreeM</span> <span class="n">pureCase</span> <span class="n">bindCase</span> (<span class="n">k</span> <span class="n">x</span>))
</code></pre></div></div> <p>This is saying, given a type <code class="language-plaintext highlighter-rouge">β</code> with a <code class="language-plaintext highlighter-rouge">pureCase : α → β</code> and a <code class="language-plaintext highlighter-rouge">bindCase : {ι : Type u} → F ι → (ι → β) → β</code> (making it an algebra over the free monad functor), we define a function <code class="language-plaintext highlighter-rouge">cataFreeM : FreeM F α -&gt; β</code>. This is indeed the catamorphism guaranteed by initiality of <code class="language-plaintext highlighter-rouge">FreeM F α</code>.</p> <p>We define the carrier type of our effect algebra as:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">EffAction</span> (α : <span class="kt">Type</span>) := <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (α <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>)
</code></pre></div></div> <p>Then we define the two parts of the algebra:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">-- Handle pure values</span>
<span class="k">def</span> <span class="n">effPure</span> <span class="err">{</span>α<span class="err">}</span> (<span class="n">a</span> : α) : <span class="n">EffAction</span> α :=
  <span class="k">fun</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">ok</span> (<span class="n">a</span>, <span class="n">env</span>, <span class="n">tr</span>)

<span class="cd">-- Handle effectful operations and sequencing</span>
<span class="k">def</span> <span class="n">effStep</span> <span class="err">{</span>α<span class="err">}</span> :
    <span class="err">{ι</span> : <span class="kt">Type</span><span class="err">}</span> <span class="o">→</span> <span class="n">Eff</span> <span class="err">ι</span> <span class="o">→</span> (<span class="err">ι</span> <span class="o">→</span> <span class="n">EffAction</span> α) <span class="o">→</span> <span class="n">EffAction</span> α
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> <span class="n">StateEff</span><span class="o">.</span><span class="n">Get</span>,        <span class="n">k</span> <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=&gt;</span> <span class="n">k</span> <span class="n">env</span> <span class="n">env</span> <span class="n">tr</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inl</span> (<span class="n">StateEff</span><span class="o">.</span><span class="n">Put</span> <span class="err">σ</span>),    <span class="n">k</span> <span class="o">=&gt;</span> <span class="k">fun</span> <span class="n">_</span>   <span class="n">tr</span> <span class="o">=&gt;</span> <span class="n">k</span> () <span class="err">σ</span> <span class="n">tr</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inl</span> (<span class="n">ErrorEff</span><span class="o">.</span><span class="n">Fail</span> <span class="n">msg</span>)), <span class="n">_</span> <span class="o">=&gt;</span>
        <span class="k">fun</span> <span class="n">_</span> <span class="n">_</span>  <span class="o">=&gt;</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="o">.</span><span class="n">inr</span> (<span class="o">.</span><span class="n">inr</span> (<span class="n">TraceEff</span><span class="o">.</span><span class="n">Log</span> <span class="n">msg</span>)), <span class="n">k</span> <span class="o">=&gt;</span>
        <span class="k">fun</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=&gt;</span> <span class="n">k</span> () <span class="n">env</span> (<span class="n">tr</span> <span class="o">++</span> [<span class="n">msg</span>])
</code></pre></div></div> <p>Finally, we combine the two cases into a full interpreter via our catamorphism <code class="language-plaintext highlighter-rouge">cataFreeM</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">run</span> <span class="err">{</span>α<span class="err">}</span> : <span class="n">FreeM</span> <span class="n">Eff</span> α <span class="o">→</span> <span class="n">EffAction</span> α :=
  <span class="n">cataFreeM</span> <span class="n">effPure</span> <span class="n">effStep</span>
</code></pre></div></div> <p>This catamorphism <code class="language-plaintext highlighter-rouge">run</code> is the unique morphism from <code class="language-plaintext highlighter-rouge">FreeM Eff α</code> to our effect algebra <code class="language-plaintext highlighter-rouge">EffAction α</code> which interprets computation trees of type <code class="language-plaintext highlighter-rouge">FreeM Eff α</code> by evaluating them and executing their effects concretely.</p> <h3 id="4-verification">4. <a name="Verification"></a>Verification</h3> <p>Now that we have an interpreter, we can verify its correctness. What does correctness mean here?</p> <p>In order to check that our interpreter is correct, we need some kind of semantics for our language, i.e., an assignment of meaning to our programs. In programming language theory, this is given as a formal relation that specifies when evaluation succeeds and what result it produces.</p> <p>We’ll define a <em>big-step operational semantics</em> as an inductive relation, and then prove that the interpreter agrees with the semantics.</p> <p><strong>Semantics</strong></p> <p>We define a relation <code class="language-plaintext highlighter-rouge">EvalRel e env trace res</code> that says: under environment <code class="language-plaintext highlighter-rouge">env</code> and trace <code class="language-plaintext highlighter-rouge">trace</code>, expression <code class="language-plaintext highlighter-rouge">e</code> evaluates to result <code class="language-plaintext highlighter-rouge">res</code>. This result is either an error or a triple of the resulting value, environment, and trace. We also define a function <code class="language-plaintext highlighter-rouge">eval</code> which maps an expression to the effectful AST. Our correctness claim will then be that if <code class="language-plaintext highlighter-rouge">EvalRel e env trace res</code> holds (i.e., <code class="language-plaintext highlighter-rouge">e</code> evaluates to <code class="language-plaintext highlighter-rouge">res</code>), then our interpreter also returns <code class="language-plaintext highlighter-rouge">res</code> when run on the output of <code class="language-plaintext highlighter-rouge">eval e</code>.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">EvalRel</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">Env</span> <span class="o">→</span> <span class="n">Trace</span> <span class="o">→</span> <span class="n">Except</span> <span class="n">String</span> (<span class="n">Int</span> <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>) <span class="o">→</span> <span class="kt">Prop</span> <span class="n">where</span>
<span class="o">|</span> <span class="n">val</span> :
    <span class="o">∀</span> <span class="n">n</span> <span class="n">env</span> <span class="n">trace</span>,
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">val</span> <span class="n">n</span>) <span class="n">env</span> <span class="n">trace</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">n</span>, <span class="n">env</span>, <span class="n">trace</span>))
<span class="o">|</span> <span class="n">var_found</span> :
    <span class="o">∀</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">v</span>,
    <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">·</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">x</span>) <span class="o">=</span> <span class="n">some</span> (<span class="n">x</span>, <span class="n">v</span>) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">var</span> <span class="n">x</span>) <span class="n">env</span> <span class="n">trace</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v</span>, <span class="n">env</span>, <span class="n">trace</span>))
<span class="o">|</span> <span class="n">var_missing</span> :
    <span class="o">∀</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span>,
    <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">·</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">x</span>) <span class="o">=</span> <span class="n">none</span> <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">var</span> <span class="n">x</span>) <span class="n">env</span> <span class="n">trace</span> (<span class="o">.</span><span class="n">error</span> <span class="n">s</span><span class="o">!</span><span class="s">"unbound variable {x}"</span>)
<span class="o">|</span> <span class="n">add</span> :
    <span class="o">∀</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span>,
    <span class="n">EvalRel</span> <span class="n">e1</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span>, <span class="n">env</span><span class="err">₂</span>, <span class="n">trace</span><span class="err">₂</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₂</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span>) <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>))
<span class="o">|</span> <span class="n">div_ok</span> :
    <span class="o">∀</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span>,
    <span class="n">v2</span> <span class="o">≠</span> <span class="mi">0</span> <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e1</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span>, <span class="n">env</span><span class="err">₂</span>, <span class="n">trace</span><span class="err">₂</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₂</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">div</span> <span class="n">e1</span> <span class="n">e2</span>) <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>))
<span class="o">|</span> <span class="n">div_zero</span> :
    <span class="o">∀</span> <span class="n">e1</span> <span class="n">e2</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span>,
    <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e1</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v1</span>, <span class="n">env</span><span class="err">₂</span>, <span class="n">trace</span><span class="err">₂</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> <span class="n">e2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₂</span> (<span class="o">.</span><span class="n">ok</span> (<span class="n">v2</span>, <span class="n">env</span><span class="err">₃</span>, <span class="n">trace</span><span class="err">₃</span>)) <span class="o">→</span>
    <span class="n">EvalRel</span> (<span class="o">.</span><span class="n">div</span> <span class="n">e1</span> <span class="n">e2</span>) <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> (<span class="o">.</span><span class="n">error</span> <span class="s">"divide by zero"</span>)
</code></pre></div></div> <p>The function <code class="language-plaintext highlighter-rouge">eval : Expr → FreeM Eff Int</code> constructs a tree of effects representing what should happen during evaluation from an expression. This is the object our interpreter consumes.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">eval</span> : <span class="n">Expr</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">Eff</span> <span class="n">Int</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">val</span> <span class="n">n</span> <span class="o">=&gt;</span> <span class="n">pure</span> <span class="n">n</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">var</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">do</span>
      <span class="n">let</span> <span class="n">env</span> <span class="err">←</span> <span class="n">getEnv</span>
      <span class="k">match</span> <span class="n">env</span><span class="o">.</span><span class="n">find</span><span class="err">?</span> (<span class="err">·</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">x</span>) <span class="k">with</span>
      <span class="o">|</span> <span class="n">some</span> (<span class="n">_</span>, <span class="n">v</span>) <span class="o">=&gt;</span> <span class="n">pure</span> <span class="n">v</span>
      <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">do</span>
          <span class="n">fail</span> <span class="n">s</span><span class="o">!</span><span class="s">"unbound variable {x}"</span>
          <span class="n">pure</span> <span class="mi">0</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">add</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=&gt;</span> <span class="n">do</span>
      <span class="n">let</span> <span class="n">v1</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e1</span>
      <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e2</span>
      <span class="n">pure</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>)
  <span class="o">|</span> <span class="o">.</span><span class="n">div</span> <span class="n">e1</span> <span class="n">e2</span> <span class="o">=&gt;</span> <span class="n">do</span>
      <span class="n">let</span> <span class="n">v1</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e1</span>
      <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e2</span>
      <span class="n">if</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span>
        <span class="n">fail</span> <span class="s">"divide by zero"</span>
        <span class="n">pure</span> <span class="mi">0</span>
      <span class="n">else</span>
        <span class="n">pure</span> (<span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>)
</code></pre></div></div> <p><strong>What do we want to prove?</strong></p> <p>We want to prove that <code class="language-plaintext highlighter-rouge">eval</code> followed by <code class="language-plaintext highlighter-rouge">run</code> gives the same result as the semantics. That is:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">eval_correct</span> (<span class="n">e</span> : <span class="n">Expr</span>) (<span class="n">env</span> : <span class="n">Env</span>) (<span class="n">trace</span> : <span class="n">Trace</span>)
    (<span class="n">res</span> : <span class="n">Except</span> <span class="n">String</span> (<span class="n">Int</span> <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>))
    (<span class="n">h</span> : <span class="n">EvalRel</span> <span class="n">e</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">res</span>) :
    <span class="n">run</span> (<span class="n">eval</span> <span class="n">e</span>) <span class="n">env</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">res</span>
</code></pre></div></div> <p><strong>Proof</strong></p> <p>We proceed by induction on the derivation of <code class="language-plaintext highlighter-rouge">EvalRel e env trace res</code>. In each case, we:</p> <ul> <li>Unfold the definition of <code class="language-plaintext highlighter-rouge">eval</code> for the given expression</li> <li>Use helper lemmas to simplify <code class="language-plaintext highlighter-rouge">run (p &gt;&gt;= k)</code></li> <li>Match the result with the expected output</li> </ul> <p>These two helper lemmas simplify <code class="language-plaintext highlighter-rouge">run (p &gt;&gt;= k)</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">run_bind_ok</span> <span class="err">{</span>α β<span class="err">}</span>
    <span class="err">{</span><span class="n">p</span> : <span class="n">FreeM</span> <span class="n">Eff</span> α<span class="err">}</span> <span class="err">{</span><span class="n">k</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">Eff</span> β<span class="err">}</span>
    <span class="err">{</span><span class="n">env</span> <span class="n">env</span><span class="err">'</span> : <span class="n">Env</span><span class="err">}</span> <span class="err">{</span><span class="n">tr</span> <span class="n">tr</span><span class="err">'</span> : <span class="n">Trace</span><span class="err">}</span> <span class="err">{</span><span class="n">v</span> : α<span class="err">}</span> (<span class="n">h</span> : <span class="n">runEff</span> <span class="n">p</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="o">.</span><span class="n">ok</span> (<span class="n">v</span>, <span class="n">env</span><span class="err">'</span>, <span class="n">tr</span><span class="err">'</span>)) :
    <span class="n">runEff</span> (<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>) <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="n">runEff</span> (<span class="n">k</span> <span class="n">v</span>) <span class="n">env</span><span class="err">'</span> <span class="n">tr</span><span class="err">'</span> := <span class="k">by</span> <span class="o">...</span>
</code></pre></div></div> <p>The above says if <code class="language-plaintext highlighter-rouge">p</code> succeeds with <code class="language-plaintext highlighter-rouge">v</code>, then <code class="language-plaintext highlighter-rouge">p &gt;&gt;= k</code> runs <code class="language-plaintext highlighter-rouge">k v</code> next.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">run_bind_err</span> <span class="err">{</span>α β<span class="err">}</span>
    <span class="err">{</span><span class="n">p</span> : <span class="n">FreeM</span> <span class="n">Eff</span> α<span class="err">}</span> <span class="err">{</span><span class="n">k</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">Eff</span> β<span class="err">}</span>
    <span class="err">{</span><span class="n">env</span> : <span class="n">Env</span><span class="err">}</span> <span class="err">{</span><span class="n">tr</span> : <span class="n">Trace</span><span class="err">}</span> <span class="err">{</span><span class="n">msg</span> : <span class="n">String</span><span class="err">}</span> :
  <span class="n">runEff</span> <span class="n">p</span> <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span> <span class="o">→</span>
  <span class="n">runEff</span> (<span class="n">p</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>) <span class="n">env</span> <span class="n">tr</span> <span class="o">=</span> <span class="o">.</span><span class="n">error</span> <span class="n">msg</span> <span class="o">...</span>
</code></pre></div></div> <p>This one says if <code class="language-plaintext highlighter-rouge">p</code> errors, then <code class="language-plaintext highlighter-rouge">p &gt;&gt;= k</code> errors with the same message.</p> <p>Now we can prove the theorem.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">eval_correct</span> (<span class="n">e</span> : <span class="n">Expr</span>) (<span class="n">env</span> : <span class="n">Env</span>) (<span class="n">trace</span> : <span class="n">Trace</span>)
    (<span class="n">res</span> : <span class="n">Except</span> <span class="n">String</span> (<span class="n">Int</span> <span class="o">×</span> <span class="n">Env</span> <span class="o">×</span> <span class="n">Trace</span>))
    (<span class="n">h</span> : <span class="n">EvalRel</span> <span class="n">e</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">res</span>) :
    <span class="n">runEff</span> (<span class="n">eval</span> <span class="n">e</span>) <span class="n">env</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">res</span> := <span class="k">by</span>
    <span class="n">induction</span><span class="err">'</span> <span class="n">h</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">val</span> <span class="n">z</span> <span class="n">env</span> <span class="n">trace</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">pure_eq_purePure</span>, <span class="n">runEff</span>, <span class="n">cataFreeM</span>, <span class="n">effPure</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">var_found</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">v</span> <span class="n">h</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">runEff</span>, <span class="n">eval</span>, <span class="n">getEnv</span>, <span class="n">bind_pure_comp</span>, <span class="n">lift_def</span>, <span class="n">cataFreeM</span>, <span class="n">effStep</span>, <span class="n">h</span>, <span class="n">effPure</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">var_missing</span> <span class="n">x</span> <span class="n">env</span> <span class="n">trace</span> <span class="n">h</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">runEff</span>, <span class="n">eval</span>, <span class="n">bind</span>, <span class="n">getEnv</span>, <span class="n">fail</span>, <span class="n">lift_def</span>, <span class="n">cataFreeM</span>, <span class="n">effStep</span>, <span class="n">h</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">add</span> <span class="n">e</span><span class="err">₁</span> <span class="n">e</span><span class="err">₂</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v1</span> <span class="n">v2</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span> <span class="n">h</span><span class="err">₁</span> <span class="n">h</span><span class="err">₂</span> <span class="n">ih</span><span class="err">₁</span> <span class="n">ih</span><span class="err">₂</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">bind</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₁</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₁</span> ) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v1</span> <span class="o">=&gt;</span> <span class="n">do</span>
        <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>
        <span class="n">pure</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>)) <span class="n">ih</span><span class="err">₁</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₁</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₁</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₂</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v2</span> <span class="o">=&gt;</span> <span class="n">pure</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span>)) <span class="n">ih</span><span class="err">₂</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₂</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₂</span>]<span class="o">;</span> <span class="n">congr</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">div_ok</span> <span class="n">e</span><span class="err">₁</span> <span class="n">e</span><span class="err">₂</span> <span class="n">env</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v</span><span class="err">₁</span> <span class="n">v</span><span class="err">₂</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span> <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span> <span class="n">h</span><span class="err">₁</span> <span class="n">h</span><span class="err">₂</span> <span class="n">ih</span><span class="err">₁</span> <span class="n">ih</span><span class="err">₂</span>  <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">bind</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₁</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₁</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v1</span> <span class="o">=&gt;</span> <span class="n">do</span>
        <span class="n">let</span> <span class="n">v2</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>
        <span class="n">if</span> <span class="n">v2</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> <span class="n">do</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span> <span class="n">else</span> <span class="n">pure</span> (<span class="n">v1</span> <span class="o">/</span> <span class="n">v2</span>)) <span class="n">ih</span><span class="err">₁</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₁</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₁</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₂</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=&gt;</span>
        <span class="n">if</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> <span class="n">do</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span> <span class="n">else</span> <span class="n">pure</span> (<span class="n">v</span><span class="err">₁</span> <span class="o">/</span> <span class="n">v</span><span class="err">₂</span>)) <span class="n">ih</span><span class="err">₂</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₂</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₂</span>, <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span>
      <span class="n">congr</span>
    <span class="err">·</span> <span class="n">case</span> <span class="n">div_zero</span> <span class="n">e</span><span class="err">₁</span> <span class="n">e</span><span class="err">₂</span> <span class="n">env</span><span class="err">'</span> <span class="n">trace</span><span class="err">₁</span> <span class="n">trace</span><span class="err">₂</span> <span class="n">trace</span><span class="err">₃</span> <span class="n">v</span><span class="err">₁</span> <span class="n">v</span><span class="err">₂</span> <span class="n">env</span><span class="err">₂</span> <span class="n">env</span><span class="err">₃</span> <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span> <span class="n">h</span><span class="err">₁</span> <span class="n">h</span><span class="err">₂</span> <span class="n">ih</span><span class="err">₁</span> <span class="n">ih</span><span class="err">₂</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> [<span class="n">eval</span>, <span class="n">bind</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₁</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₁</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v</span><span class="err">₁</span> <span class="o">=&gt;</span> <span class="n">do</span> <span class="n">let</span> <span class="n">v</span><span class="err">₂</span> <span class="err">←</span> <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span><span class="o">;</span> <span class="n">if</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span> <span class="n">else</span> <span class="n">pure</span> (<span class="n">v</span><span class="err">₁</span> <span class="o">/</span> <span class="n">v</span><span class="err">₂</span>)) <span class="n">ih</span><span class="err">₁</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₁</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₁</span>
      <span class="k">have</span> <span class="n">step</span><span class="err">₂</span> := <span class="n">runEff_bind_ok</span> (<span class="n">p</span> := <span class="n">eval</span> <span class="n">e</span><span class="err">₂</span>) (<span class="n">k</span> := <span class="k">fun</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=&gt;</span> <span class="n">if</span> <span class="n">v</span><span class="err">₂</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">then</span> (<span class="n">do</span> <span class="n">fail</span> <span class="s">"divide by zero"</span><span class="o">;</span> <span class="n">pure</span> <span class="mi">0</span>) <span class="n">else</span> <span class="n">pure</span> (<span class="n">v</span><span class="err">₁</span> <span class="o">/</span> <span class="n">v</span><span class="err">₂</span>)) <span class="n">ih</span><span class="err">₂</span>
      <span class="n">simp</span> [<span class="n">bind</span>] <span class="n">at</span> <span class="n">step</span><span class="err">₂</span><span class="o">;</span> <span class="n">simp</span> [<span class="n">step</span><span class="err">₂</span>, <span class="n">v</span><span class="err">₂</span><span class="n">_ne_0</span>
      <span class="n">simp</span> [<span class="n">pure</span>, <span class="n">fail</span>, <span class="n">lift</span>, <span class="n">runEff</span>
      <span class="n">congr</span>
</code></pre></div></div> <p>Now we have formally verified our interpreter agrees with our language semantics.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>Hopefully this article was informative and helpful in understanding free monads mathematically and gave you a glimpse of their usefulness in programming. This is the first blog post I’ve written so I’m hoping it was enjoyable. To review what we did:</p> <ul> <li> <p>We introduced the concept of free objects in mathematics, starting with vector spaces, monoids, and groups.</p> </li> <li> <p>We defined the free monad categorically as the initial algebra of a particular functor, drawing analogy to the List type.</p> </li> <li> <p>In Haskell, we implemented the standard <code class="language-plaintext highlighter-rouge">FreeM f a</code> type and gave it a Monad instance.</p> </li> <li> <p>We learned about strict positivity in dependently typed proof assistants and why the classic <code class="language-plaintext highlighter-rouge">Free</code> monad fails in Lean</p> </li> <li> <p>We introduced the Freer monad as a strictly positive solution, and showed it forms a monad for any <code class="language-plaintext highlighter-rouge">F : Type -&gt; Type</code></p> </li> <li> <p>We talked about initial algebras and how catamorphisms are canonical interpreters for effect functors, and how universal morphisms interpret free monadic computations into other monads.</p> </li> <li> <p>We defined a small expression language with three effects: state, errors, and tracing, showed how effects can be represented as data structures using the FreeM monad, and wrote an interpreter for it as a catamorphism</p> </li> <li> <p>We showed how this separation between syntax and semantics enables flexibility in evaluating and interpreting effectful languages.</p> </li> <li> <p>We showed how to define an operational semantics and prove that the interpreter agrees with it.</p> </li> </ul> <p>All this code can be found <a href="https://github.com/tannerduve/lean-playground/blob/main/LeanPlayground/freemonad.lean">here</a></p> <h2 id="6-references">6. <a name="References"></a>References</h2> <ul> <li> <p><a href="https://ncatlab.org/nlab/show/free+monad">nLab: Free Monad</a></p> </li> <li> <p><a href="https://www.seas.upenn.edu/~cis5520/22fa/lectures/stub/11-transformers/Freer.html">CIS 5520 Lecture Notes on Freer Monads</a></p> </li> <li> <p><em>The Dao of Functional Programming</em>, Bartosz Milewski (2025)</p> </li> <li> <p><a href="https://serokell.io/blog/introduction-to-free-monads">Serokell: Introduction to Free Monads</a></p> </li> <li> <p><a href="https://okmij.org/ftp/Computation/free-monad.html">Okmij : FreeM and Freer Monads: Putting Monads Back into Closet</a></p> </li> </ul>]]></content><author><name></name></author><category term="Formal"/><category term="Verification,"/><category term="Type"/><category term="Theory"/><category term="lean,"/><category term="formal-verification,"/><category term="free-monads,"/><category term="type-theory,"/><category term="tutorial"/><summary type="html"><![CDATA[Part of the free monads series]]></summary></entry><entry><title type="html">Part 3: Universal Morphisms and Effect Handlers</title><link href="https://tannerduve.github.io/blog/2025/freer-monad-part3/" rel="alternate" type="text/html" title="Part 3: Universal Morphisms and Effect Handlers"/><published>2025-06-16T19:00:00+00:00</published><updated>2025-06-16T19:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/freer-monad-part3</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/freer-monad-part3/"><![CDATA[<h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>As we recall from <a href="/blog/2025/freer-monad-part1/">part 1</a>, free objects are defined by left adjoints to forgetful functors, and can also be defined by a particular universal property. Universal properties are given by <em>universal arrows</em>: unique morphisms that characterize an object up to isomorphism. In <a href="/blog/2025/freer-monad-part2/">part 2</a>, we talked about one particular universal property, and this part will focus on another.</p> <p>In this section we will apply the general universal property of the free object to our special case of monads. The free monad over a type constructor <code class="language-plaintext highlighter-rouge">F</code> is the monad that arises from freely generating effects described by <code class="language-plaintext highlighter-rouge">F</code>, with just enough structure to satisfy the monad laws and nothing else.</p> <p>This point of view leads naturally to the concept of an effect handler, which is a function that interprets operations from <code class="language-plaintext highlighter-rouge">F</code> into a monad <code class="language-plaintext highlighter-rouge">M</code>. The universal property of the free monad ensures that any such handler extends uniquely to a monad morphism from the free monad into <code class="language-plaintext highlighter-rouge">M</code>. This morphism, in turn, acts as an interpreter for the entire computation.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#FreeMonadAsFreeObject">Free Monads as Free Objects</a></li> <li><a href="#UnivMorphism">The Universal Morphism</a></li> <li><a href="#Example">An Example</a></li> <li><a href="#Conclusion">Conclusion</a> </li> </ol> <h2 id="2-free-monads-as-free-objects">2. <a name="FreeMonadAsFreeObject"></a>Free Monads as Free Objects</h2> <p>The universal property of free objects, as we saw in part 1, says the free object on some “basis” data $X$ is a structured object $X’$ which includes $X$, such that any map from $X$ into another structured object $G$ uniquely extends to a morphism from $X’$ to $G$. Diagrammatically:</p> <script type="text/tikz">
  \begin{tikzcd}[column sep=huge, row sep=huge, labels={font=\normalsize}]
    {X'} \arrow[rr, dashed, "{\hat{h}}"] && G \\
    \\
    X \arrow[uu, "\iota"', pos=0.35] \arrow[uurr, "h"', pos=0.55]
  \end{tikzcd}
</script> <p>In the category of vector spaces for example, this intuitively says that if you have a function from a set $B$ to a vector space $W$, then this function can be extended uniquely (as a linear transformation) to the entire vector space $V_B$ with basis $B$. As we know from linear algebra, any linear transformation is uniquely defined by how it acts on a basis. This is the universal property in action.</p> <p>Now what does this mean for monads? We know that our free monad generates a monad from a type constructor <code class="language-plaintext highlighter-rouge">F : Type -&gt; Type</code>, so our “basis” data on which we freely generate our structured object (in this case, a monad) is <code class="language-plaintext highlighter-rouge">F</code> itself. Plugging things into the diagram, we get that for any type constructor <code class="language-plaintext highlighter-rouge">F</code> and a monad <code class="language-plaintext highlighter-rouge">M</code> with a map <code class="language-plaintext highlighter-rouge">h {a : Type} : F a -&gt; M a</code>, <code class="language-plaintext highlighter-rouge">h</code> extends uniquely to a monad morphism <code class="language-plaintext highlighter-rouge">h' {a : Type} : FreeM F a -&gt; M a</code>.</p> <p>Intuitively, you can think of the morphism <code class="language-plaintext highlighter-rouge">h</code> as an <em>effect handler</em> - it interprets each primitive operation described by <code class="language-plaintext highlighter-rouge">F</code> as a monadic computation in <code class="language-plaintext highlighter-rouge">M</code>. The universal property ensures that this effect handler uniquely lifts to a interpretation of entire programs written in the free monad, ie. computations of type <code class="language-plaintext highlighter-rouge">FreeM F</code>. That is, any computation of type <code class="language-plaintext highlighter-rouge">Free M a</code>, can be interpreted as a computation in <code class="language-plaintext highlighter-rouge">M</code> via a morphism <code class="language-plaintext highlighter-rouge">h' a : Free M a -&gt; M a</code>. <code class="language-plaintext highlighter-rouge">h'</code> being a morphism, means it respects both <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">bind</code> of the monads, ie:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">h</span><span class="err">'</span> (<span class="n">pure</span> <span class="n">a</span>) <span class="o">=</span> <span class="n">pure</span> <span class="n">a</span>
<span class="n">h</span><span class="err">'</span> (<span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="n">k</span>) <span class="o">=</span> <span class="n">h</span><span class="err">'</span> <span class="n">m</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">h</span><span class="err">'</span> (<span class="n">k</span> <span class="n">x</span>)
</code></pre></div></div> <h2 id="3-the-universal-morphism">3. <a name="UnivMorphism"></a>The Universal Morphism</h2> <p>Let’s formalize the universal property precisely. Recall, our <code class="language-plaintext highlighter-rouge">FreeM F</code> monad was defined inductively as a tree of computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FreeM</span> (<span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span>) (α : <span class="kt">Type</span> <span class="n">w</span>)
  <span class="o">|</span> <span class="n">pure</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α
  <span class="o">|</span> <span class="n">liftBind</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) (<span class="n">cont</span> : <span class="err">ι</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α) : <span class="n">FreeM</span> <span class="n">F</span> α
</code></pre></div></div> <p>The universal property, more precisely, is as follows:</p> <blockquote> <p>Given any monad <code class="language-plaintext highlighter-rouge">M</code> and any function (an effect handler)</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span> : <span class="o">∀</span> α, <span class="n">F</span> α <span class="o">→</span> <span class="n">M</span> α
</code></pre></div> </div> <p>there exists a unique monad morphism</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="err">'</span> : <span class="o">∀</span> α, <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> <span class="n">M</span> α
</code></pre></div> </div> <p>such that</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="err">'</span> (<span class="n">lift</span> <span class="n">op</span>) <span class="o">=</span> <span class="n">f</span> <span class="n">op</span>
</code></pre></div> </div> </blockquote> <p>Here, <code class="language-plaintext highlighter-rouge">lift</code> is the inclusion map from our type constructor into the free monad. It lifts a primitive operation into its free monad structure.</p> <p>Explicitly, we define this inclusion as:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">lift</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) : <span class="n">FreeM</span> <span class="n">F</span> <span class="err">ι</span> :=
  <span class="n">FreeM</span><span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">pure</span>
</code></pre></div></div> <p>The map <code class="language-plaintext highlighter-rouge">lift</code> takes a single operation from our basis <code class="language-plaintext highlighter-rouge">F</code> and wraps it as an effectful node inside <code class="language-plaintext highlighter-rouge">FreeM</code>.</p> <p>The universal property then guarantees that for any monad <code class="language-plaintext highlighter-rouge">M</code> and any interpretation <code class="language-plaintext highlighter-rouge">f</code> from our effects to <code class="language-plaintext highlighter-rouge">M</code>, we can define our unique interpreter <code class="language-plaintext highlighter-rouge">liftM f</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">liftM</span> <span class="err">{</span><span class="n">M</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span> [<span class="n">Monad</span> <span class="n">M</span>
    <span class="err">{</span>α : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> (<span class="err">{</span>β : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="o">→</span> <span class="n">F</span> β <span class="o">→</span> <span class="n">M</span> β) <span class="o">→</span> <span class="n">M</span> α
  <span class="o">|</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">pure</span> <span class="n">a</span>, <span class="n">_</span> <span class="o">=&gt;</span> <span class="n">pure</span> <span class="n">a</span>
  <span class="o">|</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span>, <span class="n">interp</span> <span class="o">=&gt;</span> <span class="n">interp</span> <span class="n">op</span> <span class="o">&gt;&gt;=</span> <span class="k">fun</span> <span class="n">result</span> <span class="o">=&gt;</span> <span class="n">liftM</span> (<span class="n">cont</span> <span class="n">result</span>) <span class="n">interp</span>
</code></pre></div></div> <p>This interpreter <code class="language-plaintext highlighter-rouge">liftM</code> traverses our computation tree. It interprets each effectful node using <code class="language-plaintext highlighter-rouge">interp</code> and recursively interprets the remaining computation.</p> <p>The commutativity condition of the universal property explicitly states:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">liftM</span> <span class="n">f</span> (<span class="n">lift</span> <span class="n">op</span>) <span class="o">=</span> <span class="n">f</span> <span class="n">op</span>
</code></pre></div></div> <p>In other words, interpreting an operation wrapped by <code class="language-plaintext highlighter-rouge">lift</code> using <code class="language-plaintext highlighter-rouge">liftM</code> is exactly the same as applying the effect handler <code class="language-plaintext highlighter-rouge">f</code> directly.</p> <h2 id="4-an-example">4. <a name="Example"></a>An Example</h2> <p>Let’s illustrate this concretely with an example. Suppose we have a simple effect type describing state operations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">StateF</span> (<span class="err">σ</span> : <span class="kt">Type</span> <span class="n">u</span>) : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">u</span>
  <span class="o">|</span> <span class="n">get</span> : <span class="n">StateF</span> <span class="err">σ</span> <span class="err">σ</span>
  <span class="o">|</span> <span class="n">set</span> : <span class="err">σ</span> <span class="o">→</span> <span class="n">StateF</span> <span class="err">σ</span> <span class="n">PUnit</span>
</code></pre></div></div> <p>Using <code class="language-plaintext highlighter-rouge">lift</code>, we embed these operations into <code class="language-plaintext highlighter-rouge">FreeState σ α := FreeM (StateF σ) α</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">get</span> <span class="err">{σ</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> : <span class="n">FreeState</span> <span class="err">σ</span> <span class="err">σ</span> := <span class="n">lift</span> <span class="n">StateF</span><span class="o">.</span><span class="n">get</span>

<span class="k">def</span> <span class="n">set</span> <span class="err">{σ</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">s</span> : <span class="err">σ</span>) : <span class="n">FreeState</span> <span class="err">σ</span> <span class="n">PUnit</span> := <span class="n">lift</span> (<span class="n">StateF</span><span class="o">.</span><span class="n">set</span> <span class="n">s</span>)
</code></pre></div></div> <p>Now suppose we want to interpret our <code class="language-plaintext highlighter-rouge">FreeState</code> computations into the standard state monad <code class="language-plaintext highlighter-rouge">StateM</code>. Our effect handler is straightforward:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">stateInterp</span> <span class="err">{σ</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> : <span class="o">∀</span> <span class="err">{</span>α<span class="err">}</span>, <span class="n">StateF</span> <span class="err">σ</span> α <span class="o">→</span> <span class="n">StateM</span> <span class="err">σ</span> α
  <span class="o">|</span> <span class="n">_</span>, <span class="n">StateF</span><span class="o">.</span><span class="n">get</span> <span class="o">=&gt;</span> <span class="n">StateM</span><span class="o">.</span><span class="n">get</span>
  <span class="o">|</span> <span class="n">_</span>, <span class="n">StateF</span><span class="o">.</span><span class="n">set</span> <span class="n">s</span> <span class="o">=&gt;</span> <span class="n">StateM</span><span class="o">.</span><span class="n">set</span> <span class="n">s</span>
</code></pre></div></div> <p>By the universal property, we uniquely lift this handler to interpret entire computations:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">toStateM</span> <span class="err">{σ</span> α : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">comp</span> : <span class="n">FreeState</span> <span class="err">σ</span> α) : <span class="n">StateM</span> <span class="err">σ</span> α :=
  <span class="n">liftM</span> <span class="n">stateInterp</span> <span class="n">comp</span>
</code></pre></div></div> <p>This interpreter maps our <code class="language-plaintext highlighter-rouge">FreeState</code> computations into the built-in <code class="language-plaintext highlighter-rouge">StateM</code> monad.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>The universal property of free monads provides a canonical interpreter with nice mathematical guarantees, ensuring that any choice of an effect handler uniquely determines how entire computations get interpreted. In this post we explored this universal property and showed an example in interpreting free computations into the state monad.</p> <p>In practice, this means defining computations using <code class="language-plaintext highlighter-rouge">FreeM</code> is extremely flexible, as changing how we interpret effects is simply a matter of providing different handlers. The next and final section will be a tutorial on using the free monad to design a small DSL with mutable state, logging, and exceptions, and building a verified interpreter for the language.</p> <h2 id="continue-to-part-4---a-tutorial"><strong>Continue to Part 4 - A Tutorial</strong></h2> <p><a href="/blog/2025/freer-monad-part4/">Continue to Part 4 - A Tutorial</a></p>]]></content><author><name></name></author><category term="Formal"/><category term="Verification,"/><category term="Free"/><category term="Monads"/><category term="lean,"/><category term="free-monads,"/><category term="universal-properties,"/><category term="effect-handlers"/><summary type="html"><![CDATA[Part of the free monads series]]></summary></entry><entry><title type="html">Part 2: Initial Algebras, Catamorphisms, and Interpreters</title><link href="https://tannerduve.github.io/blog/2025/freer-monad-part2/" rel="alternate" type="text/html" title="Part 2: Initial Algebras, Catamorphisms, and Interpreters"/><published>2025-06-16T18:00:00+00:00</published><updated>2025-06-16T18:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/freer-monad-part2</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/freer-monad-part2/"><![CDATA[<p>In the <a href="/blog/2025/freer-monad-part1/">last section</a>, we introduced the free monad and implemented it in Lean. In this section we will study the theory a bit more deeply, by understanding the notions of algebra and universality.</p> <h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <blockquote> <p>The essence of algebra is the formal manipulation of expressions. But what are expressions, and how do we manipulate them? The first things to observe about algebraic expressions like $2(x + y)$ or $ax^2 + bx + c$ is that there are infinitely many of them. There is a finite number of rules for making them, but these rules can be used in infinitely many combinations. This suggests that the rules are used <em>recursively</em>.</p> <ul> <li>Bartosz Milewski, The Dao of Functional Programming</li> </ul> </blockquote> <p>In this part, we will examine this connection between algebra and recursion a bit, from the perspective of category theory.</p> <p>In particular, we will explore a universal construction called an initial algebra. An initial algebra gives rise to a unique morphism that, as programmers, we can think of as an “interpreter” in a certain sense. These morphisms are often called <strong>catamorphisms</strong> in programming, and are an instance of a broader concept called a <strong>recursion scheme</strong>.</p> <p>We will then see how free monads are initial algebras giving us catamorphisms into other algebras, and how catamorphisms are essentially ways of collapsing structure, providing a way to interpret recursive data.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#InitialAlgebras">Initial Algebras and Inductive Types</a> <ul> <li><a href="#Algebras">Algebras and their Morphisms</a></li> <li><a href="#InductiveTypes">Lists as Initial Algebras</a></li> </ul> </li> <li><a href="#FreeMonads">Free Monads as Initial Algebras</a></li> <li><a href="#Cata">Catamorphisms as Interpreters</a></li> <li><a href="Conclusion">Conclusion</a></li> <li><a href="Exercise">Exercise</a></li> </ol> <h2 id="2-initial-algebras-and-inductive-types">2. <a name="InitialAlgebras"></a>Initial Algebras and Inductive Types</h2> <p>We begin this section with some definitions.</p> <h2 id="21-algebras-and-their-morphisms">2.1. <a name="Algebras"></a>Algebras and their Morphisms</h2> <p>Let $F : C \to C$ be an endofunctor. An <em>algebra</em> over $F$ is a pair $(A, \alpha)$ where $\alpha : FA \to A$.</p> <p>Given $F$-algebras $(A, \alpha)$ and $(B, \beta)$, $\f : A \to B$ is an $F$-algebra morphism iff the following diagram commutes:</p> <script type="text/tikz">
  \begin{tikzcd}[column sep=huge, row sep=huge]
    FA \arrow[rr, "\alpha"] \arrow[dd, "Ff", pos=0.4, swap] && A \arrow[dd, "f", pos=0.4] \\
    \\
    FB \arrow[rr, "\beta", pos=0.4, swap] && B
  \end{tikzcd}
</script> <p>$F$-algebras and their morphisms form a category, and the initial object in this category is called the <em>initial algebra</em>. That is, $(A, \alpha)$ is an initial $F$-algebra iff for any $F$-algebra $(B, \beta)$, there is a unique morphism $\phi : (A, \alpha) \to (B, \beta)$</p> <h2 id="22-lists-as-initial-algebras">2.2. <a name="InductiveTypes"></a>Lists as Initial Algebras</h2> <p>As it turns out, an inductive type is a type whose interpretation is given by an initial algebra of an endofunctor. This was mentioned in part 1 using the example of the <code class="language-plaintext highlighter-rouge">List</code> type but perhaps was not explained sufficiently. Let’s unpack it a bit. First, recall the definition of the type <code class="language-plaintext highlighter-rouge">List α</code> for an arbitrary type <code class="language-plaintext highlighter-rouge">α</code>:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">List</span> (α : <span class="kt">Type</span> <span class="n">u</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">nil</span> : <span class="n">List</span> α
  <span class="o">|</span> <span class="n">cons</span> (<span class="n">head</span> : α) (<span class="n">tail</span> : <span class="n">List</span> α) : <span class="n">List</span> α
</code></pre></div></div> <p>This says, a list of <code class="language-plaintext highlighter-rouge">α</code>’s is either empty, OR it consists of a single <code class="language-plaintext highlighter-rouge">α</code> AND a list of <code class="language-plaintext highlighter-rouge">α</code>’s. Another way of looking at this type is, as a function which gives you a <code class="language-plaintext highlighter-rouge">List α</code> given either a <code class="language-plaintext highlighter-rouge">nil</code> or a <code class="language-plaintext highlighter-rouge">(head : α)</code> and a <code class="language-plaintext highlighter-rouge">(tail : List α)</code>.</p> <p>If you think of “or” as a sum, “and” as a product, and “empty” as a unit, we can express this function as a morphism:</p> <div style="text-align: center;"> $$ \phi: \mathbf{1} + (\alpha \times \texttt{List } \alpha) \to \texttt{List } \alpha $$ </div> <p>That is, $(\texttt{List} \alpha, \phi)$ is an <em>algebra</em> of the functor:</p> <div style="text-align: center;"> $$ F_\alpha x = \mathbf{1} + (\alpha \times x) $$ </div> <p>The next step would be to show that this is initial, ie. that there is a unique morphism from <code class="language-plaintext highlighter-rouge">List α</code> to any other algebra over $F_\alpha$. Instead of proving this mathematically, let’s just write the function in code! As it turns out, this function is already very familiar to anyone that has touched functional programming.</p> <p>Recall our functor</p> <div style="text-align: center;"> $$ F_\alpha X = \mathbf{1} + (\alpha \times X) $$ </div> <p>Or, in code if you prefer:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">ListF</span> <span class="err">{</span>α : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">X</span> : <span class="kt">Type</span> <span class="n">u</span>) : <span class="kt">Type</span> <span class="n">u</span> :=
  <span class="n">Unit</span> <span class="err">⊕</span> (α <span class="o">×</span> <span class="n">X</span>)
</code></pre></div></div> <p>An $F_\alpha$-algebra is a pair $(B, \beta)$ where $\beta : \mathbf{1} + (\alpha \times B) \to B$. That is, $\beta$ tells you how to collapse either:</p> <ul> <li>A <strong>unit</strong>, or</li> <li>A <strong>pair</strong> <code class="language-plaintext highlighter-rouge">(fst : α, snd : B)</code></li> </ul> <p>into a single value of type <code class="language-plaintext highlighter-rouge">B</code>.</p> <p>Suppose you want to turn a list into a single value of type <code class="language-plaintext highlighter-rouge">B</code>. To do that, you need to answer two questions:</p> <ol> <li> <p>What should an empty list mean? That is, what value of <code class="language-plaintext highlighter-rouge">B</code> should <code class="language-plaintext highlighter-rouge">nil</code> become?</p> </li> <li> <p>What should a cons cell mean? That is, given a head of type <code class="language-plaintext highlighter-rouge">α</code> and a recursive result of type <code class="language-plaintext highlighter-rouge">B</code>, how do we combine them into a new <code class="language-plaintext highlighter-rouge">B</code>?</p> </li> </ol> <p>These two pieces of data:</p> <ul> <li>A base case <code class="language-plaintext highlighter-rouge">b₀ : B</code></li> <li>A step function <code class="language-plaintext highlighter-rouge">step : α → B → B</code></li> </ul> <p>together define a function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code>β : <span class="n">Unit</span> <span class="o">+</span> (α <span class="o">×</span> <span class="n">B</span>) <span class="o">→</span> <span class="n">B</span>
</code></pre></div></div> <p>which is exactly the shape of an algebra over $F_\alpha$.</p> <p>So any such <code class="language-plaintext highlighter-rouge">(B, b₀, step)</code> forms an $F_\alpha$-algebra.</p> <h3 id="the-unique-morphism-from-list-α">The Unique Morphism from <code class="language-plaintext highlighter-rouge">List α</code></h3> <p>Now the magic: because <code class="language-plaintext highlighter-rouge">List α</code> is the <em>initial algebra</em> of $F_\alpha$, there exists a <em>unique morphism</em> from <code class="language-plaintext highlighter-rouge">List α</code> to any other $F_\alpha$-algebra <code class="language-plaintext highlighter-rouge">(B, β)</code>.</p> <p>This morphism is defined by recursion:</p> <ul> <li>It sends <code class="language-plaintext highlighter-rouge">nil</code> to <code class="language-plaintext highlighter-rouge">b₀</code></li> <li>It sends <code class="language-plaintext highlighter-rouge">cons x xs</code> to <code class="language-plaintext highlighter-rouge">step x (⟦xs⟧)</code>, where <code class="language-plaintext highlighter-rouge">⟦xs⟧</code> is the interpretation of the tail</li> </ul> <p>Let’s define it in Lean:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">reduce</span> <span class="err">{</span>α β : <span class="kt">Type</span><span class="err">}</span> (<span class="n">b</span><span class="err">₀</span> : β) (<span class="n">step</span> : α <span class="o">→</span> β <span class="o">→</span> β) : <span class="n">List</span> α <span class="o">→</span> β
  <span class="o">|</span> [] <span class="o">=&gt;</span> <span class="n">b</span><span class="err">₀</span>
  <span class="o">|</span> <span class="n">x</span> :: <span class="n">xs</span> <span class="o">=&gt;</span> <span class="n">step</span> <span class="n">x</span> (<span class="n">reduce</span> <span class="n">b</span><span class="err">₀</span> <span class="n">step</span> <span class="n">xs</span>)
</code></pre></div></div> <p>This may look familiar to you if you have ever used a functional language before, in fact, this is just the <code class="language-plaintext highlighter-rouge">foldr</code> function! If you’ve ever written any functional programs you have likely used this plenty.</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foldr</span> <span class="err">{</span>α β : <span class="kt">Type</span><span class="err">}</span> (<span class="n">b</span><span class="err">₀</span> : β) (<span class="n">step</span> : α <span class="o">→</span> β <span class="o">→</span> β) : <span class="n">List</span> α <span class="o">→</span> β
  <span class="o">|</span> [] <span class="o">=&gt;</span> <span class="n">b</span><span class="err">₀</span>
  <span class="o">|</span> <span class="n">x</span> :: <span class="n">xs</span> <span class="o">=&gt;</span> <span class="n">step</span> <span class="n">x</span> (<span class="n">foldr</span> <span class="n">b</span><span class="err">₀</span> <span class="n">step</span> <span class="n">xs</span>)
</code></pre></div></div> <p>In categorical terms:</p> <ul> <li><code class="language-plaintext highlighter-rouge">List α</code> is the initial $F_\alpha$-algebra</li> <li><code class="language-plaintext highlighter-rouge">(β, b₀, step)</code> is any other $F_\alpha$-algebra</li> <li><code class="language-plaintext highlighter-rouge">foldr</code> is the unique morphism from the initial algebra to that target algebra</li> </ul> <p>So every time you use <code class="language-plaintext highlighter-rouge">foldr</code>, you’re using the initiality of <code class="language-plaintext highlighter-rouge">List α</code> to collapse the list into a value.</p> <h2 id="3-free-monads-as-initial-algebras">3. <a name="FreeMonads"></a>Free Monads as Initial Algebras</h2> <p>Now remember in part 1, we gave a functorial description of free monads analogously to that of lists, as follows:</p> <div style="text-align: center;"> $$ \Phi_F G = \text{Id} + F \circ G $$ </div> <p>Hopefully now this makes even more sense. But remember, the way we ended up defining free monads in Lean was not the traditional <code class="language-plaintext highlighter-rouge">Free</code> definition we had in Haskell. Due to strict positivity, we had to give a slightly trickier definition:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FreeM</span><span class="o">.</span><span class="err">{</span><span class="n">u</span>, <span class="n">v</span>, <span class="n">w</span><span class="err">}</span> (<span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span>) (α : <span class="kt">Type</span> <span class="n">w</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">pure</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α
  <span class="o">|</span> <span class="n">liftBind</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">F</span> <span class="err">ι</span>) (<span class="n">cont</span> : <span class="err">ι</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> α) : <span class="n">FreeM</span> <span class="n">F</span> α
</code></pre></div></div> <p>It’s an inductive type, so it’s an initial algebra over some functor. What could this functor be? Let’s break it down a bit and try to build up what this functor looks like categorically.</p> <p>We have two constructors, which tells us we have a sum, with <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">liftBind</code> on either side. <code class="language-plaintext highlighter-rouge">pure</code> is pretty straightforward, its just an <code class="language-plaintext highlighter-rouge">α</code>, so our functor will be $\alpha + …$ followed by something. The <code class="language-plaintext highlighter-rouge">liftBind</code> constructor is a bit tricker. It’s indexed by <code class="language-plaintext highlighter-rouge">ι</code>, so we can think of <code class="language-plaintext highlighter-rouge">liftBind</code> as a <em>family</em> of constructors indexed by <code class="language-plaintext highlighter-rouge">Type u</code>. It also requires an <code class="language-plaintext highlighter-rouge">op : f ι</code> and a <code class="language-plaintext highlighter-rouge">cont : ι → FreeM f α</code>. We can represent our family of constructors as an indexed sum, and the other arguments as the usual product. The functor then looks like this:</p> <div style="text-align: center;"> $$ \Phi_F(X) := \alpha + \sum_\iota F \iota \times (\iota \to X) $$ </div> <p>To give an algebra over this functor means: given either</p> <ul> <li>a <strong>value</strong> of type <code class="language-plaintext highlighter-rouge">α</code>, or</li> <li>an <strong>index</strong> <code class="language-plaintext highlighter-rouge">ι</code>, an <strong>effect</strong> <code class="language-plaintext highlighter-rouge">op : F ι</code>, and a <strong>continuation</strong> <code class="language-plaintext highlighter-rouge">k : ι → FreeM F α</code>,</li> </ul> <p>you tell me how to return a value of type <code class="language-plaintext highlighter-rouge">FreeM F α</code>.</p> <p>So just like with <code class="language-plaintext highlighter-rouge">List</code>, we can define a morphism:</p> <div style="text-align: center;"> $$ \varphi_F : \alpha + \textstyle\sum_\iota F\ \iota \times (\iota \to \text{FreeM }F\alpha) \to \text{FreeM } F\alpha $$ </div> <p>by matching on the sum:</p> <ul> <li>If it’s an <code class="language-plaintext highlighter-rouge">inl a</code>, return <code class="language-plaintext highlighter-rouge">pure a</code></li> <li>If it’s an <code class="language-plaintext highlighter-rouge">inr (ι, (op, k))</code>, return <code class="language-plaintext highlighter-rouge">liftBind op k</code></li> </ul> <p>Now to show that <code class="language-plaintext highlighter-rouge">FreeM F α</code> is initial, we need to define the unique morphism from it into any other $\Phi_F$-algebra. This is just like what we did with <code class="language-plaintext highlighter-rouge">List α</code>. Given an algebra <code class="language-plaintext highlighter-rouge">(B, pureCase, bindCase)</code> — that is:</p> <ul> <li>a function <code class="language-plaintext highlighter-rouge">pureCase : α → B</code> for the <code class="language-plaintext highlighter-rouge">pure</code> case, and</li> <li>a function <code class="language-plaintext highlighter-rouge">bindCase : ∀ {ι}, F ι → (ι → B) → B</code> for the <code class="language-plaintext highlighter-rouge">liftBind</code> case,</li> </ul> <p>we want to define a function <code class="language-plaintext highlighter-rouge">⟦·⟧ : FreeM F α → B</code> that collapses the entire free monad tree into a single result of type <code class="language-plaintext highlighter-rouge">B</code>.</p> <p>Just like with <code class="language-plaintext highlighter-rouge">foldr</code> for lists, we define this function recursively:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">foldFree</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{</span>α β : <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span>
  (<span class="n">pureCase</span> : α <span class="o">→</span> β)
  (<span class="n">bindCase</span> : <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="o">→</span> <span class="n">F</span> <span class="err">ι</span> <span class="o">→</span> (<span class="err">ι</span> <span class="o">→</span> β) <span class="o">→</span> β)
  : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> β
<span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">pureCase</span> <span class="n">a</span>
<span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">k</span> <span class="o">=&gt;</span> <span class="n">bindCase</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="n">foldFree</span> <span class="n">pureCase</span> <span class="n">bindCase</span> (<span class="n">k</span> <span class="n">x</span>))
</code></pre></div></div> <p>This is the fold analogue for the free monad: the unique morphism from the initial algebra <code class="language-plaintext highlighter-rouge">FreeM F α</code> to any other algebra <code class="language-plaintext highlighter-rouge">(β, pureCase, bindCase)</code>. It lets us “run” or “collapse” a free monadic structure by specifying what to do at each node of the tree.</p> <h2 id="4-catamorphisms-as-interpreters">4. <a name="Cata"></a>Catamorphisms as Interpreters</h2> <p>We’ve now seen two initial algebras and described their unique outgoing morphisms as ways of “folding” or “collapsing” their data into another value. In functional programming, there is a word for the unique morphism from an initial algebra - a <strong>catamorphism</strong>. This is a generalization of folding that allows you to collapse structured data from an initial algebra into a single value. More precisely, a catamorphism is the unique function from an inductive type to any algebra over its defining functor, which folds the recursive structure into some value and respects the algebra’s semantics.</p> <p>In the case of the free monad, the separation of syntax and semantics provides additional freedom in how programs are interpreted. Given a computation tree defined by a free monad, one can evaluate its value, execute its effects, pretty print its nodes, or anything else all by selecting the appropriate target algebra for its catamorphism. We will put this to use in part 4, where we build and verify an interpreter for a small effectful language.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>In this post, we explored how free monads arise as initial algebras over a particular functor, and how this initiality gives rise to a unique morphism—called a catamorphism—that collapses or interprets the structure into some other type. This construction generalizes common patterns in functional programming, such as folding over lists.</p> <h2 id="6-exercise">6. <a name="Exercise"></a>Exercise</h2> <ul> <li>Suppose <code class="language-plaintext highlighter-rouge">Tree α</code> is defined as either a <code class="language-plaintext highlighter-rouge">Leaf α</code> or a <code class="language-plaintext highlighter-rouge">Branch</code> of two subtrees. Define it as an initial algebra over an appropriate functor and write the associated <code class="language-plaintext highlighter-rouge">foldTree</code>.</li> </ul> <h2 id="continue-to-part-3---universal-morphisms"><strong>Continue to Part 3 - Universal Morphisms</strong></h2> <p><a href="/blog/2025/freer-monad-part3/">Continue to Part 3 - Universal Morphisms</a></p>]]></content><author><name></name></author><category term="Formal"/><category term="Verification,"/><category term="Free"/><category term="Monads"/><category term="lean,"/><category term="free-monads,"/><category term="catamorphisms,"/><category term="interpreters"/><summary type="html"><![CDATA[Part of the free monads series]]></summary></entry><entry><title type="html">Part 1: Defining the Free Monad in Lean</title><link href="https://tannerduve.github.io/blog/2025/freer-monad-part1/" rel="alternate" type="text/html" title="Part 1: Defining the Free Monad in Lean"/><published>2025-06-16T17:00:00+00:00</published><updated>2025-06-16T17:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/freer-monad-part1</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/freer-monad-part1/"><![CDATA[<h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>Free monads provide a way to represent effectful sequential programs as pure syntactic data, separate from their interpretation. You describe <em>what</em> should happen as an abstract tree of effects, leaving open <em>how</em> you want it to happen. By decoupling syntax from semantics like this you gain full control over how programs are evaluated and interpreted - for example we could interpret a syntax tree in multiple ways:</p> <ul> <li>Run it directly</li> <li>Pretty print it</li> <li>Analyze it statically</li> </ul> <p>Each of these corresponds to a different interpreter. This approach also allows effects to be combined without you having to get tangled up in monad transformers.</p> <p>This four-part series will introduce the free monad in Lean. In this first part we will introduce and implement the free monad from first principles, and discuss some of the finesse involved in implementing it in a proof assistant like Lean, compared to a functional language like Haskell.</p> <p>In part 2 we will further explore some theory and study initial algebras and catamorphisms, and how they give rise to interpreters for effectful computation trees. In part 3 we will study the universal property of free monads and what it provides for us as programmers. Finally in part 4, we will use what we’ve learned to build and verify a real interpreter for a small language, making elegant use of freeness to combine effectful computations.</p> <p>This series assumes you know basic concepts from both category theory and functional programming, including functors, monads, and inductive datatypes. You can find most of the code used here at <a href="https://github.com/leanprover-community/mathlib4/pull/25491">this Mathlib PR</a></p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#FreeObjects">Free Objects</a></li> <li><a href="#FreeMonads">Free Monads</a> <ul> <li><a href="#InHaskell">In Haskell</a></li> <li><a href="#InLean">In Lean</a></li> </ul> </li> <li><a href="#Conclusion">Conclusion</a></li> </ol> <h2 id="2-free-objects">2. <a name="FreeObjects"></a>Free Objects</h2> <p>Before getting into free monads, we will first consider what it means for some structure to be “free”. This section is pretty mathematical but if you’re like me it may help understand things down the line when we start coding, otherwise you can skim this section.</p> <p>As a familiar example, consider a vector space $V$ over a field $F$ with basis $B$. $V$ is said to be “free” on $B$: it is the smallest vector space containing $B$, and is generated by taking all finite linear combinations of elements in $B$ with coefficients in $F$. A similar construction is done for other algebraic structures, for example the free group $G_S$ on a set $S$ consists of all the reduced words of elements of $S$.</p> <p>The free object which is most familiar to the programmer is the free monoid on a datatype <code class="language-plaintext highlighter-rouge">α</code>, aka the type <code class="language-plaintext highlighter-rouge">List α</code>. This is of course the type of all finite sequences of elements of <code class="language-plaintext highlighter-rouge">α</code>, which forms the monoid <code class="language-plaintext highlighter-rouge">(List α, ++, [])</code>, where <code class="language-plaintext highlighter-rouge">++</code> is list concatenation.</p> <p>How can we generalize this? In general categories, free constructions are defined as left adjoints to forgetful functors. If a forgetful functor $U : C \to D$ has a left adjoint $F : D \to C$, then for any $x \in D$, $Fx$ is the free $C$-object on $x$.</p> <p>Consider the functor $U : \texttt{Grp} \to \texttt{Set}$ which forgets the group structure and returns the underlying set. If $F : \texttt{Set} \to \texttt{Grp}$ is left adjoint to $U$, then $FX$ is the free group on $X$ for any set $X$.</p> <p>This can also be stated in terms of a universal property. Slightly informally, an object $X’$ is the free $C$-object on $X$ if there is an embedding $\iota : X \to X’$ such that for any $C$-object $G$ with a map $h : X \to G$, there is a unique $C$-morphism $\hat{h} : X’ \to G$ such that the following diagram commutes:</p> <script type="text/tikz">
\begin{tikzcd}[column sep=5em, row sep=5em, labels={font=\normalsize}]
  {X'} \arrow[rr, dashed, "{\hat{h}}"] && G \\
  \\
  X \arrow[uu, "\iota"', pos=0.35] \arrow[uurr, "h"', pos=0.55]
\end{tikzcd}
</script> <p><em>(Exercise: Let $U : \texttt{Grp} \to \texttt{Set}$ be the forgetful functor and $F$ a left adjoint. Prove $FX$ satisfies the above universal property for any set $X$.)</em></p> <p>The moral of the story here is that a free construction is the canonical way to generate the desired structure from some underlying data, adding only what is necessary to satisfy the rules of the desired structure. Our free monad is thus the canonical monad generated from an endofunctor, satisfying nothing other than the monad laws.</p> <h2 id="3-free-monads">3. <a name="FreeMonads"></a>Free Monads</h2> <blockquote> <p>“A monad is just a monoid in the category of endofunctors, what’s the problem?”</p> </blockquote> <p>You’ve probably heard someone jokingly say monads are <em>just</em> monoids in the category of endofunctors. It’s technically a correct definition, but it tells you nothing if you don’t speak category theory. However, understanding monads as monoids may actually help us construct the free monad by analogy to the free monoid, aka the <code class="language-plaintext highlighter-rouge">List</code> type. I know I promised this was an article on Lean but we will start with some Haskell first.</p> <h3 id="31-in-haskell">3.1. <a name="InHaskell"></a>In Haskell</h3> <p>The List type is defined as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="n">List</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Nil</span> <span class="o">|</span> <span class="n">Cons</span> <span class="n">a</span> (<span class="n">List</span> <span class="n">a</span>)
</code></pre></div></div> <p>Categorically this looks like:</p> \[L_a \cong \mathbf{1} + (a \times L_a)\] <p>i.e., the List type is a fixed point of the functor:</p> \[F_a x = \mathbf{1} + (a \times x)\] <p><em><a href="/blog/2025/freer-monad-part2/">Part 2</a> goes into more detail about inductive types as fixed points of functors. This part is just briefly explaining the analogy between lists and free monads, and the mathematical detail is not centrally important yet</em></p> <p>The List functor maps a type to its free monoid, and we want our free monad functor to map an endofunctor to its free monad. The heart of the analogy is that lists are to types as free monads are to functors. So, we “lift” what we have done on lists in the category of types to free monads in the category of endofunctors. In programmer terms, we are defining a higher-order functor that is analogous to <code class="language-plaintext highlighter-rouge">List</code>, but acts on functors rather than types.</p> <p>Our monoidal product in the endofunctor category is functor composition, the terminal object is the identity functor, and coproduct is defined component-wise. Thus the analogous functor is:</p> \[\Phi_F G = \text{Id} + F \circ G\] <p>Note how this corresponds to the above definition of <code class="language-plaintext highlighter-rouge">List</code>. Our free monad is the (least) fixed point:</p> \[\text{Free}_F \cong \text{Id} + F \circ \text{Free}_F\] <p>Finally we are all done with the category theory for this part. Let’s now write our free monad in code:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Pure</span> <span class="n">a</span> <span class="o">|</span> <span class="n">Free</span> (<span class="n">f</span> (<span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>))
</code></pre></div></div> <p>To be more explicit with the types, we have the constructors:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Pure</span> :: <span class="n">a</span> <span class="o">-&gt;</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>
<span class="n">Free</span> :: <span class="n">f</span> (<span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>) <span class="o">-&gt;</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div> <p>Convince yourself that this definition corresponds to the categorical one we gave above.</p> <p>This already kind of looks like a monad by definition! Now, given that <code class="language-plaintext highlighter-rouge">f</code> is a functor, we can define a straightforward monad instance on <code class="language-plaintext highlighter-rouge">Free f</code> as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">instance</span> <span class="n">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">Monad</span> (<span class="n">Free</span> <span class="n">f</span>) <span class="n">where</span>
  <span class="n">return</span> <span class="o">=</span> <span class="n">Pure</span>
  <span class="n">Pure</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
  <span class="n">Free</span> <span class="n">g</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Free</span> ((<span class="o">&gt;&gt;=</span> <span class="n">f</span>) <span class="o">&lt;</span><span class="err">$</span><span class="o">&gt;</span> <span class="n">g</span>)
</code></pre></div></div> <h3 id="32-in-lean">3.2. <a name="InLean"></a>In Lean</h3> <p>Now, as promised, we will do the rest of our work in Lean. Let’s write the same definition in Lean:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">Free</span> (<span class="n">f</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span>) (<span class="n">a</span> : <span class="kt">Type</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">pure</span> : <span class="n">a</span> <span class="o">→</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>
  <span class="o">|</span> <span class="n">free</span> : <span class="n">f</span> (<span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>) <span class="o">→</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div> <p>Weird. We get this opaque error message:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- error: (kernel) arg #3 of `Free.free' contains a non valid occurrence of the
datatypes being declared
</code></pre></div></div> <p>Why does the definition work in Haskell but not Lean?</p> <p><strong>Strict Positivity</strong></p> <p>Recall that, in languages like Lean (or Coq, or Agda), in order for the proof system to be consistent, all functions must terminate. Proofs correspond to programs, and if we had programs that could loop forever, we could prove anything, and our logic would be useless.</p> <p>To enforce this, defining inductive types has a restriction, called <a href="https://www.pls-lab.org/Strictly_positive"><strong>strict positivity</strong></a>. Basically, an inductive type can not refer to itself on the left side of an arrow in its constructors. If Lean allowed this definition, we could inhabit the empty type (i.e. prove False) using a contravariant functor.</p> <p>Since the free monad doesn’t work due to type-theoretic restrictions, we need a little bit more freedom. <em>Enter the freer monad</em>. The below definition is strictly positive:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FreeM</span><span class="o">.</span><span class="err">{</span><span class="n">u</span>, <span class="n">v</span>, <span class="n">w</span><span class="err">}</span> (<span class="n">f</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span>) (α : <span class="kt">Type</span> <span class="n">w</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">pure</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">f</span> α
  <span class="o">|</span> <span class="n">liftBind</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">f</span> <span class="err">ι</span>) (<span class="n">cont</span> : <span class="err">ι</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">f</span> α) : <span class="n">FreeM</span> <span class="n">f</span> α
</code></pre></div></div> <p>In fact, this is <em>freer</em> in the sense that we no longer even require <code class="language-plaintext highlighter-rouge">f</code> to be a functor. Let’s define the Functor and Monad instances for this type, given any type constructor.</p> <p><strong>Monad Instance of <code class="language-plaintext highlighter-rouge">FreeM f</code></strong></p> <p>We begin by providing a Functor instance, which is just defining a map function, lifting a function $f : \alpha \to \beta$ to a function $Ff : \text{FreeM } F \ \alpha \to \text{FreeM } F \ \beta$:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">w</span><span class="err">'</span> <span class="n">w</span><span class="err">''</span>
<span class="k">namespace</span> <span class="n">FreeM</span>
<span class="k">variable</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="err">{</span>α : <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span> <span class="err">{</span>β : <span class="kt">Type</span> <span class="n">w</span><span class="err">'}</span> <span class="err">{γ</span> : <span class="kt">Type</span> <span class="n">w</span><span class="err">''}</span>

<span class="k">def</span> <span class="n">map</span> (<span class="n">f</span> : α <span class="o">→</span> β) : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> β
  <span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">pure</span> (<span class="n">f</span> <span class="n">a</span>)
  <span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">z</span> <span class="o">=&gt;</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">map</span> <span class="n">f</span> (<span class="n">cont</span> <span class="n">z</span>))

<span class="k">instance</span> : <span class="n">Functor</span> (<span class="n">FreeM</span> <span class="n">F</span>) <span class="n">where</span>
  <span class="n">map</span> := <span class="o">.</span><span class="n">map</span>
</code></pre></div></div> <p>Now we can provide a monad instance by defining <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">bind</code> as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">def</span> <span class="n">bind</span> (<span class="n">x</span> : <span class="n">FreeM</span> <span class="n">F</span> α) (<span class="n">f</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> β) : <span class="n">FreeM</span> <span class="n">F</span> β :=
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">z</span> <span class="o">=&gt;</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">bind</span> (<span class="n">cont</span> <span class="n">z</span>) <span class="n">f</span>)

<span class="k">instance</span> : <span class="n">Monad</span> (<span class="n">FreeM</span> <span class="n">F</span>) <span class="n">where</span>
  <span class="n">pure</span> := <span class="o">.</span><span class="n">pure</span>
  <span class="n">bind</span> := <span class="o">.</span><span class="n">bind</span>
</code></pre></div></div> <p>Of course we all love Lean because you can actually prove things about the code you write. Lean provides not just a <code class="language-plaintext highlighter-rouge">Monad</code> typeclass, but a <code class="language-plaintext highlighter-rouge">LawfulMonad</code> typeclass, which additionally requires explicit proofs that the monad laws are satisfied. Let’s do this for fun. Throughout these posts I will be using some lemmas that you can find in the source code whose statements/proofs I won’t expliclty be showing here.</p> <p>We first prove it is a lawful functor, i.e. it is <em>functorial</em> in the categorical sense:</p> <ul> <li>Identity law: $\text{map}\ id = id$</li> <li>Composition law: $\text{map}\ (g \circ f) = \text{map}\ g \circ \text{map}\ f$</li> </ul> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">instance</span> : <span class="n">LawfulFunctor</span> (<span class="n">FreeM</span> <span class="n">F</span>) <span class="n">where</span>
  <span class="n">map_const</span> := <span class="n">rfl</span>
  <span class="n">id_map</span> <span class="n">x</span> := <span class="k">by</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
    <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
      <span class="n">simp_all</span> [<span class="n">map_eq_map</span>, <span class="n">lift_def</span>, <span class="n">map</span>, <span class="n">ih</span>]
  <span class="n">comp_map</span> <span class="n">g</span> <span class="n">h</span> <span class="n">x</span> := <span class="k">by</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
    <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
      <span class="n">simp_all</span> [<span class="n">map_eq_map</span>, <span class="n">lift_def</span>, <span class="n">map</span>, <span class="n">ih</span>]
</code></pre></div></div> <p>Now we prove that our structure is a <strong>lawful monad</strong>, meaning it satisfies the following <strong>monad laws</strong>:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">bind_pure_comp : x &gt;&gt;= (λ a → pure (f a)) = f &lt;$&gt; x</code><br/> A bind followed by pure composed with a function is equivalent to a functorial map.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">id_map : id &lt;$&gt; x = x</code><br/> Mapping the identity function over a value leaves it unchanged.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">pure_bind : pure x &gt;&gt;= f = f x</code><br/> Pure followed by bind is equivalent to function application.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">bind_assoc : (x &gt;&gt;= f) &gt;&gt;= g = x &gt;&gt;= (λ a → f a &gt;&gt;= g)</code><br/> Bind is associative.</p> </li> </ul> <p>The proof is as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">-- Lemma that bind is associative</span>
<span class="k">protected</span> <span class="k">theorem</span> <span class="n">bind_assoc</span> (<span class="n">x</span> : <span class="n">FreeM</span> <span class="n">F</span> α) (<span class="n">f</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> β) (<span class="n">g</span> : β <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> <span class="err">γ</span>) :
    (<span class="n">x</span><span class="o">.</span><span class="n">bind</span> <span class="n">f</span>)<span class="o">.</span><span class="n">bind</span> <span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">bind</span> (<span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> (<span class="n">f</span> <span class="n">x</span>)<span class="o">.</span><span class="n">bind</span> <span class="n">g</span>) := <span class="k">by</span>
  <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
  <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
    <span class="n">simp</span> [<span class="n">FreeM</span><span class="o">.</span><span class="n">bind</span>,  <span class="err">←</span> <span class="n">pure_eq_pure</span>] <span class="n">at</span> <span class="o">*</span>
    <span class="n">simp</span> [<span class="n">ih</span>]

<span class="cd">-- Complete proof that FreeM F is a lawful monad</span>
<span class="k">instance</span> : <span class="n">LawfulMonad</span> (<span class="n">FreeM</span> <span class="n">F</span>) := <span class="n">LawfulMonad</span><span class="o">.</span><span class="n">mk</span><span class="err">'</span>
  (<span class="n">bind_pure_comp</span> := <span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="k">by</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
    <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> [<span class="n">FreeM</span><span class="o">.</span><span class="n">bind</span>, <span class="n">bind_eq_bind</span>, <span class="n">map_eq_map</span>, <span class="n">pure_eq_purePure</span>, <span class="n">map</span>] <span class="n">at</span> <span class="o">*</span>
      <span class="n">simp</span> <span class="n">only</span> [<span class="n">ih</span>]
  )
  (<span class="n">id_map</span> := <span class="n">id_map</span>)
  (<span class="n">pure_bind</span> := <span class="k">fun</span> <span class="n">x</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">rfl</span>)
  (<span class="n">bind_assoc</span> := <span class="n">FreeM</span><span class="o">.</span><span class="n">bind_assoc</span>)
</code></pre></div></div> <p>I won’t write out the informal details of the proof, but it is mostly straightforward, we unfold all the definitions using <code class="language-plaintext highlighter-rouge">simp</code>, and in some cases when we have a value of type <code class="language-plaintext highlighter-rouge">FreeM F a</code> we perform induction on it and simplify further using our lemmas.</p> <h2 id="4-conclusion">4. <a name="Conclusion"></a>Conclusion</h2> <p>In this first part of our series, we explored the concept of free objects and introduced the idea of a free monad from a categorical perspective. Starting from familiar examples like free vector spaces and monoids, we generalized the construction to free monads, and implemented the free monad in Lean from the ground up.</p> <p>We discussed the idea of <em>strict positivity</em>, leading us to the freer monad construction as both a workaround and a generalization. We were able to define a monad instance on <code class="language-plaintext highlighter-rouge">FreeM F</code> for any <code class="language-plaintext highlighter-rouge">F : Type -&gt; Type</code>, and proved that it satisfies the monad laws.</p> <h2 id="the-story-continues-in-part-2-with-catamorphisms-interpreters-and-universal-properties"><strong>The story continues in <a href="/blog/2025/freer-monad-part2/">Part 2</a> with catamorphisms, interpreters, and universal properties.</strong></h2>]]></content><author><name></name></author><category term="Formal-Verification"/><category term="Free-Monads"/><category term="lean"/><category term="free-monads"/><category term="category-theory"/><summary type="html"><![CDATA[Introducing the categorical theory and implementation of free monads in Lean]]></summary></entry><entry><title type="html">The Free Monad: A Four-Part Series</title><link href="https://tannerduve.github.io/blog/2025/freer-monad/" rel="alternate" type="text/html" title="The Free Monad: A Four-Part Series"/><published>2025-05-21T21:00:00+00:00</published><updated>2025-05-21T21:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/freer-monad</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/freer-monad/"><![CDATA[<p>Free monads provide a way to represent effectful sequential programs as pure syntactic data, separate from their interpretation. You describe <em>what</em> should happen as an abstract tree of effects, leaving open <em>how</em> you want it to happen. By decoupling syntax from semantics like this you gain full control over how programs are evaluated and interpreted - for example we could interpret a syntax tree in multiple ways:</p> <ul> <li>Run it directly</li> <li>Pretty print it</li> <li>Analyze it statically</li> </ul> <p>Each of these corresponds to a different interpreter. This approach also allows effects to be combined without you having to get tangled up in monad transformers. <em>Freer</em> monads are a flexible generalization of free monads that make combining and interpreting effects even easier.</p> <p>This four-part series will introduce the free monad in Lean — Part 1 will introduce the categorical theory and motivation of the free monad and walk through its implementation in Lean. In part 2 we will further explore some theory and study initial algebras and catamorphisms, and how they give rise to canonical interpreters for effectful computation trees. In part 3 we will study the universal property of free monads and what it provides for us as programmers. Finally in part 4, we will use what we’ve learned to build and verify a real interpreter for a small language, making elegant use of freeness to combine effectful computations.</p> <p>This series assumes you know basic concepts from both category theory and functional programming, including functors, monads, and inductive datatypes.</p> <ol> <li><a href="/blog/2025/freer-monad-part1/">Part 1 — Defining the Free Monad in Lean</a></li> <li><a href="/blog/2025/freer-monad-part2/">Part 2 — Initial Algebras, Catamorphisms, and Interpreters</a></li> <li><a href="/blog/2025/freer-monad-part3/">Part 3 — Universal Morphisms and Effect Handlers</a></li> <li><a href="/blog/2025/freer-monad-part4/">Part 4 — Tutorial: A Verified Interpreter with Side Effects</a></li> </ol>]]></content><author><name></name></author><category term="Formal-Verification"/><category term="Free-Monads"/><category term="lean"/><category term="free-monads"/><category term="category-theory"/><category term="effects"/><summary type="html"><![CDATA[A four-part series on free monads in Lean]]></summary></entry><entry><title type="html">Verified Dynamic Programming with Σ-types in Lean</title><link href="https://tannerduve.github.io/blog/2025/verified-dp/" rel="alternate" type="text/html" title="Verified Dynamic Programming with Σ-types in Lean"/><published>2025-05-21T20:00:00+00:00</published><updated>2025-05-21T20:00:00+00:00</updated><id>https://tannerduve.github.io/blog/2025/verified-dp</id><content type="html" xml:base="https://tannerduve.github.io/blog/2025/verified-dp/"><![CDATA[<h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>If you’ve taken an algorithms class, you have likely seen dynamic programming, specifically a technique called <em>memoization</em>. Memoization works to optimize recursive algorithms by <em>caching</em> the solutions to subproblems in a table, and when a subproblem is encountered, it queries the table instead of recomputing the solution. This gives us an exponential performance boost.</p> <p>This blog post will show how to solve a dynamic programming problem using memoization in Lean, and verify its correctness against a specification. The technique used in the proof of correctness here is an interesting application of Lean’s dependent types, and is generalized to work for any memoization algorithm. The idea came from a conversation with <a href="https://gasstationmanager.github.io">GasStationManager</a> over at the <a href="https://leanprover.zulipchat.com">Lean Zulip chat</a>, who I credit with coming up with the general technique.</p> <p>This should be pretty beginner friendly. Basic data structures+algorithms at the undergrad level. Lean experience is not necessary but you should be able to read functional code.</p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#Problem">Problem</a></li> <li><a href="#FirstSolution">First Solution</a></li> <li><a href="#Sigma">Type Theory Interlude: Subtypes and Dependent Pairs</a></li> <li><a href="#Solution">Improved Solution</a></li> <li><a href="#Conclusion">Conclusion</a></li> <li><a href="#Exercises">Exercises</a></li> <li><a href="#References">References</a></li> </ol> <h2 id="2-problem">2. <a name="Problem"></a>Problem</h2> <p>The problem we will be working on here is called <a href="https://www.hackerearth.com/practice/algorithms/dynamic-programming/state-space-reduction/practice-problems/algorithm/bytelandian-gold-coins/">Bytelandian Gold Coins</a>. The problem description is as follows:</p> <blockquote> <p>In Byteland they have a very strange monetary system. Each Bytelandian gold coin has an integer number written on it. A coin n can be exchanged in a bank into three coins: n/2, n/3 and n/4. But these numbers are all rounded down (the banks have to make a profit).</p> <p>You can also sell Bytelandian coins for American dollars. The exchange rate is 1:1. But you can not buy Bytelandian coins. You have one gold coin. What is the maximum amount of American dollars you can get for it?</p> </blockquote> <p>The solution is classic DP. Observe that for any amount up to 8, we can’t get more money by dividing into $n/2, n/3, n/4$. For any value, the minimum amount we can get out of it is $n$. We will compare this value with the value we get after dividing $n$ and select the bigger value.</p> <h2 id="3-first-solution">3. <a name="FirstSolution"></a>First Solution</h2> <p>The solution is given by the following recurrence relation :</p> \[f(n)= \begin{cases} n, &amp; n \le 8,\\[6pt] \displaystyle \max\!\bigl(n,\; f(\lfloor n/2\rfloor)+f(\lfloor n/3\rfloor)+f(\lfloor n/4\rfloor)\bigr), &amp; n&gt;8. \end{cases}\] <p>Before writing any code, here is the header we’ll want to use:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="n">Std</span><span class="o">.</span><span class="n">Data</span><span class="o">.</span><span class="n">HashMap</span>
<span class="k">open</span> <span class="n">Std</span>
</code></pre></div></div> <p>We define the recurrence in Lean as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  <span class="n">if</span> <span class="n">n</span> <span class="o">≤</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">
  -- Base case: for `n ≤ 8`, it's better to sell the coin directly.</span>
    <span class="n">n</span>
  <span class="n">else</span><span class="cd">
  -- Recursive case: choose the maximum between selling the coin directly and exchanging it.</span>
    <span class="n">max</span> <span class="n">n</span> (<span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="o">+</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="o">+</span> <span class="n">maxDollars_spec</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>))
</code></pre></div></div> <p>This directly computes the maximum earnable amount. We will use this as our specification for proving our memoized solution is correct.</p> <p>Now here is a memoized solution:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollarsMemo</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  <span class="n">let</span> <span class="n">rec</span> <span class="n">helperMemo</span> (<span class="n">n</span> : <span class="n">Nat</span>) (<span class="n">memo</span> : <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span>) : <span class="n">Nat</span> <span class="o">×</span> <span class="n">HashMap</span> <span class="n">Nat</span> <span class="n">Nat</span> :=
      <span class="k">match</span> <span class="n">memo</span><span class="o">.</span><span class="n">get</span><span class="err">?</span> <span class="n">n</span> <span class="k">with</span>
      <span class="o">|</span> <span class="n">some</span> <span class="n">v</span> <span class="o">=&gt;</span> (<span class="n">v</span>, <span class="n">memo</span>)  <span class="cd">-- already cached</span>
      <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span>
        <span class="n">if</span> <span class="n">n</span> <span class="o">≤</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">          -- base case: sell coin directly</span>
          <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">memo</span><span class="o">.</span><span class="n">insert</span> <span class="n">n</span> <span class="n">n</span>
          (<span class="n">n</span>, <span class="n">memo</span><span class="err">'</span>)
        <span class="n">else</span><span class="cd">
          -- recursive: compute best exchange value, memoizing along the way</span>
          <span class="n">let</span> (<span class="n">v1</span>, <span class="n">memo1</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="n">memo</span>
          <span class="n">let</span> (<span class="n">v2</span>, <span class="n">memo2</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="n">memo1</span>
          <span class="n">let</span> (<span class="n">v3</span>, <span class="n">memo3</span>) := <span class="n">helperMemo</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>) <span class="n">memo2</span>
          <span class="n">let</span> <span class="n">best</span> := <span class="n">max</span> <span class="n">n</span> (<span class="n">v1</span> <span class="o">+</span> <span class="n">v2</span> <span class="o">+</span> <span class="n">v3</span>)
          <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">memo3</span><span class="o">.</span><span class="n">insert</span> <span class="n">n</span> <span class="n">best</span>
          (<span class="n">best</span>, <span class="n">memo</span><span class="err">'</span>)
  (<span class="n">helperMemo</span> <span class="n">n</span> (<span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>))<span class="o">.</span><span class="n">fst</span>
</code></pre></div></div> <p>This function defines a helper which caches the solutions to subproblems in a hashmap and at each recursive call, queries the hashmap for a stored value. It then calls the helper on the empty map and returns the <code class="language-plaintext highlighter-rouge">n</code>th value <em>(Exercise : Rewrite this using a state monad to simulate mutating the hashmap instead of passing around a new one with each insertion)</em></p> <p>Now our correctness claim is as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">memo_correct</span> : <span class="o">∀</span> (<span class="n">n</span> : <span class="o">ℕ</span>), <span class="n">maxDollarsMemo</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maxDollarsSpec</span> <span class="n">n</span>
</code></pre></div></div> <p>That is, our memoized solution computes the recurrence correctly on every $n \in \mathbb{N}$. Trying to prove this ends up being <em>very</em> difficult. I invite the reader to try it out themselves and see where you get stuck. A good prover may figure it out. I attempted strong induction on $n$ to no avail and trying various approaches I kept getting stuck. The direct proof is indeed possible but the statement feels far too intuitively true to be worth this much effort. The key realization here as to what makes this proof difficult is that correctness relies on invariant properties of the data structure which we store our values in.</p> <p>First off, we need to prove that the HashMap correctly computes subproblems, that is, that <code class="language-plaintext highlighter-rouge">get? x</code> always returns either <code class="language-plaintext highlighter-rouge">none</code> or a value which is equal to <code class="language-plaintext highlighter-rouge">maxDollars_spec x</code>. We also rely on the invariant that if the HashMap satisfies this property before the call to <code class="language-plaintext highlighter-rouge">helperMemo</code>, then it satisfies this property after the call to <code class="language-plaintext highlighter-rouge">helperMemo</code>. To prove this requires reasoning about the body of <code class="language-plaintext highlighter-rouge">helperMemo</code>.</p> <p>There’s a lot of logic to juggle here in our proof, but thankfully there is a better way. A Haskeller is likely familiar with the notion of refinement types. In Lean we call them subtypes. Subtypes provide a way to attach logical properties to data using a familiar set-builder-like notation, where we can refer to the type of all elements of some type <code class="language-plaintext highlighter-rouge">T</code> for which a particular property holds. An example of a subtype is <code class="language-plaintext highlighter-rouge">{n : ℕ // Even n}</code> - the subtype of <code class="language-plaintext highlighter-rouge">ℕ</code> consisting of all of the Even natural numbers. This is all just syntactic sugar for a dependent pair type, aka $\Sigma$-types. Let’s explore these some more before moving on.</p> <h2 id="4-type-theory-interlude-subtypes-and-dependent-pairs">4. <a name="Sigma"></a>Type Theory Interlude: Subtypes and Dependent Pairs</h2> <p>This section is a brief detour into the theory of Lean’s subtypes. This is optional but I find it valuable. In dependent type theory, $\Sigma$-types are a generalization of a product type, where the type of the second element in a pair can <em>depend</em> on the value of the first element. In a non-dependent setting, the product $A \times B$ of two types $A$ and $B$ consists of all pairs $(a, b)$ where $a : A$ and $b : B$ - it’s just the standard cartesian product. The dependent pair type generalizes this.</p> <p>Suppose we have a type $A$ and a <em>family of types indexed by $A$</em>, denoted $B : A \to \mathcal{U}$ (where $\mathcal{U}$ denotes the universe of all types). Then the type $\sum_{(x : A)}B(x)$ consists of the pairs $(a, b)$ where $a : A$ and $b : B(a)$ - the <em>type</em> of $b$ <em>depends</em> on the <em>value</em> of $a$. Note that the Cartesian product is exactly the special case where $B$ is constant, ie $\displaystyle\sum_{(x : A)}B = A \times B$.</p> <p>Back to the original example, let’s think about <code class="language-plaintext highlighter-rouge">{n : ℕ // Even n}</code> in these terms. Under the <a href="https://en.wikipedia.org/wiki/Curry–Howard_correspondence">propositions-as-types</a> principle, the proposition <code class="language-plaintext highlighter-rouge">Even n</code> is of course just a type. But note that <code class="language-plaintext highlighter-rouge">Even n</code> is a <em>different</em> proposition for every <code class="language-plaintext highlighter-rouge">n : ℕ</code> - that is, <code class="language-plaintext highlighter-rouge">Even</code> is a <em>family</em> of types <em>indexed</em> by <code class="language-plaintext highlighter-rouge">ℕ</code>. So, the type <code class="language-plaintext highlighter-rouge">{n : ℕ // Even n}</code> is exactly the $\Sigma$-type $\sum_{n : \mathbb{N}}\text{Even}(n)$, which consists of pairs $(n, P_n)$, where $P_n$ is a <em>proof</em> that $n$ is Even.</p> <p>For a primer on dependent type theory, see chapter 1 of <a href="https://www.cs.uoregon.edu/research/summerschool/summer14/rwh_notes/hott-book.pdf">HoTT</a></p> <h2 id="5-improved-solution">5. <a name="Solution"></a>Improved Solution</h2> <p>Now that we’ve introduced subtypes we will put them to use by writing a new memoized algorithm that, in some sense, proves itself. Remember part of our correctness proof is showing that the HashMap’s <code class="language-plaintext highlighter-rouge">get? x</code> method always returns a <code class="language-plaintext highlighter-rouge">y</code> such that <code class="language-plaintext highlighter-rouge">maxDollars_spec x = y</code>. What if, to guarantee this, we write a new version of <code class="language-plaintext highlighter-rouge">get?</code> so that <code class="language-plaintext highlighter-rouge">get? x</code> returns a <code class="language-plaintext highlighter-rouge">y</code> in the subtype <code class="language-plaintext highlighter-rouge">{y : ℕ // maxDollars_spec x = y}</code>? To do this, we can just subtype the data which our HashMap stores.</p> <p>For the memoization, the property we want to hold is: for a pair <code class="language-plaintext highlighter-rouge">(k, v)</code> stored in your table, <code class="language-plaintext highlighter-rouge">f k = v</code> where <code class="language-plaintext highlighter-rouge">f</code> is the recursive function you are proving equivalence to (in our case, <code class="language-plaintext highlighter-rouge">f</code> is the the recurrence <code class="language-plaintext highlighter-rouge">maxDollars_spec</code>).</p> <p>Now the implementation is as follows. We begin with a very general definition: a pair of values with a property attached to it:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">cell</span> (<span class="n">f</span> : α <span class="o">→</span> β) := <span class="err">{</span><span class="n">c</span>: α <span class="o">×</span> β <span class="o">//</span> <span class="n">f</span> <span class="n">c</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">snd</span><span class="err">}</span>
</code></pre></div></div> <p>That is, given a function <code class="language-plaintext highlighter-rouge">f : α → β</code>, for example the recurrence <code class="language-plaintext highlighter-rouge">maxDollars_spec</code> above, <code class="language-plaintext highlighter-rouge">cell f</code> is the type of all pairs <code class="language-plaintext highlighter-rouge">(a, b) : α × β</code> such that <code class="language-plaintext highlighter-rouge">f a = b</code></p> <p>Our new HashMap, <code class="language-plaintext highlighter-rouge">PropMap</code>, stores keys of type <code class="language-plaintext highlighter-rouge">α</code> and values of type <code class="language-plaintext highlighter-rouge">cell f</code> whose first element is equal to the key:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">abbrev</span> <span class="n">PropMap</span> [<span class="n">BEq</span> α][<span class="n">Hashable</span> α] [<span class="n">LawfulBEq</span> α] (<span class="n">f</span> : α <span class="o">→</span> β) :=
  <span class="n">HashMap</span> α (<span class="n">cell</span> <span class="n">f</span>)
</code></pre></div></div> <p>Now we can define <code class="language-plaintext highlighter-rouge">get?</code> with the guarantee we are looking for:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">PropMap_get</span><span class="err">?</span> [<span class="n">BEq</span> α][<span class="n">Hashable</span> α] [<span class="n">LawfulBEq</span> α] (<span class="n">ft</span> : α <span class="o">→</span> β) (<span class="n">hm</span> : <span class="n">PropMap</span> <span class="n">ft</span>) (<span class="n">a</span> : α) : <span class="n">Option</span> <span class="err">{</span> <span class="n">b</span> : β <span class="o">//</span> <span class="n">ft</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="err">}</span> :=
  <span class="k">match</span> <span class="n">hf</span> : <span class="n">hm</span><span class="o">.</span><span class="n">get</span><span class="err">?</span> <span class="n">a</span> <span class="k">with</span><span class="cd">  -- Attempt to get the value associated with `a` in the map.</span>
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span> <span class="n">none</span><span class="cd">            -- If not found, return `none`.</span>
  <span class="o">|</span> <span class="n">some</span> <span class="n">x</span> <span class="o">=&gt;</span>
    <span class="n">if</span> <span class="n">heq</span> : <span class="n">a</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">fst</span> <span class="n">then</span><span class="cd">  -- Check if the key `a` matches `x.val.fst`.</span>
      <span class="k">have</span> : <span class="n">ft</span> <span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">snd</span> := <span class="k">by</span>
        <span class="k">have</span> <span class="n">hx</span> := <span class="n">x</span><span class="o">.</span><span class="n">property</span><span class="cd">       -- Extract the proof that `ft x.val.fst = x.val.snd`.</span>
        <span class="n">rw</span> [<span class="n">beq_iff_eq</span>] <span class="n">at</span> <span class="n">heq</span><span class="cd">      -- Propositional equality from boolean equality</span>
        <span class="n">rw</span> [<span class="err">←</span> <span class="n">heq</span>] <span class="n">at</span> <span class="n">hx</span><span class="cd">            -- Replace `x.val.fst` with `a` using `heq`.</span>
        <span class="n">exact</span> <span class="n">hx</span><span class="cd">                    -- Conclude that `ft a = x.val.snd`.</span>
      <span class="n">pure</span> <span class="o">⟨</span> <span class="n">x</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">snd</span>, <span class="n">this</span> <span class="o">⟩</span><span class="cd">     -- Return the value and proof as `some`.</span>
    <span class="n">else</span>
      <span class="n">none</span><span class="cd">  -- If the keys don't match (shouldn't happen), return `none`.</span>
</code></pre></div></div> <p>As well as an insertion function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">PropMap_insert</span> [<span class="n">BEq</span> α][<span class="n">Hashable</span> α] [<span class="n">LawfulBEq</span> α] (<span class="n">ft</span> : α <span class="o">→</span> β) (<span class="n">hm</span> : <span class="n">PropMap</span> <span class="n">ft</span>) (<span class="n">k</span> : α) (<span class="n">v</span> : β) (<span class="n">h</span> : <span class="n">ft</span> <span class="n">k</span> <span class="o">=</span> <span class="n">v</span>) : <span class="n">PropMap</span> <span class="n">ft</span> :=
  <span class="n">let</span> <span class="n">cell</span> : <span class="err">{</span> <span class="n">c</span> : α <span class="o">×</span> β <span class="o">//</span> <span class="n">ft</span> <span class="n">c</span><span class="o">.</span><span class="n">fst</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">snd</span> <span class="err">}</span> := <span class="o">⟨</span>(<span class="n">k</span>, <span class="n">v</span>), <span class="n">h</span><span class="o">⟩</span><span class="cd">  -- Create the cell with proof.</span>
  <span class="n">hm</span><span class="o">.</span><span class="n">insert</span> <span class="n">k</span> <span class="n">cell</span><span class="cd">  -- Insert the cell into the map at key `k`.</span>
</code></pre></div></div> <p>And now we can define our recursive helper:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">helper</span> (<span class="n">n</span> : <span class="n">Nat</span>) (<span class="n">memo</span> : <span class="n">PropMap</span> <span class="n">maxDollars_spec</span>) :
  <span class="err">{</span> <span class="n">v</span> : <span class="n">Nat</span> <span class="o">//</span> <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> <span class="err">}</span> <span class="o">×</span> <span class="n">PropMap</span> <span class="n">maxDollars_spec</span> :=
  <span class="k">match</span> <span class="n">PropMap_get</span><span class="err">?</span> <span class="n">maxDollars_spec</span> <span class="n">memo</span> <span class="n">n</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">some</span> <span class="n">result</span> <span class="o">=&gt;</span><span class="cd">
    -- If `n` is already in the memoization map, return the cached value and the memo.
    -- `result` has type `{ v : Nat // maxDollars_spec n = v }`.</span>
    (<span class="n">result</span>, <span class="n">memo</span>)
  <span class="o">|</span> <span class="n">none</span> <span class="o">=&gt;</span>
    <span class="n">if</span> <span class="n">h</span> : <span class="n">n</span> <span class="o">≤</span> <span class="mi">8</span> <span class="n">then</span><span class="cd">
      -- Base case: for `n ≤ 8`.</span>
      <span class="n">let</span> <span class="n">v</span> := <span class="n">n</span>
      <span class="n">let</span> <span class="n">h_spec</span> : <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> := <span class="k">by</span> <span class="n">simp</span> [<span class="n">maxDollars_spec</span>, <span class="n">h</span><span class="cd">
      -- Prove that `maxDollars_spec n = n` using simplification.</span>
      <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">PropMap_insert</span> <span class="n">maxDollars_spec</span> <span class="n">memo</span> <span class="n">n</span> <span class="n">v</span> <span class="n">h_spec</span><span class="cd">
      -- Insert `(n, v)` with proof into the memoization map.</span>
      (<span class="o">⟨</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">⟩</span>, <span class="n">memo</span><span class="err">'</span>)
    <span class="n">else</span><span class="cd">
      -- Recursive case: compute the values for `n / 2`, `n / 3`, and `n / 4`.</span>
      <span class="n">let</span> (<span class="n">r1</span>, <span class="n">memo1</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">2</span>) <span class="n">memo</span>
      <span class="n">let</span> (<span class="n">r2</span>, <span class="n">memo2</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">3</span>) <span class="n">memo1</span>
      <span class="n">let</span> (<span class="n">r3</span>, <span class="n">memo3</span>) := <span class="n">helper</span> (<span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>) <span class="n">memo2</span><span class="cd">
      -- `r1`, `r2`, `r3` are of type `{ v : Nat // maxDollars_spec (n / x) = v }`. Basically an induction hypothesis.
      -- `memo3` is the updated memoization map after all recursive calls.</span>
      <span class="n">let</span> <span class="n">exchangeSum</span> := <span class="n">r1</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">r2</span><span class="o">.</span><span class="n">val</span> <span class="o">+</span> <span class="n">r3</span><span class="o">.</span><span class="n">val</span><span class="cd">  -- Sum the values obtained from recursion.</span>
      <span class="n">let</span> <span class="n">v</span> := <span class="n">max</span> <span class="n">n</span> <span class="n">exchangeSum</span><span class="cd">  -- Decide whether to sell `n` directly or exchange it.

      -- **Construct the proof that `maxDollars_spec n = v`**</span>
      <span class="k">have</span> <span class="n">h_spec</span> : <span class="n">maxDollars_spec</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span> := <span class="k">by</span>
        <span class="n">unfold</span> <span class="n">maxDollars_spec</span><span class="cd">         -- Expand `maxDollars_spec n`.</span>
        <span class="n">rw</span> [<span class="n">if_neg</span> <span class="n">h</span>]                  <span class="cd">-- Since `n &gt; 8`, use the recursive case.</span>
        <span class="n">rw</span> [<span class="n">r1</span><span class="o">.</span><span class="n">property</span>, <span class="n">r2</span><span class="o">.</span><span class="n">property</span>, <span class="n">r3</span><span class="o">.</span><span class="n">property</span><span class="cd">

      -- Replace recursive calls with their computed values using the proofs from `r1`, `r2`, `r3`.</span>
      <span class="n">let</span> <span class="n">memo</span><span class="err">'</span> := <span class="n">PropMap_insert</span> <span class="n">maxDollars_spec</span> <span class="n">memo3</span> <span class="n">n</span> <span class="n">v</span> <span class="n">h_spec</span><span class="cd">
      -- Insert the computed value and its proof into the memoization map.</span>
      (<span class="o">⟨</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">⟩</span>, <span class="n">memo</span><span class="err">'</span>)  <span class="cd">-- Return the computed value with proof and the updated memo.</span>
</code></pre></div></div> <p>Look here. Subtypes require proofs that their value satisfies their logical property. Thus each time our algorithm computes a value <code class="language-plaintext highlighter-rouge">v</code> to go in our table, we also compute a proof that <code class="language-plaintext highlighter-rouge">v</code> is computed correctly according to <code class="language-plaintext highlighter-rouge">maxDollars_spec</code>. We are interleaving code and proof and essentially proving correctness <em>inside the algorithm itself</em>.</p> <p>And finally, here is our main function:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="n">maxDollars</span> (<span class="n">n</span> : <span class="n">Nat</span>) : <span class="n">Nat</span> :=
  (<span class="n">helper</span> <span class="n">n</span> (<span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>))<span class="o">.1</span>
</code></pre></div></div> <p>We’ve embedded the proof into the algorithm itself: every computed value is stored together with a proof that it satisfies the spec. So to prove correctness for any n, we just apply the function — its type guarantees that the result equals maxDollars_spec n:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">maxDollars_spec_correct</span> : <span class="o">∀</span> <span class="n">n</span>, <span class="n">maxDollars</span> <span class="n">n</span> <span class="o">=</span> <span class="n">maxDollars_spec</span> <span class="n">n</span> := <span class="k">by</span>
  <span class="n">intro</span> <span class="n">n</span>
  <span class="n">unfold</span> <span class="n">maxDollars</span>
  <span class="n">let</span> <span class="o">⟨</span><span class="n">v</span>, <span class="n">h_spec</span><span class="o">⟩</span> := (<span class="n">helper</span> <span class="n">n</span> <span class="n">HashMap</span><span class="o">.</span><span class="n">empty</span>)<span class="o">.1</span>
  <span class="n">exact</span> <span class="n">h_spec</span><span class="o">.</span><span class="n">symm</span>
</code></pre></div></div> <p>And we’re done. The algorithm has been verified.</p> <h2 id="5-conclusion">5. <a name="Conclusion"></a>Conclusion</h2> <p>My goal here was to share what I learned from this technique and show how it can be applied to a particular problem. I also hope the reader came away understanding subtypes from the perspective of dependent type theory. I find intertwining code with proof in this way really cool and the people I’ve shown this to felt the same.</p> <p>To review what we did:</p> <ul> <li> <p>We introduced the Bytelandian Gold Coins problem and wrote a basic recursive specification using a natural recurrence relation.</p> </li> <li> <p>We implemented a naive memoized version using a <code class="language-plaintext highlighter-rouge">HashMap</code>, and discussed why proving its correctness directly is tough due to the difficulty of reasoning about data structure invariants.</p> </li> <li> <p>We took a detour into type theory to study subtypes and $\Sigma$-types as a way to attach logical properties to data.</p> </li> <li> <p>We defined a new form of memoization table (<code class="language-plaintext highlighter-rouge">PropMap</code>) that stores not just computed values, but also <em>proofs</em> that they were computed correctly with respect to the spec.</p> </li> <li> <p>We rewrote the algorithm so that correctness was proven incrementally, at every step, as a side effect of evaluation - embedding the proof <em>into</em> the recursion.</p> </li> <li> <p>We ended with a trivial top-level proof: correctness follows directly from the structure of the implementation.</p> </li> </ul> <p>All this code is available at <a href="https://github.com/tannerduve/coins">this repo</a></p> <h2 id="6-exercises">6. <a name="Exercises"></a>Exercises</h2> <p>Each of the following DP problems can be solved using the same framework introduced in this post: define a recurrence relation as a specification, write a memoized implementation that returns values paired with correctness proofs via subtypes, and prove the top-level function computes the intended result.</p> <p>Try implementing and verifying your favorite(s) of the following:</p> <ul> <li> <p><strong>Rod Cutting</strong> Given a rod of length <code class="language-plaintext highlighter-rouge">n</code> and a list of prices <code class="language-plaintext highlighter-rouge">p : List ℕ</code> where <code class="language-plaintext highlighter-rouge">p[i]</code> is the price of a rod of length <code class="language-plaintext highlighter-rouge">i + 1</code>, define:</p> \[r(n) = \max_{1 \le i \le n} (p[i{-}1] + r(n - i))\] <p>Implement <code class="language-plaintext highlighter-rouge">rodCut : ℕ → ℕ</code> using a memoization table and prove correctness</p> </li> <li> <p><strong>0/1 Knapsack</strong> Given <code class="language-plaintext highlighter-rouge">n</code> items with weights <code class="language-plaintext highlighter-rouge">w : Fin n → ℕ</code>, values <code class="language-plaintext highlighter-rouge">v : Fin n → ℕ</code>, and a maximum capacity <code class="language-plaintext highlighter-rouge">C</code>, define:</p> \[\text{knapsack}(i, c) = \begin{cases} 0, &amp; i = n \\ \text{knapsack}(i+1, c), &amp; w[i] &gt; c \\ \max(\text{knapsack}(i+1, c),\ v[i] + \text{knapsack}(i+1, c - w[i])), &amp; \text{otherwise} \end{cases}\] <p>Implement and verify <code class="language-plaintext highlighter-rouge">knapsack : ℕ → ℕ</code> using a memo table indexed by item and capacity.</p> </li> <li> <p><strong>Levenshtein Distance</strong> Given two strings <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">t</code>, define their edit/Levenshtein distance:</p> \[\text{dist}(i, j) = \begin{cases} i, &amp; j = 0 \\ j, &amp; i = 0 \\ \min\!\left( \text{dist}(i{-}1, j) + 1,\; \text{dist}(i, j{-}1) + 1,\; \text{dist}(i{-}1, j{-}1) + \text{cost} \right), &amp; \text{otherwise} \end{cases}\] <p>where <code class="language-plaintext highlighter-rouge">cost = 0</code> if <code class="language-plaintext highlighter-rouge">s[i-1] = t[j-1]</code> and <code class="language-plaintext highlighter-rouge">1</code> otherwise. Implement and verify <code class="language-plaintext highlighter-rouge">editDist : String → String → ℕ</code>.</p> </li> </ul> <p>In each case, define the specification as a recursive function, then write a subtype-verified implementation using a <code class="language-plaintext highlighter-rouge">PropMap</code> to cache and prove subproblem results. Your goal is a final theorem of the form:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">theorem</span> <span class="n">algorithm_correct</span> : <span class="o">∀</span> <span class="n">input</span>, <span class="n">algorithm</span> <span class="n">input</span> <span class="o">=</span> <span class="n">spec</span> <span class="n">input</span>
</code></pre></div></div> <h2 id="7-references">7. <a name="References"></a>References</h2> <p><a href="https://gasstationmanager.github.io/ai/2024/12/03/memoization1.html">Proving Memoization in Lean, And Teaching it to Sonnet</a>, GasStationManager</p>]]></content><author><name></name></author><category term="Formal-Verification"/><category term="Algorithms"/><category term="lean"/><category term="dynamic-programming"/><category term="formal-verification"/><category term="dependent-types"/><category term="sigma-types"/><summary type="html"><![CDATA[Solving a competitive programming problem and proving it correct with dependent types]]></summary></entry></feed>