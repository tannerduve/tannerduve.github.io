---
title: "The Free-er Monad"
layout: single
permalink: /blog/freeer-monad/
---

🚧 Under construction 📐

## Intro

This post will introduce the freer monad, aka the operational monad, in Lean — from categorical foundations to programming applications. We will cover what it means to be “free” in mathematics, what are free monads in categories and in code, and introduce freer monads as a solution to a certain type-theoretic obstacle to defining free monads in Lean. We will then use what we've learned to build and verify a small interpreter which makes elegant use of freeness.

This post assumes you know basic concepts from both category theory and functional programming, including functors, monads, and inductive datatypes.

## Free Objects

Before getting into free monads, we will first consider what it means for some structure to be “free”. This section is pretty mathematical but if you're like me it may help understand things down the line when we start coding, otherwise you can skim this section.

As a familiar example, consider a vector space $V$ over a field $F$ with basis $B$. $V$ is said to be “free” on $B$ — it is the smallest vector space containing $B$, and is generated by taking all finite linear combinations of elements in $B$ with coefficients in $F$. A similar construction is done for other algebraic structures, for example the free group $G_S$ on a set $S$ consists of all the “reduced words” of elements of $S$.

The free object which is most familiar to the programmer is the free monoid on a datatype $\alpha$ — aka the type `List α`. This is of course the type of all finite sequences of elements of $\alpha$, which forms the monoid $(\text{List } \alpha, ++, [\ ])$, where $++$ is list concatenation.

How can we generalize this? In general categories, free constructions are defined as left adjoints to forgetful functors. If a forgetful functor $U : C \to D$ has a left adjoint $F : D \to C$, then for any $x \in D$, $Fx$ is the free $C$-object on $x$. Consider the functor $U : \texttt{Grp} \to \texttt{Set}$ which forgets the group structure and returns the underlying set. If $F : \texttt{Set} \to \texttt{Grp}$ is left adjoint to $U$, then $FX$ is the free group on $X$ for any set $X$.

This can also be stated in terms of a universal property. Slightly informally, an object $X'$ is the free $C$-object on $X$ if there is an embedding $\iota : X \to X'$ such that for any $C$-object $G$ with a map $h : X \to G$, there is a unique $C$-morphism $\hat{h} : X' \to G$ such that the following diagram commutes:

![Universal Property Diagram](images/tikz.png)

The moral of the story here is that a free construction is the canonical way to generate the desired structure from some underlying data, adding only what is necessary to satisfy the rules of the desired structure. Our free monad is thus the canonical monad generated from an endofunctor, satisfying nothing other than the monad laws.

## Free Monads

We've all heard the joke, “a monad is just a monoid in the category of endofunctors, what's the problem?” Understanding monads as monoids may actually help us construct the free monad by analogy to the free monoid — aka the `List` type constructor. I know I promised this was an article on Lean but we will start with some Haskell first.

### In Haskell

The `List` type is defined as follows:

```haskell
data List a = Nil | Cons a (List a)
```

Categorically this looks like:

$$L_a \cong \mathbf{1} + (a \times L_a)$$

i.e. the `List` type is a fixed point of the functor:

$$F_a(x) = \mathbf{1} + (a \times x)$$

Well, since the `List` functor maps a type to its free monoid, and we want our free monad functor to map an endofunctor to its free monad, we “lift” what we have done on lists in the category of types to free monads in the category of endofunctors. In this sense, lists are to types as free monads are to endofunctors.

Our monoidal product in the endofunctor category is functor composition, the terminal object is the identity functor, and coproduct is defined component-wise, thus the analogous functor is:

$$\Phi_F(G) = \text{Id} + F \circ G$$

Our free monad is the (least) fixed point:

$$\text{Free}_F \cong \text{Id} + F \circ \text{Free}_F$$

Finally we are all done with the category theory for this article. Let's now write our free monad in code:

```haskell
data Free f a = Pure a | Free (f (Free f a))
```

To be more explicit with the types, we have the constructors:

```haskell
Pure :: a -> Free f a
Free :: f (Free f a) -> Free f a
```

Convince yourself that this definition corresponds to the categorical one we gave above.

This already kind of looks like a monad by definition! Now, given that `f` is a functor, we can define a straightforward monad instance on `Free f` as follows:

```haskell
instance Functor f => Monad (Free f) where
  return = Pure
  Pure x >>= f = f x
  Free g >>= f = Free ((>>= f) <$> g)
```

### In Lean

Now, as promised, we will do the rest of our work in Lean. Let's write the same definition in Lean:

```lean
inductive Free (f : Type → Type) (a : Type) where
  | pure : a → Free f a
  | free : f (Free f a) → Free f a
```

Weird. We get this opaque error message:

```
-- error: (kernel) arg #3 of `Free.free' contains a non valid occurrence of the
datatypes being declared
```

What could this mean?

In Lean (and other dependently typed languages like Coq or Agda), all functions must terminate. This ensures logical consistency, since proofs correspond to programs. To enforce this, inductive types are subject to the **strict positivity** requirement — the type being defined may not appear to the left of an arrow in its own constructor arguments.

Since `Free f a = Pure a | Free (f (Free f a))` violates this when `f` is contravariant, Lean rejects it.

#### The Freer Monad

The workaround is to switch to a freer representation:

```lean
inductive Free (f : Type → Type) (a : Type) where
  | pure : a → Free f a
  | bind : ∀ x, f x → (x → Free f a) → Free f a
```

This encoding is strictly positive, and in fact even works without requiring that `f` be a functor.

We can define `Functor` and `Monad` instances as usual, then prove the relevant laws — which Lean will check for us. We leave that to the next section.