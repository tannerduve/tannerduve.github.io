## Intro

This post will introduce the freer monad, aka the operational monad, in Lean — from categorical foundations to programming applications. We will cover what it means to be "free" in mathematics, what are free monads in categories and in code, and introduce freer monads as a solution to a certain type-theoretic obstacle to defining free monads in Lean. We will then use what we've learned to build and verify a small interpreter which makes elegant use of freeness.

This post assumes you know basic concepts from both category theory and functional programming, including functors, monads, and inductive datatypes.

## Free Objects

Before getting into free monads, we will first consider what it means for some structure to be "free". This section is pretty mathematical but if you're like me it may help understand things down the line when we start coding, otherwise you can skim this section.

As a familiar example, consider a vector space \(V\) over a field \(F\) with basis \(B\). \(V\) is said to be "free" on \(B\) — it is the smallest vector space containing \(B\), and is generated by taking all finite linear combinations of elements in \(B\) with coefficients in \(F\). A similar construction is done for other algebraic structures — for example the free group \(G_S\) on a set \(S\) consists of all the reduced words of elements of \(S\).

The free object which is most familiar to the programmer is the free monoid on a datatype \(\alpha\) — aka the type `List α`. This is of course the type of all finite sequences of elements of \(\alpha\), which forms the monoid \((\text{List } \alpha, ++, [\ ])\), where `++` is list concatenation.

How can we generalize this? In general categories, free constructions are defined as left adjoints to forgetful functors. If a forgetful functor \(U : C \to D\) has a left adjoint \(F : D \to C\), then for any \(x \in D\), \(Fx\) is the free \(C\)-object on \(x\). 

Consider the functor \(U : \texttt{Grp} \to \texttt{Set}\) which forgets the group structure and returns the underlying set. If \(F : \texttt{Set} \to \texttt{Grp}\) is left adjoint to \(U\), then \(FX\) is the free group on \(X\) for any set \(X\).

This can also be stated in terms of a universal property. Slightly informally, an object \(X'\) is the free \(C\)-object on \(X\) if there is an embedding \(\iota : X \to X'\) such that for any \(C\)-object \(G\) with a map \(h : X \to G\), there is a unique \(C\)-morphism \(\hat{h} : X' \to G\) such that the following diagram commutes:

<div style="text-align: center;">
  <img src="https://raw.githubusercontent.com/tannerduve/tannerduve.github.io/master/images/tikz.png" alt="tikz diagram" />
</div>

*(Exercise: Let \(U : \texttt{Grp} \to \texttt{Set}\) be the forgetful functor and \(F\) a left adjoint. Prove \(FX\) satisfies the above universal property for any set \(X\).)*

The moral of the story here is that a free construction is the canonical way to generate the desired structure from some underlying data, adding only what is necessary to satisfy the rules of the desired structure. Our free monad is thus the canonical monad generated from an endofunctor, satisfying nothing other than the monad laws.

## Free Monads

We've all heard the joke, "a monad is just a monoid in the category of endofunctors, what's the problem?" Understanding monads as monoids may actually help us construct the free monad by analogy to the free monoid — aka the List type constructor. I know I promised this was an article on Lean but we will start with some Haskell first.

### In Haskell

The List type is defined as follows:

```haskell
data List a = Nil | Cons a (List a)
```

Categorically this looks like:

$$
L_a \cong \mathbf{1} + (a \times L_a)
$$

i.e., the List type is a fixed point of the functor:

$$
F_a x = \mathbf{1} + (a \times x)
$$

(see: inductive types as initial algebras — [link to be filled]).

Well, since the List functor maps a type to its free monoid, and we want our free monad functor to map an endofunctor to its free monad, we "lift" what we have done on lists in the category of types to free monads in the category of endofunctors. In this sense, lists are to types as free monads are to endofunctors. In programmer terms, we are defining a higher-order functor that is analogous to `List`, but acts on functors rather than types.

Our monoidal product in the endofunctor category is functor composition, the terminal object is the identity functor, and coproduct is defined component-wise. Thus the analogous functor is:

$$
\Phi_F G = \text{Id} + F \circ G
$$

Note how this corresponds to the above definition of `List`. Our free monad is the (least) fixed point:

$$
\text{Free}_F \cong \text{Id} + F \circ \text{Free}_F
$$

Finally we are all done with the category theory for this article. Let's now write our free monad in code:

```haskell
data Free f a = Pure a | Free (f (Free f a))
```

To be more explicit with the types, we have the constructors:

```haskell
Pure :: a -> Free f a
Free :: f (Free f a) -> Free f a
```

Convince yourself that this definition corresponds to the categorical one we gave above.

This already kind of looks like a monad by definition! Now, given that `f` is a functor, we can define a straightforward monad instance on `Free f` as follows:

```haskell
instance Functor f => Monad (Free f) where
  return = Pure
  Pure x >>= f = f x
  Free g >>= f = Free ((>>= f) <\(> g)
```

### In Lean

Now, as promised, we will do the rest of our work in Lean. Let's write the same definition in Lean:

```lean
inductive Free (f : Type → Type) (a : Type) where
  | pure : a → Free f a
  | free : f (Free f a) → Free f a
```

Weird. We get this opaque error message:

```
-- error: (kernel) arg #3 of `Free.free' contains a non valid occurrence of the
datatypes being declared
```

What could this mean?

Recall that, in languages like Lean (or Coq, or Agda), in order for the proof system to be consistent, all functions must terminate. Proofs correspond to programs, and if we had programs that could loop forever, we could prove anything, and our logic would be useless.

To enforce this, defining inductive types has a restriction, called **strict positivity**. Strict positivity disallows contravariant occurrences of self-reference in the constructors of an inductive type. In simpler terms, an inductive type definition cannot refer to itself on the left side of an arrow in the constructors. If Lean allowed this definition, we could inhabit the empty type (i.e. prove false) using a contravariant functor.

Since the free monad doesn't work due to type-theoretic restrictions, we need a little bit more freedom. Enter: the freer monad. The below definition is strictly positive:

```lean
inductive Free (f : Type -> Type) (a : Type) where
  | pure : a -> Free f a
  | bind : forall x, f x -> (x -> Free f a) -> Free f a
```

In fact, this is *freer* in the sense that we no longer even require `f` to be a functor. Let's define the Functor and Monad instances for this type, given any type constructor G.


We begin by providing a Functor instance, which is just defining a map function, lifting a function \(f : \alpha \to \beta\) to a function \(Ff : \text{Free } F \ \alpha \to \text{Free } F \ \beta\):

```lean
def Free.map {a b : Type} (F : Type → Type) (f : a → b) : Free F a → Free F b :=
fun FFa =>
match FFa with
| pure a => Free.pure (f a)
| bind X Fx k => Free.bind X Fx (fun z => map F f (k z))

instance : Functor (Free F) where
map := Free.map F
```

Now we can provide a monad instance by defining `pure` and `bind` as follows:

```lean
def bindFree {a b : Type} (F : Type → Type) (x : Free F a) (f : a → Free F b) : Free F b :=
match x with
| .pure a => f a
| .bind X Fx k => .bind X Fx (fun z => bindFree F (k z) f)

instance FreeMonad (F : Type → Type) : Monad (Free F) where
  pure := Free.pure
  bind := bindFree F
```

Of course we all love Lean because you can actually prove things about the code you write. Lean provides not just a `Monad` typeclass, but a `LawfulMonad` typeclass, which additionally requires explicit proofs that the monad laws are satisfied. Let's do this for fun.

We first prove it is a lawful functor, i.e. it is *functorial* in the following sense:

- Identity law: \(\text{map}\ id = id\)
- Composition law: \(\text{map}\ (g \circ f) = \text{map}\ g \circ \text{map}\ f\)

```lean
instance : LawfulFunctor (Free F) where
map_const := by
  intro a b
  simp [Functor.mapConst, Functor.map]
id_map := by
  intro a x
  simp [Functor.map]
  induction x
  case pure a =>
    simp [Free.map]
  case bind X Fx f ih =>
    simp [Free.map, ih]
comp_map := by
  intro a b c g h x
  simp [Functor.map]
  induction x
  case pure a =>
    simp [Free.map]
  case bind X Fx f ih =>
    simp [Free.map, ih]
```

Now we prove it is a lawful monad, i.e. it satisfies the monadic laws:

- Left identity: \(\text{pure}\ a \gg= f = f\ a\)
- Right identity: \(m \gg= \text{pure} = m\)
- Associativity: \((m \gg= f) \gg= g = m \gg= (\lambda x. f\ x \gg= g)\)
- Naturality (map then bind): \(x \gg= (\lambda a. \text{pure}(f\ a)) = \text{map}\ f\ x\)

```lean
instance : LawfulMonad (Free F) where
bind_pure_comp := by
  intro a b x f
  simp [Functor.map, bindFree, Free.map]
  sorry
bind_map := by sorry 
pure_bind := by
  intro a x f
  sorry
bind_assoc := by sorry 
seqLeft_eq := by
  intro a b x f
  simp [Functor.map, bindFree, Free.map]
  sorry
seqRight_eq := by
  intro a b x f
  simp [Functor.map, bindFree, Free.map]
  sorry
pure_seq := by
  intro a x
  simp [Functor.map, bindFree, Free.map]
  sorry
```

I will fill this proof in.
