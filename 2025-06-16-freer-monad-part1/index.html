<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h2 id="1-introduction">1. <a name="Introduction"></a>Introduction</h2> <p>Free monads provide a way to represent effectful sequential programs as pure syntactic data, separate from their interpretation. You describe <em>what</em> should happen as an abstract tree of effects, leaving open <em>how</em> you want it to happen. By decoupling syntax from semantics like this you gain full control over how programs are evaluated and interpreted - for example we could interpret a syntax tree in multiple ways:</p> <ul> <li>Run it directly</li> <li>Pretty print it</li> <li>Analyze it statically</li> </ul> <p>Each of these corresponds to a different interpreter. This approach also allows effects to be combined without you having to get tangled up in monad transformers.</p> <p>This four-part series will introduce the free monad in Lean. In this first part we will introduce and implement the free monad from first principles, and discuss some of the finesse involved in implementing it in a proof assistant like Lean, compared to a functional language like Haskell.</p> <p>In part 2 we will further explore some theory and study initial algebras and catamorphisms, and how they give rise to interpreters for effectful computation trees. In part 3 we will study the universal property of free monads and what it provides for us as programmers. Finally in part 4, we will use what we’ve learned to build and verify a real interpreter for a small language, making elegant use of freeness to combine effectful computations.</p> <p>This series assumes you know basic concepts from both category theory and functional programming, including functors, monads, and inductive datatypes. You can find most of the code used here at <a href="https://github.com/leanprover-community/mathlib4/pull/25491" rel="external nofollow noopener" target="_blank">this Mathlib PR</a></p> <h2 id="table-of-contents">Table of Contents</h2> <ol> <li><a href="#Introduction">Introduction</a></li> <li><a href="#FreeObjects">Free Objects</a></li> <li> <a href="#FreeMonads">Free Monads</a> <ul> <li><a href="#InHaskell">In Haskell</a></li> <li><a href="#InLean">In Lean</a></li> </ul> </li> <li><a href="#Conclusion">Conclusion</a></li> </ol> <h2 id="2-free-objects">2. <a name="FreeObjects"></a>Free Objects</h2> <p>Before getting into free monads, we will first consider what it means for some structure to be “free”. This section is pretty mathematical but if you’re like me it may help understand things down the line when we start coding, otherwise you can skim this section.</p> <p>As a familiar example, consider a vector space $V$ over a field $F$ with basis $B$. $V$ is said to be “free” on $B$: it is the smallest vector space containing $B$, and is generated by taking all finite linear combinations of elements in $B$ with coefficients in $F$. A similar construction is done for other algebraic structures, for example the free group $G_S$ on a set $S$ consists of all the reduced words of elements of $S$.</p> <p>The free object which is most familiar to the programmer is the free monoid on a datatype <code class="language-plaintext highlighter-rouge">α</code>, aka the type <code class="language-plaintext highlighter-rouge">List α</code>. This is of course the type of all finite sequences of elements of <code class="language-plaintext highlighter-rouge">α</code>, which forms the monoid <code class="language-plaintext highlighter-rouge">(List α, ++, [])</code>, where <code class="language-plaintext highlighter-rouge">++</code> is list concatenation.</p> <p>How can we generalize this? In general categories, free constructions are defined as left adjoints to forgetful functors. If a forgetful functor $U : C \to D$ has a left adjoint $F : D \to C$, then for any $x \in D$, $Fx$ is the free $C$-object on $x$.</p> <p>Consider the functor $U : \texttt{Grp} \to \texttt{Set}$ which forgets the group structure and returns the underlying set. If $F : \texttt{Set} \to \texttt{Grp}$ is left adjoint to $U$, then $FX$ is the free group on $X$ for any set $X$.</p> <p>This can also be stated in terms of a universal property. Slightly informally, an object $X’$ is the free $C$-object on $X$ if there is an embedding $\iota : X \to X’$ such that for any $C$-object $G$ with a map $h : X \to G$, there is a unique $C$-morphism $\hat{h} : X’ \to G$ such that the following diagram commutes:</p> <div style="text-align: center;"> <span style="display: inline-block;"> <script type="text/tikz">
      \begin{tikzcd}[scale=2, column sep=huge, row sep=huge]
        {X'} && G \\
        \\
        X
        \arrow["{\hat{h}}", dashed, from=1-1, to=1-3]
        \arrow["\iota", from=3-1, to=1-1]
        \arrow["h"', from=3-1, to=1-3]
      \end{tikzcd}
    </script> </span> </div> <p><em>(Exercise: Let $U : \texttt{Grp} \to \texttt{Set}$ be the forgetful functor and $F$ a left adjoint. Prove $FX$ satisfies the above universal property for any set $X$.)</em></p> <p>The moral of the story here is that a free construction is the canonical way to generate the desired structure from some underlying data, adding only what is necessary to satisfy the rules of the desired structure. Our free monad is thus the canonical monad generated from an endofunctor, satisfying nothing other than the monad laws.</p> <h2 id="3-free-monads">3. <a name="FreeMonads"></a>Free Monads</h2> <blockquote> <p>“A monad is just a monoid in the category of endofunctors, what’s the problem?”</p> </blockquote> <p>You’ve probably heard someone jokingly say monads are <em>just</em> monoids in the category of endofunctors. It’s technically a correct definition, but it tells you nothing if you don’t speak category theory. However, understanding monads as monoids may actually help us construct the free monad by analogy to the free monoid, aka the <code class="language-plaintext highlighter-rouge">List</code> type. I know I promised this was an article on Lean but we will start with some Haskell first.</p> <h3 id="31-in-haskell">3.1. <a name="InHaskell"></a>In Haskell</h3> <p>The List type is defined as follows:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">List</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Nil</span> <span class="o">|</span> <span class="kt">Cons</span> <span class="n">a</span> <span class="p">(</span><span class="kt">List</span> <span class="n">a</span><span class="p">)</span> 
</code></pre></div></div> <p>Categorically this looks like:</p> \[L_a \cong \mathbf{1} + (a \times L_a)\] <p>i.e., the List type is a fixed point of the functor:</p> \[F_a x = \mathbf{1} + (a \times x)\] <p><em><a href="/blog/freer-monad/part2/">Part 2</a> goes into more detail about inductive types as fixed points of functors. This part is just briefly explaining the analogy between lists and free monads, and the mathematical detail is not centrally important yet</em></p> <p>The List functor maps a type to its free monoid, and we want our free monad functor to map an endofunctor to its free monad. The heart of the analogy is that lists are to types as free monads are to functors. So, we “lift” what we have done on lists in the category of types to free monads in the category of endofunctors. In programmer terms, we are defining a higher-order functor that is analogous to <code class="language-plaintext highlighter-rouge">List</code>, but acts on functors rather than types.</p> <p>Our monoidal product in the endofunctor category is functor composition, the terminal object is the identity functor, and coproduct is defined component-wise. Thus the analogous functor is:</p> \[\Phi_F G = \text{Id} + F \circ G\] <p>Note how this corresponds to the above definition of <code class="language-plaintext highlighter-rouge">List</code>. Our free monad is the (least) fixed point:</p> \[\text{Free}_F \cong \text{Id} + F \circ \text{Free}_F\] <p>Finally we are all done with the category theory for this part. Let’s now write our free monad in code:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Pure</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Free</span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span><span class="p">))</span>
</code></pre></div></div> <p>To be more explicit with the types, we have the constructors:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">Pure</span> <span class="o">::</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span>
<span class="kt">Free</span> <span class="o">::</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Free</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div> <p>Convince yourself that this definition corresponds to the categorical one we gave above.</p> <p>This already kind of looks like a monad by definition! Now, given that <code class="language-plaintext highlighter-rouge">f</code> is a functor, we can define a straightforward monad instance on <code class="language-plaintext highlighter-rouge">Free f</code> as follows:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">instance</span> <span class="kt">Functor</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="kt">Monad</span> <span class="p">(</span><span class="kt">Free</span> <span class="n">f</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">return</span> <span class="o">=</span> <span class="kt">Pure</span>
  <span class="kt">Pure</span> <span class="n">x</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="n">f</span> <span class="n">x</span>
  <span class="kt">Free</span> <span class="n">g</span> <span class="o">&gt;&gt;=</span> <span class="n">f</span> <span class="o">=</span> <span class="kt">Free</span> <span class="p">((</span><span class="o">&gt;&gt;=</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="n">g</span><span class="p">)</span>
</code></pre></div></div> <h3 id="32-in-lean">3.2. <a name="InLean"></a>In Lean</h3> <p>Now, as promised, we will do the rest of our work in Lean. Let’s write the same definition in Lean:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">Free</span> (<span class="n">f</span> : <span class="kt">Type</span> <span class="o">→</span> <span class="kt">Type</span>) (<span class="n">a</span> : <span class="kt">Type</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">pure</span> : <span class="n">a</span> <span class="o">→</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>
  <span class="o">|</span> <span class="n">free</span> : <span class="n">f</span> (<span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>) <span class="o">→</span> <span class="n">Free</span> <span class="n">f</span> <span class="n">a</span>
</code></pre></div></div> <p>Weird. We get this opaque error message:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- error: (kernel) arg #3 of `Free.free' contains a non valid occurrence of the
datatypes being declared
</code></pre></div></div> <p>Why does the definition work in Haskell but not Lean?</p> <p><strong>Strict Positivity</strong></p> <p>Recall that, in languages like Lean (or Coq, or Agda), in order for the proof system to be consistent, all functions must terminate. Proofs correspond to programs, and if we had programs that could loop forever, we could prove anything, and our logic would be useless.</p> <p>To enforce this, defining inductive types has a restriction, called <a href="https://www.pls-lab.org/Strictly_positive" rel="external nofollow noopener" target="_blank"><strong>strict positivity</strong></a>. Basically, an inductive type can not refer to itself on the left side of an arrow in its constructors. If Lean allowed this definition, we could inhabit the empty type (i.e. prove False) using a contravariant functor.</p> <p>Since the free monad doesn’t work due to type-theoretic restrictions, we need a little bit more freedom. <em>Enter the freer monad</em>. The below definition is strictly positive:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">inductive</span> <span class="n">FreeM</span><span class="o">.</span><span class="err">{</span><span class="n">u</span>, <span class="n">v</span>, <span class="n">w</span><span class="err">}</span> (<span class="n">f</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span>) (α : <span class="kt">Type</span> <span class="n">w</span>) <span class="n">where</span>
  <span class="o">|</span> <span class="n">pure</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">f</span> α
  <span class="o">|</span> <span class="n">liftBind</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> (<span class="n">op</span> : <span class="n">f</span> <span class="err">ι</span>) (<span class="n">cont</span> : <span class="err">ι</span> <span class="o">→</span> <span class="n">FreeM</span> <span class="n">f</span> α) : <span class="n">FreeM</span> <span class="n">f</span> α
</code></pre></div></div> <p>In fact, this is <em>freer</em> in the sense that we no longer even require <code class="language-plaintext highlighter-rouge">f</code> to be a functor. Let’s define the Functor and Monad instances for this type, given any type constructor.</p> <p><strong>Monad Instance of <code class="language-plaintext highlighter-rouge">FreeM f</code></strong></p> <p>We begin by providing a Functor instance, which is just defining a map function, lifting a function $f : \alpha \to \beta$ to a function $Ff : \text{FreeM } F \ \alpha \to \text{FreeM } F \ \beta$:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">universe</span> <span class="n">u</span> <span class="n">v</span> <span class="n">w</span> <span class="n">w</span><span class="err">'</span> <span class="n">w</span><span class="err">''</span>
<span class="k">namespace</span> <span class="n">FreeM</span>
<span class="k">variable</span> <span class="err">{</span><span class="n">F</span> : <span class="kt">Type</span> <span class="n">u</span> <span class="o">→</span> <span class="kt">Type</span> <span class="n">v</span><span class="err">}</span> <span class="err">{ι</span> : <span class="kt">Type</span> <span class="n">u</span><span class="err">}</span> <span class="err">{</span>α : <span class="kt">Type</span> <span class="n">w</span><span class="err">}</span> <span class="err">{</span>β : <span class="kt">Type</span> <span class="n">w</span><span class="err">'}</span> <span class="err">{γ</span> : <span class="kt">Type</span> <span class="n">w</span><span class="err">''}</span>

<span class="k">def</span> <span class="n">map</span> (<span class="n">f</span> : α <span class="o">→</span> β) : <span class="n">FreeM</span> <span class="n">F</span> α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> β
  <span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">pure</span> (<span class="n">f</span> <span class="n">a</span>)
  <span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">z</span> <span class="o">=&gt;</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">map</span> <span class="n">f</span> (<span class="n">cont</span> <span class="n">z</span>))

<span class="k">instance</span> : <span class="n">Functor</span> (<span class="n">FreeM</span> <span class="n">F</span>) <span class="n">where</span>
  <span class="n">map</span> := <span class="o">.</span><span class="n">map</span>
</code></pre></div></div> <p>Now we can provide a monad instance by defining <code class="language-plaintext highlighter-rouge">pure</code> and <code class="language-plaintext highlighter-rouge">bind</code> as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">protected</span> <span class="k">def</span> <span class="n">bind</span> (<span class="n">x</span> : <span class="n">FreeM</span> <span class="n">F</span> α) (<span class="n">f</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> β) : <span class="n">FreeM</span> <span class="n">F</span> β :=
  <span class="k">match</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">f</span> <span class="n">a</span>
  <span class="o">|</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="o">=&gt;</span> <span class="o">.</span><span class="n">liftBind</span> <span class="n">op</span> (<span class="k">fun</span> <span class="n">z</span> <span class="o">=&gt;</span> <span class="n">FreeM</span><span class="o">.</span><span class="n">bind</span> (<span class="n">cont</span> <span class="n">z</span>) <span class="n">f</span>)

<span class="k">instance</span> : <span class="n">Monad</span> (<span class="n">FreeM</span> <span class="n">F</span>) <span class="n">where</span>
  <span class="n">pure</span> := <span class="o">.</span><span class="n">pure</span>
  <span class="n">bind</span> := <span class="o">.</span><span class="n">bind</span>
</code></pre></div></div> <p>Of course we all love Lean because you can actually prove things about the code you write. Lean provides not just a <code class="language-plaintext highlighter-rouge">Monad</code> typeclass, but a <code class="language-plaintext highlighter-rouge">LawfulMonad</code> typeclass, which additionally requires explicit proofs that the monad laws are satisfied. Let’s do this for fun. Throughout these posts I will be using some lemmas that you can find in the source code whose statements/proofs I won’t expliclty be showing here.</p> <p>We first prove it is a lawful functor, i.e. it is <em>functorial</em> in the categorical sense:</p> <ul> <li>Identity law: $\text{map}\ id = id$</li> <li>Composition law: $\text{map}\ (g \circ f) = \text{map}\ g \circ \text{map}\ f$</li> </ul> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">instance</span> : <span class="n">LawfulFunctor</span> (<span class="n">FreeM</span> <span class="n">F</span>) <span class="n">where</span>
  <span class="n">map_const</span> := <span class="n">rfl</span>
  <span class="n">id_map</span> <span class="n">x</span> := <span class="k">by</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
    <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
      <span class="n">simp_all</span> [<span class="n">map_eq_map</span>, <span class="n">lift_def</span>, <span class="n">map</span>, <span class="n">ih</span>]
  <span class="n">comp_map</span> <span class="n">g</span> <span class="n">h</span> <span class="n">x</span> := <span class="k">by</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
    <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
      <span class="n">simp_all</span> [<span class="n">map_eq_map</span>, <span class="n">lift_def</span>, <span class="n">map</span>, <span class="n">ih</span>]
</code></pre></div></div> <p>Now we prove that our structure is a <strong>lawful monad</strong>, meaning it satisfies the following <strong>monad laws</strong>:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">bind_pure_comp : x &gt;&gt;= (λ a → pure (f a)) = f &lt;$&gt; x</code><br> A bind followed by pure composed with a function is equivalent to a functorial map.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">id_map : id &lt;$&gt; x = x</code><br> Mapping the identity function over a value leaves it unchanged.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">pure_bind : pure x &gt;&gt;= f = f x</code><br> Pure followed by bind is equivalent to function application.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">bind_assoc : (x &gt;&gt;= f) &gt;&gt;= g = x &gt;&gt;= (λ a → f a &gt;&gt;= g)</code><br> Bind is associative.</p> </li> </ul> <p>The proof is as follows:</p> <div class="language-lean highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">-- Lemma that bind is associative</span>
<span class="k">protected</span> <span class="k">theorem</span> <span class="n">bind_assoc</span> (<span class="n">x</span> : <span class="n">FreeM</span> <span class="n">F</span> α) (<span class="n">f</span> : α <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> β) (<span class="n">g</span> : β <span class="o">→</span> <span class="n">FreeM</span> <span class="n">F</span> <span class="err">γ</span>) :
    (<span class="n">x</span><span class="o">.</span><span class="n">bind</span> <span class="n">f</span>)<span class="o">.</span><span class="n">bind</span> <span class="n">g</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">bind</span> (<span class="k">fun</span> <span class="n">x</span> <span class="o">=&gt;</span> (<span class="n">f</span> <span class="n">x</span>)<span class="o">.</span><span class="n">bind</span> <span class="n">g</span>) := <span class="k">by</span>
  <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
  <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
  <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
    <span class="n">simp</span> [<span class="n">FreeM</span><span class="o">.</span><span class="n">bind</span>,  <span class="err">←</span> <span class="n">pure_eq_pure</span>] <span class="n">at</span> <span class="o">*</span>
    <span class="n">simp</span> [<span class="n">ih</span>]

<span class="cd">-- Complete proof that FreeM F is a lawful monad</span>
<span class="k">instance</span> : <span class="n">LawfulMonad</span> (<span class="n">FreeM</span> <span class="n">F</span>) := <span class="n">LawfulMonad</span><span class="o">.</span><span class="n">mk</span><span class="err">'</span>
  (<span class="n">bind_pure_comp</span> := <span class="k">fun</span> <span class="n">f</span> <span class="n">x</span> <span class="o">=&gt;</span> <span class="k">by</span>
    <span class="n">induction</span> <span class="n">x</span> <span class="k">with</span>
    <span class="o">|</span> <span class="n">pure</span> <span class="n">a</span> <span class="o">=&gt;</span> <span class="n">rfl</span>
    <span class="o">|</span> <span class="n">liftBind</span> <span class="n">op</span> <span class="n">cont</span> <span class="n">ih</span> <span class="o">=&gt;</span>
      <span class="n">simp</span> <span class="n">only</span> [<span class="n">FreeM</span><span class="o">.</span><span class="n">bind</span>, <span class="n">bind_eq_bind</span>, <span class="n">map_eq_map</span>, <span class="n">pure_eq_purePure</span>, <span class="n">map</span>] <span class="n">at</span> <span class="o">*</span>
      <span class="n">simp</span> <span class="n">only</span> [<span class="n">ih</span>]
  )
  (<span class="n">id_map</span> := <span class="n">id_map</span>)
  (<span class="n">pure_bind</span> := <span class="k">fun</span> <span class="n">x</span> <span class="n">f</span> <span class="o">=&gt;</span> <span class="n">rfl</span>)
  (<span class="n">bind_assoc</span> := <span class="n">FreeM</span><span class="o">.</span><span class="n">bind_assoc</span>)
</code></pre></div></div> <p>I won’t write out the informal details of the proof, but it is mostly straightforward, we unfold all the definitions using <code class="language-plaintext highlighter-rouge">simp</code>, and in some cases when we have a value of type <code class="language-plaintext highlighter-rouge">FreeM F a</code> we perform induction on it and simplify further using our lemmas.</p> <h2 id="4-conclusion">4. <a name="Conclusion"></a>Conclusion</h2> <p>In this first part of our series, we explored the concept of free objects and introduced the idea of a free monad from a categorical perspective. Starting from familiar examples like free vector spaces and monoids, we generalized the construction to free monads, and implemented the free monad in Lean from the ground up.</p> <p>We discussed the idea of <em>strict positivity</em>, leading us to the freer monad construction as both a workaround and a generalization. We were able to define a monad instance on <code class="language-plaintext highlighter-rouge">FreeM F</code> for any <code class="language-plaintext highlighter-rouge">F : Type -&gt; Type</code>, and proved that it satisfies the monad laws.</p> <h2 id="the-story-continues-in-part-2-with-catamorphisms-interpreters-and-universal-properties"><strong>The story continues in <a href="/blog/freer-monad/part2/">Part 2</a> with catamorphisms, interpreters, and universal properties.</strong></h2> </body></html>